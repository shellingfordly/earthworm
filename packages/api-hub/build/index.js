"use strict";
var wj = Object.create;
var MS = Object.defineProperty;
var Ej = Object.getOwnPropertyDescriptor;
var Rj = Object.getOwnPropertyNames;
var Tj = Object.getPrototypeOf,
  Pj = Object.prototype.hasOwnProperty;
var b = (e, t) => () => (t || e((t = { exports: {} }).exports, t), t.exports);
var $j = (e, t, r, n) => {
  if ((t && typeof t == "object") || typeof t == "function")
    for (let s of Rj(t))
      !Pj.call(e, s) &&
        s !== r &&
        MS(e, s, { get: () => t[s], enumerable: !(n = Ej(t, s)) || n.enumerable });
  return e;
};
var Jr = (e, t, r) => (
  (r = e != null ? wj(Tj(e)) : {}),
  $j(t || !e || !e.__esModule ? MS(r, "default", { value: e, enumerable: !0 }) : r, e)
);
var zS = b((ine, ah) => {
  "use strict";
  var We = {},
    ih;
  function El(e) {
    return (
      ih ?? (ih = (process.execArgv ?? []).concat(process.argv ?? [])),
      ih.some((t) => t.indexOf(e) >= 0)
    );
  }
  var Pl;
  function Rl(e) {
    return Pl ?? (Pl = process._preload_modules ?? []), Pl.includes(e);
  }
  var oh;
  function Oj(e) {
    return oh ?? (oh = Pl.toString()), oh.includes(e);
  }
  function Tl(e, t) {
    return t ? process.env[e] === t : process.env[e] !== void 0;
  }
  var Qr = {};
  Object.defineProperties(Qr, {
    tsNode: {
      get() {
        return (
          We.tsNode ??
            (We.tsNode =
              Symbol.for("ts-node.register.instance") in process ||
              El("ts-node/esm") ||
              !!process.env.TS_NODE_DEV),
          We.tsNode
        );
      },
    },
    babelNode: {
      get() {
        return We.babelNode ?? (We.babelNode = El("babel-node")), We.babelNode;
      },
    },
    vitest: {
      get() {
        return We.vitest ?? (We.vitest = Tl("VITEST", "true") || Tl("VITEST_WORKER_ID")), We.vitest;
      },
    },
    jest: {
      get() {
        return We.jest ?? (We.jest = Tl("JEST_WORKER_ID")), We.jest;
      },
    },
    swc: {
      get() {
        return (
          We.swc ??
            (We.swc = Rl("@swc/register") || Rl("@swc-node/register") || El(".bin/swc-node")),
          We.swc
        );
      },
    },
    tsm: {
      get() {
        return We.tsm ?? (We.tsm = Rl("tsm")), We.tsm;
      },
    },
    esbuild: {
      get() {
        return We.esbuild ?? (We.esbuild = Rl("esbuild-register")), We.esbuild;
      },
    },
    tsx: {
      get() {
        return We.tsx ?? (We.tsx = Oj("tsx")), We.tsx;
      },
    },
    supportTypeScript: {
      get() {
        return (
          We.supportTypeScript ??
            (We.supportTypeScript =
              Tl("FASTIFY_AUTOLOAD_TYPESCRIPT") ||
              Qr.tsNode ||
              Qr.vitest ||
              Qr.babelNode ||
              Qr.jest ||
              Qr.swc ||
              Qr.tsm ||
              Qr.tsx ||
              Qr.esbuild),
          We.supportTypeScript
        );
      },
    },
    forceESM: {
      get() {
        return We.forceESM ?? (We.forceESM = El("ts-node/esm") || Qr.vitest || !1), We.forceESM;
      },
    },
  });
  ah.exports = Qr;
  ah.exports.runtime = Qr;
});
var YS = b((one, Al) => {
  "use strict";
  var {
      promises: { readdir: Nj, readFile: Aj },
    } = require("node:fs"),
    { join: $l, relative: Ij, sep: VS } = require("node:path"),
    { pathToFileURL: GS } = require("node:url"),
    Ol = zS(),
    US = /\/_/gu,
    HS = /__/gu,
    Cj = {
      scriptPattern: /(?:(?:^.?|\.[^d]|[^.]d|[^.][^d])\.ts|\.js|\.cjs|\.mjs|\.cts|\.mts)$/iu,
      indexPattern: /^index(?:\.ts|\.js|\.cjs|\.mjs|\.cts|\.mts)$/iu,
      autoHooksPattern: /^[_.]?auto_?hooks(?:\.ts|\.js|\.cjs|\.mjs|\.cts|\.mts)$/iu,
      dirNameRoutePrefix: !0,
      encapsulate: !0,
    },
    Nl = async function (t, r) {
      let n = await kj(r.dir),
        s = { ...Cj, packageType: n, ...r },
        i = await lh(s.dir, s),
        o = {},
        a = {},
        u = [].concat.apply(
          [],
          Object.values(i).map((p) => p.plugins),
        ),
        l = [].concat.apply(
          [],
          Object.values(i).map((p) => p.hooks),
        ),
        c = r.options?.prefix ?? "";
      c[c.length - 1] === "/" && (c = c.slice(0, -1)),
        await Promise.all(
          u.map(({ file: p, type: y, prefix: _ }) =>
            Lj({ file: p, type: y, directoryPrefix: _, options: s, log: t.log })
              .then((S) => {
                S &&
                  (r.routeParams &&
                    (S.options.prefix = S.options.prefix ? f(S.options.prefix) : S.options.prefix),
                  (o[S.name] = S));
              })
              .catch((S) => {
                throw KS(S);
              }),
          ),
        );
      function f(p) {
        let y = p.match(US);
        return p.match(HS) ? p.replace(HS, ":") : y ? p.replace(US, "/:") : p;
      }
      await Promise.all(
        l.map((p) =>
          Fj(p, s)
            .then((y) => {
              a[p.file] = y;
            })
            .catch((y) => {
              throw KS(y);
            }),
        ),
      );
      let d = Object.values(o);
      for (let p in i) {
        let y = i[p].hooks,
          _ = i[p].plugins;
        if (y.length === 0) h(t, _);
        else {
          let S = async function (E) {
            for (let g of y) {
              let m = a[g.file];
              E.register(m);
            }
            h(E, _, !0);
          };
          t.register(S, { prefix: c + f(p) });
        }
      }
      function h(p, y, _ = !1) {
        for (let S of y) {
          let E = d.find((g) => g.filename === S.file);
          _ && (E.options.prefix = void 0), E && JS(p, E, o);
        }
      }
    };
  async function kj(e) {
    let t = e.split(VS);
    for (t[0] = t[0] !== "" ? t[0] : VS; t.length > 0; ) {
      let r = $l(...t, "package.json"),
        n = await Aj(r, "utf-8").catch(() => null);
      if (n) return JSON.parse(n).type;
      t.pop();
    }
  }
  var Dj = /\.(ts|mts|cts)$/iu,
    qj = /\.(mjs|mts)$/iu,
    jj = /\.(cjs|cts)$/iu;
  function uh(e, t) {
    return {
      language: Dj.test(e) ? "typescript" : "javascript",
      type: (qj.test(e) ? "module" : jj.test(e) ? "commonjs" : t) || "commonjs",
    };
  }
  async function lh(e, t, r = {}, n, s = 0, i = []) {
    let {
        indexPattern: o,
        ignorePattern: a,
        ignoreFilter: u,
        matchFilter: l,
        scriptPattern: c,
        dirNameRoutePrefix: f,
        maxDepth: d,
        autoHooksPattern: h,
      } = t,
      p = await Nj(e, { withFileTypes: !0 }),
      y = [];
    if ((r[n || "/"] || (r[n || "/"] = { hooks: [], plugins: [] }), t.autoHooks)) {
      if (i && i.length > 0) for (let T of i) y.push(T);
      let m = p.find((T) => h.test(T.name));
      if (m) {
        let T = $l(e, m.name),
          { type: N } = uh(T, t.packageType);
        t.overwriteHooks && y.length > 0 && (y = []), y.push({ file: T, type: N });
      }
      r[n || "/"].hooks = y;
    }
    let _ = p.find((m) => o.test(m.name));
    if (_) {
      let m = $l(e, _.name),
        { language: T, type: N } = uh(m, t.packageType);
      if (T === "typescript" && !Ol.supportTypeScript)
        throw new Error(
          `@fastify/autoload cannot import hooks plugin at '${m}'. To fix this error compile TypeScript to JavaScript or use 'ts-node' to run your app.`,
        );
      if ((g({ file: m, type: N }), !p.find(($) => $.isDirectory()))) return r;
    }
    if (p.find((m) => m.name === "package.json") && !_)
      throw new Error(
        `@fastify/autoload cannot import plugin at '${e}'. To fix this error rename the main entry file to 'index.js' (or .cjs, .mjs, .ts).`,
      );
    let E = [];
    for (let m of p) {
      if (a && m.name.match(a)) continue;
      let T = Number.isFinite(d) && d <= s,
        N = $l(e, m.name);
      if (m.isDirectory() && !T) {
        let w = n ? `${n}/` : "/";
        if (f === !0) w += m.name;
        else if (typeof f == "function") {
          let $ = f(e, m.name);
          $ && (w += $);
        }
        t.autoHooks && t.cascadeHooks
          ? E.push(lh(N, t, r, w, s + 1, y))
          : E.push(lh(N, t, r, w, s + 1));
        continue;
      } else if (_) continue;
      if (m.isFile() && c.test(m.name)) {
        let { language: w, type: $ } = uh(N, t.packageType);
        if (w === "typescript" && !Ol.supportTypeScript)
          throw new Error(
            `@fastify/autoload cannot import plugin at '${N}'. To fix this error compile TypeScript to JavaScript or use 'ts-node' to run your app.`,
          );
        h.test(m.name) || g({ file: N, type: $ });
      }
    }
    return await Promise.all(E), r;
    function g({ file: m, type: T }) {
      let N = "/" + Ij(t.dir, m).replace(/\\/gu, "/");
      (l && !BS(N, l)) ||
        (u && BS(N, u)) ||
        r[n || "/"].plugins.push({ file: m, type: T, prefix: n });
    }
  }
  async function Lj({ file: e, type: t, directoryPrefix: r, options: n, log: s }) {
    let { options: i, forceESM: o, encapsulate: a } = n,
      u;
    if (
      (o || t === "module" || Ol.forceESM ? (u = await import(GS(e).href)) : (u = require(e)),
      WS(u) === !1)
    ) {
      s.debug(
        { file: e },
        "skipping autoloading of file because it does not export a Fastify plugin compatible shape",
      );
      return;
    }
    let l = xj(u.default || u),
      c = (u.default && u.default.autoConfig) || u.autoConfig || {},
      f = Object.assign({}, c, i),
      d = l[Symbol.for("plugin-meta")] || {};
    if ((a || (l[Symbol.for("skip-override")] = !0), l.autoload === !1 || u.autoload === !1)) {
      s.debug({ file: e }, "skipping autoload due to `autoload: false` being set");
      return;
    }
    l.autoConfig !== void 0 && (l.autoConfig = void 0),
      (f.prefix = f.prefix && f.prefix.endsWith("/") ? f.prefix.slice(0, -1) : f.prefix);
    let h =
        l.prefixOverride !== void 0
          ? l.prefixOverride
          : u.prefixOverride !== void 0
            ? u.prefixOverride
            : void 0,
      p =
        (l.autoPrefix !== void 0
          ? l.autoPrefix
          : u.autoPrefix !== void 0
            ? u.autoPrefix
            : void 0) || r;
    return (
      h !== void 0 ? (f.prefix = h) : p && (f.prefix = (f.prefix || "") + p.replace(/\/+/gu, "/")),
      {
        plugin: l,
        filename: e,
        name: d.name || e,
        dependencies: d.dependencies,
        options: f,
        registered: !1,
      }
    );
  }
  function JS(e, t, r, n = {}) {
    let { plugin: s, name: i, options: o, dependencies: a = [] } = t;
    if (n[i]) throw new Error("Cyclic dependency");
    if (!t.registered) {
      n[i] = !0;
      for (let u of a) r[u] && JS(e, r[u], r, { ...n });
      e.register(s, o), (t.registered = !0);
    }
  }
  function BS(e, t) {
    return typeof t == "string" ? e.includes(t) : t instanceof RegExp ? t.test(e) : t(e);
  }
  function QS(e) {
    return !!(
      e &&
      Object.prototype.toString.call(e) === "[object Object]" &&
      Object.prototype.hasOwnProperty.call(e, "method")
    );
  }
  function WS(e) {
    let t = !1,
      r = Object.prototype.toString.call(e);
    return (
      /\[object (?:AsyncFunction|Function|Module)\]/u.test(r) === !0
        ? (t = !0)
        : Object.prototype.hasOwnProperty.call(e, "default")
          ? (t = WS(e.default))
          : (t = QS(e)),
      t
    );
  }
  function xj(e) {
    return QS(e) === !0
      ? async function (t, r) {
          t.route(e);
        }
      : e;
  }
  async function Fj(e, t) {
    let r;
    return (
      t.forceESM || e.type === "module" || Ol.forceESM
        ? (r = await import(GS(e.file).href))
        : (r = require(e.file)),
      (r = r.default || r),
      (Object.prototype.toString.call(r) === "[object AsyncFunction]" ||
        Object.prototype.toString.call(r) === "[object Function]") &&
        (r[Symbol.for("skip-override")] = !0),
      r
    );
  }
  function KS(e) {
    return (
      e instanceof SyntaxError &&
        (e.message +=
          " at " +
          e.stack.split(
            `
`,
            1,
          )[0]),
      e
    );
  }
  Nl[Symbol.for("skip-override")] = !0;
  Al.exports = Nl;
  Al.exports.fastifyAutoload = Nl;
  Al.exports.default = Nl;
});
var XS = b((ane, Mj) => {
  Mj.exports = {
    name: "dotenv",
    version: "16.4.5",
    description: "Loads environment variables from .env file",
    main: "lib/main.js",
    types: "lib/main.d.ts",
    exports: {
      ".": { types: "./lib/main.d.ts", require: "./lib/main.js", default: "./lib/main.js" },
      "./config": "./config.js",
      "./config.js": "./config.js",
      "./lib/env-options": "./lib/env-options.js",
      "./lib/env-options.js": "./lib/env-options.js",
      "./lib/cli-options": "./lib/cli-options.js",
      "./lib/cli-options.js": "./lib/cli-options.js",
      "./package.json": "./package.json",
    },
    scripts: {
      "dts-check": "tsc --project tests/types/tsconfig.json",
      lint: "standard",
      "lint-readme": "standard-markdown",
      pretest: "npm run lint && npm run dts-check",
      test: "tap tests/*.js --100 -Rspec",
      "test:coverage": "tap --coverage-report=lcov",
      prerelease: "npm test",
      release: "standard-version",
    },
    repository: { type: "git", url: "git://github.com/motdotla/dotenv.git" },
    funding: "https://dotenvx.com",
    keywords: ["dotenv", "env", ".env", "environment", "variables", "config", "settings"],
    readmeFilename: "README.md",
    license: "BSD-2-Clause",
    devDependencies: {
      "@definitelytyped/dtslint": "^0.0.133",
      "@types/node": "^18.11.3",
      decache: "^4.6.1",
      sinon: "^14.0.1",
      standard: "^17.0.0",
      "standard-markdown": "^7.1.0",
      "standard-version": "^9.5.0",
      tap: "^16.3.0",
      tar: "^6.1.11",
      typescript: "^4.8.4",
    },
    engines: { node: ">=12" },
    browser: { fs: !1 },
  };
});
var rv = b((une, es) => {
  var ch = require("fs"),
    fh = require("path"),
    zj = require("os"),
    Vj = require("crypto"),
    Uj = XS(),
    dh = Uj.version,
    Hj =
      /(?:^|^)\s*(?:export\s+)?([\w.-]+)(?:\s*=\s*?|:\s+?)(\s*'(?:\\'|[^'])*'|\s*"(?:\\"|[^"])*"|\s*`(?:\\`|[^`])*`|[^#\r\n]+)?\s*(?:#.*)?(?:$|$)/gm;
  function Bj(e) {
    let t = {},
      r = e.toString();
    r = r.replace(
      /\r\n?/gm,
      `
`,
    );
    let n;
    for (; (n = Hj.exec(r)) != null; ) {
      let s = n[1],
        i = n[2] || "";
      i = i.trim();
      let o = i[0];
      (i = i.replace(/^(['"`])([\s\S]*)\1$/gm, "$2")),
        o === '"' &&
          ((i = i.replace(
            /\\n/g,
            `
`,
          )),
          (i = i.replace(/\\r/g, "\r"))),
        (t[s] = i);
    }
    return t;
  }
  function Kj(e) {
    let t = tv(e),
      r = Mt.configDotenv({ path: t });
    if (!r.parsed) {
      let o = new Error(`MISSING_DATA: Cannot parse ${t} for an unknown reason`);
      throw ((o.code = "MISSING_DATA"), o);
    }
    let n = ev(e).split(","),
      s = n.length,
      i;
    for (let o = 0; o < s; o++)
      try {
        let a = n[o].trim(),
          u = Qj(r, a);
        i = Mt.decrypt(u.ciphertext, u.key);
        break;
      } catch (a) {
        if (o + 1 >= s) throw a;
      }
    return Mt.parse(i);
  }
  function Gj(e) {
    console.log(`[dotenv@${dh}][INFO] ${e}`);
  }
  function Jj(e) {
    console.log(`[dotenv@${dh}][WARN] ${e}`);
  }
  function Il(e) {
    console.log(`[dotenv@${dh}][DEBUG] ${e}`);
  }
  function ev(e) {
    return e && e.DOTENV_KEY && e.DOTENV_KEY.length > 0
      ? e.DOTENV_KEY
      : process.env.DOTENV_KEY && process.env.DOTENV_KEY.length > 0
        ? process.env.DOTENV_KEY
        : "";
  }
  function Qj(e, t) {
    let r;
    try {
      r = new URL(t);
    } catch (a) {
      if (a.code === "ERR_INVALID_URL") {
        let u = new Error(
          "INVALID_DOTENV_KEY: Wrong format. Must be in valid uri format like dotenv://:key_1234@dotenvx.com/vault/.env.vault?environment=development",
        );
        throw ((u.code = "INVALID_DOTENV_KEY"), u);
      }
      throw a;
    }
    let n = r.password;
    if (!n) {
      let a = new Error("INVALID_DOTENV_KEY: Missing key part");
      throw ((a.code = "INVALID_DOTENV_KEY"), a);
    }
    let s = r.searchParams.get("environment");
    if (!s) {
      let a = new Error("INVALID_DOTENV_KEY: Missing environment part");
      throw ((a.code = "INVALID_DOTENV_KEY"), a);
    }
    let i = `DOTENV_VAULT_${s.toUpperCase()}`,
      o = e.parsed[i];
    if (!o) {
      let a = new Error(
        `NOT_FOUND_DOTENV_ENVIRONMENT: Cannot locate environment ${i} in your .env.vault file.`,
      );
      throw ((a.code = "NOT_FOUND_DOTENV_ENVIRONMENT"), a);
    }
    return { ciphertext: o, key: n };
  }
  function tv(e) {
    let t = null;
    if (e && e.path && e.path.length > 0)
      if (Array.isArray(e.path))
        for (let r of e.path) ch.existsSync(r) && (t = r.endsWith(".vault") ? r : `${r}.vault`);
      else t = e.path.endsWith(".vault") ? e.path : `${e.path}.vault`;
    else t = fh.resolve(process.cwd(), ".env.vault");
    return ch.existsSync(t) ? t : null;
  }
  function ZS(e) {
    return e[0] === "~" ? fh.join(zj.homedir(), e.slice(1)) : e;
  }
  function Wj(e) {
    Gj("Loading env from encrypted .env.vault");
    let t = Mt._parseVault(e),
      r = process.env;
    return e && e.processEnv != null && (r = e.processEnv), Mt.populate(r, t, e), { parsed: t };
  }
  function Yj(e) {
    let t = fh.resolve(process.cwd(), ".env"),
      r = "utf8",
      n = !!(e && e.debug);
    e && e.encoding
      ? (r = e.encoding)
      : n && Il("No encoding is specified. UTF-8 is used by default");
    let s = [t];
    if (e && e.path)
      if (!Array.isArray(e.path)) s = [ZS(e.path)];
      else {
        s = [];
        for (let u of e.path) s.push(ZS(u));
      }
    let i,
      o = {};
    for (let u of s)
      try {
        let l = Mt.parse(ch.readFileSync(u, { encoding: r }));
        Mt.populate(o, l, e);
      } catch (l) {
        n && Il(`Failed to load ${u} ${l.message}`), (i = l);
      }
    let a = process.env;
    return (
      e && e.processEnv != null && (a = e.processEnv),
      Mt.populate(a, o, e),
      i ? { parsed: o, error: i } : { parsed: o }
    );
  }
  function Xj(e) {
    if (ev(e).length === 0) return Mt.configDotenv(e);
    let t = tv(e);
    return t
      ? Mt._configVault(e)
      : (Jj(
          `You set DOTENV_KEY but you are missing a .env.vault file at ${t}. Did you forget to build it?`,
        ),
        Mt.configDotenv(e));
  }
  function Zj(e, t) {
    let r = Buffer.from(t.slice(-64), "hex"),
      n = Buffer.from(e, "base64"),
      s = n.subarray(0, 12),
      i = n.subarray(-16);
    n = n.subarray(12, -16);
    try {
      let o = Vj.createDecipheriv("aes-256-gcm", r, s);
      return o.setAuthTag(i), `${o.update(n)}${o.final()}`;
    } catch (o) {
      let a = o instanceof RangeError,
        u = o.message === "Invalid key length",
        l = o.message === "Unsupported state or unable to authenticate data";
      if (a || u) {
        let c = new Error("INVALID_DOTENV_KEY: It must be 64 characters long (or more)");
        throw ((c.code = "INVALID_DOTENV_KEY"), c);
      } else if (l) {
        let c = new Error("DECRYPTION_FAILED: Please check your DOTENV_KEY");
        throw ((c.code = "DECRYPTION_FAILED"), c);
      } else throw o;
    }
  }
  function eL(e, t, r = {}) {
    let n = !!(r && r.debug),
      s = !!(r && r.override);
    if (typeof t != "object") {
      let i = new Error(
        "OBJECT_REQUIRED: Please check the processEnv argument being passed to populate",
      );
      throw ((i.code = "OBJECT_REQUIRED"), i);
    }
    for (let i of Object.keys(t))
      Object.prototype.hasOwnProperty.call(e, i)
        ? (s === !0 && (e[i] = t[i]),
          n &&
            Il(
              s === !0
                ? `"${i}" is already defined and WAS overwritten`
                : `"${i}" is already defined and was NOT overwritten`,
            ))
        : (e[i] = t[i]);
  }
  var Mt = {
    configDotenv: Yj,
    _configVault: Wj,
    _parseVault: Kj,
    config: Xj,
    decrypt: Zj,
    parse: Bj,
    populate: eL,
  };
  es.exports.configDotenv = Mt.configDotenv;
  es.exports._configVault = Mt._configVault;
  es.exports._parseVault = Mt._parseVault;
  es.exports.config = Mt.config;
  es.exports.decrypt = Mt.decrypt;
  es.exports.parse = Mt.parse;
  es.exports.populate = Mt.populate;
  es.exports = Mt;
});
var sv = b((lne, nv) => {
  "use strict";
  function tL(e) {
    var t = new e(),
      r = t;
    function n() {
      var i = t;
      return i.next ? (t = i.next) : ((t = new e()), (r = t)), (i.next = null), i;
    }
    function s(i) {
      (r.next = i), (r = i);
    }
    return { get: n, release: s };
  }
  nv.exports = tL;
});
var ov = b((cne, hh) => {
  "use strict";
  var rL = sv();
  function iv(e, t, r) {
    if ((typeof e == "function" && ((r = t), (t = e), (e = null)), !(r >= 1)))
      throw new Error("fastqueue concurrency must be equal to or greater than 1");
    var n = rL(nL),
      s = null,
      i = null,
      o = 0,
      a = null,
      u = {
        push: y,
        drain: Wr,
        saturated: Wr,
        pause: c,
        paused: !1,
        get concurrency() {
          return r;
        },
        set concurrency(T) {
          if (!(T >= 1))
            throw new Error("fastqueue concurrency must be equal to or greater than 1");
          if (((r = T), !u.paused)) for (; s && o < r; ) o++, S();
        },
        running: l,
        resume: h,
        idle: p,
        length: f,
        getQueue: d,
        unshift: _,
        empty: Wr,
        kill: E,
        killAndDrain: g,
        error: m,
      };
    return u;
    function l() {
      return o;
    }
    function c() {
      u.paused = !0;
    }
    function f() {
      for (var T = s, N = 0; T; ) (T = T.next), N++;
      return N;
    }
    function d() {
      for (var T = s, N = []; T; ) N.push(T.value), (T = T.next);
      return N;
    }
    function h() {
      if (u.paused) {
        if (((u.paused = !1), s === null)) {
          o++, S();
          return;
        }
        for (; s && o < r; ) o++, S();
      }
    }
    function p() {
      return o === 0 && u.length() === 0;
    }
    function y(T, N) {
      var w = n.get();
      (w.context = e),
        (w.release = S),
        (w.value = T),
        (w.callback = N || Wr),
        (w.errorHandler = a),
        o >= r || u.paused
          ? i
            ? ((i.next = w), (i = w))
            : ((s = w), (i = w), u.saturated())
          : (o++, t.call(e, w.value, w.worked));
    }
    function _(T, N) {
      var w = n.get();
      (w.context = e),
        (w.release = S),
        (w.value = T),
        (w.callback = N || Wr),
        (w.errorHandler = a),
        o >= r || u.paused
          ? s
            ? ((w.next = s), (s = w))
            : ((s = w), (i = w), u.saturated())
          : (o++, t.call(e, w.value, w.worked));
    }
    function S(T) {
      T && n.release(T);
      var N = s;
      N && o <= r
        ? u.paused
          ? o--
          : (i === s && (i = null),
            (s = N.next),
            (N.next = null),
            t.call(e, N.value, N.worked),
            i === null && u.empty())
        : --o === 0 && u.drain();
    }
    function E() {
      (s = null), (i = null), (u.drain = Wr);
    }
    function g() {
      (s = null), (i = null), u.drain(), (u.drain = Wr);
    }
    function m(T) {
      a = T;
    }
  }
  function Wr() {}
  function nL() {
    (this.value = null),
      (this.callback = Wr),
      (this.next = null),
      (this.release = Wr),
      (this.context = null),
      (this.errorHandler = null);
    var e = this;
    this.worked = function (r, n) {
      var s = e.callback,
        i = e.errorHandler,
        o = e.value;
      (e.value = null),
        (e.callback = Wr),
        e.errorHandler && i(r, o),
        s.call(e.context, r, n),
        e.release(e);
    };
  }
  function sL(e, t, r) {
    typeof e == "function" && ((r = t), (t = e), (e = null));
    function n(c, f) {
      t.call(this, c).then(function (d) {
        f(null, d);
      }, f);
    }
    var s = iv(e, n, r),
      i = s.push,
      o = s.unshift;
    return (s.push = a), (s.unshift = u), (s.drained = l), s;
    function a(c) {
      var f = new Promise(function (d, h) {
        i(c, function (p, y) {
          if (p) {
            h(p);
            return;
          }
          d(y);
        });
      });
      return f.catch(Wr), f;
    }
    function u(c) {
      var f = new Promise(function (d, h) {
        o(c, function (p, y) {
          if (p) {
            h(p);
            return;
          }
          d(y);
        });
      });
      return f.catch(Wr), f;
    }
    function l() {
      if (s.idle())
        return new Promise(function (d) {
          d();
        });
      var c = s.drain,
        f = new Promise(function (d) {
          s.drain = function () {
            c(), d();
          };
        });
      return f;
    }
  }
  hh.exports = iv;
  hh.exports.promise = sL;
});
var mh = b((fne, Cl) => {
  "use strict";
  var { format: iL } = require("node:util");
  function oL() {
    return `${this.name} [${this.code}]: ${this.message}`;
  }
  function ph(e, t, r = 500, n = Error) {
    if (!e) throw new Error("Fastify error code must not be empty");
    if (!t) throw new Error("Fastify error message must not be empty");
    (e = e.toUpperCase()), !r && (r = void 0);
    function s(...i) {
      if (!new.target) return new s(...i);
      (this.code = e), (this.name = "FastifyError"), (this.statusCode = r);
      let o = i.length - 1;
      o !== -1 &&
        i[o] &&
        typeof i[o] == "object" &&
        "cause" in i[o] &&
        (this.cause = i.pop().cause),
        (this.message = iL(t, ...i)),
        Error.stackTraceLimit !== 0 && Error.captureStackTrace(this, s);
    }
    return (
      (s.prototype = Object.create(n.prototype, {
        constructor: { value: s, enumerable: !1, writable: !0, configurable: !0 },
      })),
      (s.prototype[Symbol.toStringTag] = "Error"),
      (s.prototype.toString = oL),
      s
    );
  }
  Cl.exports = ph;
  Cl.exports.default = ph;
  Cl.exports.createError = ph;
});
var kl = b((dne, av) => {
  "use strict";
  var { createError: $s } = mh();
  av.exports = {
    AVV_ERR_EXPOSE_ALREADY_DEFINED: $s(
      "AVV_ERR_EXPOSE_ALREADY_DEFINED",
      "'%s' is already defined, specify an expose option for '%s'",
    ),
    AVV_ERR_ATTRIBUTE_ALREADY_DEFINED: $s(
      "AVV_ERR_ATTRIBUTE_ALREADY_DEFINED",
      "'%s' is already defined",
    ),
    AVV_ERR_CALLBACK_NOT_FN: $s(
      "AVV_ERR_CALLBACK_NOT_FN",
      "Callback for '%s' hook is not a function. Received: '%s'",
    ),
    AVV_ERR_PLUGIN_NOT_VALID: $s(
      "AVV_ERR_PLUGIN_NOT_VALID",
      "Plugin must be a function or a promise. Received: '%s'",
    ),
    AVV_ERR_ROOT_PLG_BOOTED: $s("AVV_ERR_ROOT_PLG_BOOTED", "Root plugin has already booted"),
    AVV_ERR_PARENT_PLG_LOADED: $s(
      "AVV_ERR_PARENT_PLG_LOADED",
      "Impossible to load '%s' plugin because the parent '%s' was already loaded",
    ),
    AVV_ERR_READY_TIMEOUT: $s(
      "AVV_ERR_READY_TIMEOUT",
      "Plugin did not start in time: '%s'. You may have forgotten to call 'done' function or to resolve a Promise",
    ),
    AVV_ERR_PLUGIN_EXEC_TIMEOUT: $s(
      "AVV_ERR_PLUGIN_EXEC_TIMEOUT",
      "Plugin did not start in time: '%s'. You may have forgotten to call 'done' function or to resolve a Promise",
    ),
  };
});
var Yi = b((hne, uv) => {
  "use strict";
  var aL = Symbol("avvio.Boot"),
    uL = Symbol("isOnCloseHandler"),
    lL = Symbol("avvio.ThenifyDoNotWrap"),
    cL = Symbol("avvio.TimeTree.untrackNode"),
    fL = Symbol("avvio.TimeTree.trackNode"),
    dL = Symbol("avvio.TimeTree.getParent"),
    hL = Symbol("avvio.TimeTree.getNode"),
    pL = Symbol("avvio.TimeTree.addNode"),
    mL = Symbol.for("plugin-meta");
  uv.exports = {
    kAvvio: aL,
    kIsOnCloseHandler: uL,
    kThenifyDoNotWrap: lL,
    kUntrackNode: cL,
    kTrackNode: fL,
    kGetParent: dL,
    kGetNode: hL,
    kAddNode: pL,
    kPluginMeta: mL,
  };
});
var mv = b((pne, pv) => {
  "use strict";
  var { kUntrackNode: lv, kTrackNode: yh, kGetParent: cv, kGetNode: fv, kAddNode: dv } = Yi(),
    gh = class {
      constructor() {
        (this.root = null), (this.tableId = new Map()), (this.tableLabel = new Map());
      }
      [yh](t) {
        this.tableId.set(t.id, t),
          this.tableLabel.has(t.label)
            ? this.tableLabel.get(t.label).push(t)
            : this.tableLabel.set(t.label, [t]);
      }
      [lv](t) {
        this.tableId.delete(t.id);
        let r = this.tableLabel.get(t.label);
        r.pop(), r.length === 0 && this.tableLabel.delete(t.label);
      }
      [cv](t) {
        if (t === null) return null;
        if (this.tableLabel.has(t)) {
          let r = this.tableLabel.get(t);
          return r[r.length - 1];
        } else return null;
      }
      [fv](t) {
        return this.tableId.get(t);
      }
      [dv](t, r, n) {
        let s = this[cv](t);
        if (s === null)
          return (
            (this.root = {
              parent: null,
              id: "root",
              label: r,
              nodes: [],
              start: n,
              stop: null,
              diff: -1,
            }),
            this[yh](this.root),
            this.root.id
          );
        let o = `${r}-${Math.random()}`,
          a = { parent: t, id: o, label: r, nodes: [], start: n, stop: null, diff: -1 };
        return s.nodes.push(a), this[yh](a), o;
      }
      start(t, r, n = Date.now()) {
        return this[dv](t, r, n);
      }
      stop(t, r = Date.now()) {
        let n = this[fv](t);
        n && ((n.stop = r), (n.diff = n.stop - n.start || 0), this[lv](n));
      }
      toJSON() {
        return Object.assign({}, this.root);
      }
      prettyPrint() {
        return hv(this.toJSON());
      }
    };
  function hv(e, t = "") {
    let r = t,
      n = e.nodes.length,
      s = n - 1;
    r += `${e.label} ${e.diff} ms
`;
    for (let i = 0; i < n; ++i) {
      let o = e.nodes[i],
        a = t + (i === s ? "  " : "\u2502 ");
      (r += t),
        (r += i === s ? "\u2514\u2500" : "\u251C\u2500"),
        (r += o.nodes.length === 0 ? "\u2500 " : "\u252C "),
        (r += hv(o, a).slice(t.length + 2));
    }
    return r;
  }
  pv.exports = { TimeTree: gh };
});
var Dl = b((mne, yv) => {
  "use strict";
  var { debuglog: yL } = require("node:util"),
    gL = yL("avvio");
  yv.exports = { debug: gL };
});
var _v = b((yne, gv) => {
  "use strict";
  function _L() {
    let e = { resolve: null, reject: null, promise: null };
    return (
      (e.promise = new Promise((t, r) => {
        (e.resolve = t), (e.reject = r);
      })),
      e
    );
  }
  gv.exports = { createPromise: _L };
});
var vv = b((gne, Sv) => {
  "use strict";
  var { kPluginMeta: _h } = Yi();
  function SL(e, t) {
    return e[_h] && e[_h].name
      ? e[_h].name
      : t && t.name
        ? t.name
        : e.name
          ? e.name
          : e
              .toString()
              .split(
                `
`,
              )
              .slice(0, 2)
              .map((r) => r.trim())
              .join(" -- ");
  }
  Sv.exports = { getPluginName: SL };
});
var ql = b((_ne, bv) => {
  "use strict";
  function vL(e) {
    return e !== null && typeof e == "object" && typeof e.then == "function";
  }
  bv.exports = { isPromiseLike: vL };
});
var Ev = b((Sne, wv) => {
  "use strict";
  var { EventEmitter: bL } = require("node:events"),
    { inherits: wL } = require("node:util"),
    { debug: Kt } = Dl(),
    { createPromise: EL } = _v(),
    { AVV_ERR_PLUGIN_EXEC_TIMEOUT: RL } = kl(),
    { getPluginName: TL } = vv(),
    { isPromiseLike: PL } = ql();
  function Xi(e, t, r, n, s) {
    (this.queue = e),
      (this.func = t),
      (this.options = r),
      (this.isAfter = n),
      (this.timeout = s),
      (this.started = !1),
      (this.name = TL(t, r)),
      this.queue.pause(),
      (this._error = null),
      (this.loaded = !1),
      (this._promise = null),
      (this.startTime = null);
  }
  wL(Xi, bL);
  Xi.prototype.exec = function (e, t) {
    Kt("exec", this.name), (this.server = e);
    let r = this.func,
      n = this.name,
      s = !1;
    this.options = typeof this.options == "function" ? this.options(this.server) : this.options;
    let i = null,
      o = (u) => {
        if (s) {
          Kt("loading complete", n);
          return;
        }
        (this._error = u),
          Kt(u ? "exec errored" : "exec completed", n),
          (s = !0),
          i && clearTimeout(i),
          t(u);
      };
    this.timeout > 0 &&
      (Kt("setting up timeout", n, this.timeout),
      (i = setTimeout(function () {
        Kt("timed out", n), (i = null);
        let u = new RL(n);
        (u.fn = r), o(u);
      }, this.timeout))),
      (this.started = !0),
      (this.startTime = Date.now()),
      this.emit("start", this.server ? this.server.name : null, this.name, Date.now());
    let a = r(this.server, this.options, o);
    PL(a) &&
      (Kt("exec: resolving promise", n),
      a.then(
        () => process.nextTick(o),
        (u) => process.nextTick(o, u),
      ));
  };
  Xi.prototype.loadedSoFar = function () {
    if ((Kt("loadedSoFar", this.name), this.loaded)) return Promise.resolve();
    let e = () => {
        this.server.after((r, n) => {
          (this._error = r),
            this.queue.pause(),
            this._promise &&
              (r
                ? (Kt("rejecting promise", this.name, r), this._promise.reject(r))
                : (Kt("resolving promise", this.name), this._promise.resolve()),
              (this._promise = null)),
            process.nextTick(n, r);
        }),
          this.queue.resume();
      },
      t;
    return (
      this._promise
        ? (t = Promise.resolve())
        : ((this._promise = EL()),
          (t = this._promise.promise),
          this.server ? e() : this.on("start", e)),
      t
    );
  };
  Xi.prototype.enqueue = function (e, t) {
    Kt("enqueue", this.name, e.name),
      this.emit("enqueue", this.server ? this.server.name : null, this.name, Date.now()),
      this.queue.push(e, t);
  };
  Xi.prototype.finish = function (e, t) {
    Kt("finish", this.name, e);
    let r = () => {
      this.loaded ||
        (Kt("loaded", this.name),
        this.emit("loaded", this.server ? this.server.name : null, this.name, Date.now()),
        (this.loaded = !0),
        t(e));
    };
    if (e) {
      this._promise && (this._promise.reject(e), (this._promise = null)), r();
      return;
    }
    let n = () => {
      if (
        (Kt("check", this.name, this.queue.length(), this.queue.running(), this._promise),
        this.queue.length() === 0 && this.queue.running() === 0)
      )
        if (this._promise) {
          let s = () => {
            Kt("wrap"), queueMicrotask(n);
          };
          this._promise.resolve(), this._promise.promise.then(s, s), (this._promise = null);
        } else r();
      else
        Kt("delayed", this.name),
          (this.queue.drain = () => {
            Kt("drain", this.name), (this.queue.drain = $L), queueMicrotask(n);
          });
    };
    queueMicrotask(n), this.queue.resume();
  };
  function $L() {}
  wv.exports = { Plugin: Xi };
});
var Tv = b((vne, Rv) => {
  "use strict";
  var { AVV_ERR_PLUGIN_NOT_VALID: Sh } = kl();
  function OL(e) {
    if (!(e && (typeof e == "function" || typeof e.then == "function")))
      throw Array.isArray(e) ? new Sh("array") : e === null ? new Sh("null") : new Sh(typeof e);
  }
  Rv.exports = { validatePlugin: OL };
});
var $v = b((bne, Pv) => {
  "use strict";
  function NL(e) {
    return e !== null && typeof e == "object" && typeof e.default == "function";
  }
  Pv.exports = { isBundledOrTypescriptPlugin: NL };
});
var Av = b((wne, Nv) => {
  "use strict";
  var { debug: Ov } = Dl(),
    { kThenifyDoNotWrap: vh } = Yi();
  function AL() {
    if (this.booted) {
      Ov("thenify returning undefined because we are already booted");
      return;
    }
    if (this[vh]) {
      this[vh] = !1;
      return;
    }
    return (
      Ov("thenify"),
      (e, t) => this._loadRegistered().then(() => ((this[vh] = !0), e(this._server)), t)
    );
  }
  Nv.exports = { thenify: AL };
});
var Cv = b((Ene, Iv) => {
  "use strict";
  var { isPromiseLike: IL } = ql(),
    { kAvvio: CL } = Yi();
  function kL(e, t, r) {
    let n = e.apply(e, t);
    IL(n) && !n[CL]
      ? n.then(
          () => process.nextTick(r),
          (s) => process.nextTick(r, s),
        )
      : r && process.nextTick(r);
  }
  Iv.exports = { executeWithThenable: kL };
});
var Mv = b((Rne, wh) => {
  "use strict";
  var jl = ov(),
    DL = require("node:events").EventEmitter,
    qL = require("node:util").inherits,
    {
      AVV_ERR_EXPOSE_ALREADY_DEFINED: pa,
      AVV_ERR_CALLBACK_NOT_FN: Zi,
      AVV_ERR_ROOT_PLG_BOOTED: jL,
      AVV_ERR_READY_TIMEOUT: LL,
      AVV_ERR_ATTRIBUTE_ALREADY_DEFINED: xL,
    } = kl(),
    { kAvvio: qv, kIsOnCloseHandler: jv } = Yi(),
    { TimeTree: FL } = mv(),
    { Plugin: Lv } = Ev(),
    { debug: eo } = Dl(),
    { validatePlugin: ML } = Tv(),
    { isBundledOrTypescriptPlugin: zL } = $v(),
    { isPromiseLike: VL } = ql(),
    { thenify: xv } = Av(),
    { executeWithThenable: kv } = Cv();
  function At(e, t, r) {
    if (
      (typeof e == "function" && arguments.length === 1 && ((r = e), (t = {}), (e = null)),
      typeof t == "function" && ((r = t), (t = {})),
      (t = t || {}),
      (t.autostart = t.autostart !== !1),
      (t.timeout = Number(t.timeout) || 0),
      (t.expose = t.expose || {}),
      !new.target)
    )
      return new At(e, t, r);
    (this._server = e || this),
      (this._opts = t),
      e && this._expose(),
      (this._current = []),
      (this._error = null),
      (this._lastUsed = null),
      this.setMaxListeners(0),
      r && this.once("start", r),
      (this.started = !1),
      (this.booted = !1),
      (this.pluginTree = new FL()),
      (this._readyQ = jl(this, Fv, 1)),
      this._readyQ.pause(),
      (this._readyQ.drain = () => {
        this.emit("start"), (this._readyQ.drain = Dv);
      }),
      (this._closeQ = jl(this, HL, 1)),
      this._closeQ.pause(),
      (this._closeQ.drain = () => {
        this.emit("close"), (this._closeQ.drain = Dv);
      }),
      (this._doStart = null);
    let n = this;
    (this._root = new Lv(
      jl(this, this._loadPluginNextTick, 1),
      function (i, o, a) {
        (n._doStart = a), o.autostart && n.start();
      },
      t,
      !1,
      0,
    )),
      this._trackPluginLoading(this._root),
      this._loadPlugin(this._root, (s) => {
        eo("root plugin ready");
        try {
          this.emit("preReady"), (this._root = null);
        } catch (i) {
          s = s || this._error || i;
        }
        if (s) {
          if (((this._error = s), this._readyQ.length() === 0)) throw s;
        } else this.booted = !0;
        this._readyQ.resume();
      });
  }
  qL(At, DL);
  At.prototype.start = function () {
    return (this.started = !0), process.nextTick(this._doStart), this;
  };
  At.prototype.override = function (e, t, r) {
    return e;
  };
  At.prototype[qv] = !0;
  At.prototype.use = function (e, t) {
    return (this._lastUsed = this._addPlugin(e, t, !1)), this;
  };
  At.prototype._loadRegistered = function () {
    let e = this._current[0];
    return (
      !this.started && !this.booted && process.nextTick(() => this._root.queue.resume()),
      e ? e.loadedSoFar() : Promise.resolve()
    );
  };
  Object.defineProperty(At.prototype, "then", { get: xv });
  At.prototype._addPlugin = function (e, t, r) {
    if ((zL(e) && (e = e.default), ML(e), (t = t || {}), this.booted)) throw new jL();
    let n = this._current[0],
      s = this._opts.timeout;
    if (!n.loaded && n.timeout > 0) {
      let o = Date.now() - n.startTime;
      s = n.timeout - (o + 3);
    }
    let i = new Lv(jl(this, this._loadPluginNextTick, 1), e, t, r, s);
    if ((this._trackPluginLoading(i), n.loaded)) throw new Error(i.name, n.name);
    return (
      n.enqueue(i, (o) => {
        o && (this._error = o);
      }),
      i
    );
  };
  At.prototype._expose = function () {
    let t = this,
      r = t._server,
      {
        use: n = "use",
        after: s = "after",
        ready: i = "ready",
        onClose: o = "onClose",
        close: a = "close",
      } = this._opts.expose;
    if (r[n]) throw new pa(n, "use");
    if (
      ((r[n] = function (u, l) {
        return t.use(u, l), this;
      }),
      r[s])
    )
      throw new pa(s, "after");
    if (
      ((r[s] = function (u) {
        return typeof u != "function" ? t._loadRegistered() : (t.after(bh(u, this)), this);
      }),
      r[i])
    )
      throw new pa(i, "ready");
    if (
      ((r[i] = function (u) {
        if (u && typeof u != "function") throw new Zi(i, typeof u);
        return t.ready(u ? bh(u, this) : void 0);
      }),
      r[o])
    )
      throw new pa(o, "onClose");
    if (
      ((r[o] = function (u) {
        if (typeof u != "function") throw new Zi(o, typeof u);
        return t.onClose(BL(u, this)), this;
      }),
      r[a])
    )
      throw new pa(a, "close");
    if (
      ((r[a] = function (u) {
        if (u && typeof u != "function") throw new Zi(a, typeof u);
        return u ? (t.close(bh(u, this)), this) : t.close();
      }),
      r.then)
    )
      throw new xL("then");
    Object.defineProperty(r, "then", { get: xv.bind(t) }), (r[qv] = !0);
  };
  At.prototype.after = function (e) {
    if (!e) return this._loadRegistered();
    this._addPlugin(t.bind(this), {}, !0);
    function t(r, n, s) {
      Fv.call(this, e, s);
    }
    return this;
  };
  At.prototype.onClose = function (e) {
    if (typeof e != "function") throw new Zi("onClose", typeof e);
    return (
      (e[jv] = !0),
      this._closeQ.unshift(e, (t) => {
        t && (this._error = t);
      }),
      this
    );
  };
  At.prototype.close = function (e) {
    let t;
    if (e) {
      if (typeof e != "function") throw new Zi("close", typeof e);
    } else
      t = new Promise(function (r, n) {
        e = function (s) {
          if (s) return n(s);
          r();
        };
      });
    return (
      this.ready(() => {
        (this._error = null),
          this._closeQ.push(e),
          process.nextTick(this._closeQ.resume.bind(this._closeQ));
      }),
      t
    );
  };
  At.prototype.ready = function (e) {
    if (e) {
      if (typeof e != "function") throw new Zi("ready", typeof e);
      this._readyQ.push(e), queueMicrotask(this.start.bind(this));
      return;
    }
    return new Promise((t, r) => {
      this._readyQ.push(s), this.start();
      let n = this._current[0].server;
      function s(i, o, a) {
        i ? r(i) : t(n), process.nextTick(a);
      }
    });
  };
  At.prototype._trackPluginLoading = function (e) {
    let t = this._current[0]?.name || null;
    e.once("start", (r, n, s) => {
      let i = this.pluginTree.start(t || null, n, s);
      e.once("loaded", (o, a, u) => {
        this.pluginTree.stop(i, u);
      });
    });
  };
  At.prototype.prettyPrint = function () {
    return this.pluginTree.prettyPrint();
  };
  At.prototype.toJSON = function () {
    return this.pluginTree.toJSON();
  };
  At.prototype._loadPlugin = function (e, t) {
    let r = this;
    if (VL(e.func)) {
      e.func.then((o) => {
        typeof o.default == "function" && (o = o.default), (e.func = o), this._loadPlugin(e, t);
      }, t);
      return;
    }
    let n = r._current[0];
    if ((r._current.unshift(e), r._error && !e.isAfter)) {
      eo("skipping loading of plugin as instance errored and it is not an after", e.name),
        process.nextTick(i);
      return;
    }
    let s = (n && n.server) || r._server;
    if (!e.isAfter)
      try {
        s = r.override(s, e.func, e.options);
      } catch (o) {
        return eo("override errored", e.name), i(o);
      }
    e.exec(s, i);
    function i(o) {
      e.finish(o, (a) => {
        r._current.shift(), t(a);
      });
    }
  };
  At.prototype._loadPluginNextTick = function (e, t) {
    process.nextTick(this._loadPlugin.bind(this), e, t);
  };
  function Dv() {}
  function Fv(e, t) {
    let r = this._server,
      n = this._error;
    if (((this._error = null), e.length === 0)) (this._error = n), kv(e, [], t);
    else if (e.length === 1) kv(e, [n], t);
    else if (this._opts.timeout === 0) {
      let s = (i) => {
        (this._error = i), t(this._error);
      };
      e.length === 2 ? e(n, s) : e(n, r, s);
    } else UL.call(this, e, n, r, t);
  }
  function UL(e, t, r, n) {
    let s = e.name;
    eo("setting up ready timeout", s, this._opts.timeout);
    let i = setTimeout(() => {
      eo("timed out", s), (i = null);
      let a = new LL(s);
      (a.fn = e), (this._error = a), n(a);
    }, this._opts.timeout);
    e.length === 2 ? e(t, o.bind(this)) : e(t, r, o.bind(this));
    function o(a) {
      i && (clearTimeout(i), (this._error = a), n(this._error));
    }
  }
  function HL(e, t) {
    let r = this._server,
      n = e[jv];
    if (e.length === 0 || e.length === 1) {
      let s;
      n ? (s = e(r)) : (s = e(this._error)),
        s && typeof s.then == "function"
          ? (eo("resolving close/onClose promise"),
            s.then(
              () => process.nextTick(t),
              (i) => process.nextTick(t, i),
            ))
          : process.nextTick(t);
    } else e.length === 2 ? e(n ? r : this._error, t) : n ? e(r, t) : e(this._error, r, t);
  }
  function BL(e, t) {
    return r.bind(t);
    function r(n, s) {
      let i;
      e.length === 0
        ? ((i = e()),
          i && i.then
            ? i.then(function () {
                process.nextTick(s);
              }, s)
            : process.nextTick(s))
        : e.length === 1
          ? ((i = e(this)),
            i && i.then
              ? i.then(function () {
                  process.nextTick(s);
                }, s)
              : process.nextTick(s))
          : e(this, s);
    }
  }
  function bh(e, t) {
    return r.bind(t);
    function r(n, s) {
      let i;
      e
        ? e.length === 0
          ? ((i = e()),
            i && i.then
              ? i.then(function () {
                  process.nextTick(s, n);
                }, s)
              : process.nextTick(s, n))
          : e.length === 1
            ? ((i = e(n)),
              i && i.then
                ? i.then(function () {
                    process.nextTick(s);
                  }, s)
                : process.nextTick(s))
            : e.length === 2
              ? e(n, s)
              : e(n, this, s)
        : process.nextTick(s);
    }
  }
  wh.exports = At;
  wh.exports.express = function (e) {
    return At(e, { expose: { use: "load" } });
  };
});
var Vt = b((Tne, zv) => {
  "use strict";
  var KL = {
    kAvvioBoot: Symbol("fastify.avvioBoot"),
    kChildren: Symbol("fastify.children"),
    kServerBindings: Symbol("fastify.serverBindings"),
    kBodyLimit: Symbol("fastify.bodyLimit"),
    kRoutePrefix: Symbol("fastify.routePrefix"),
    kLogLevel: Symbol("fastify.logLevel"),
    kLogSerializers: Symbol("fastify.logSerializers"),
    kHooks: Symbol("fastify.hooks"),
    kContentTypeParser: Symbol("fastify.contentTypeParser"),
    kState: Symbol("fastify.state"),
    kOptions: Symbol("fastify.options"),
    kDisableRequestLogging: Symbol("fastify.disableRequestLogging"),
    kPluginNameChain: Symbol("fastify.pluginNameChain"),
    kRouteContext: Symbol("fastify.context"),
    kPublicRouteContext: Symbol("fastify.routeOptions"),
    kGenReqId: Symbol("fastify.genReqId"),
    kSchemaController: Symbol("fastify.schemaController"),
    kSchemaHeaders: Symbol("headers-schema"),
    kSchemaParams: Symbol("params-schema"),
    kSchemaQuerystring: Symbol("querystring-schema"),
    kSchemaBody: Symbol("body-schema"),
    kSchemaResponse: Symbol("response-schema"),
    kSchemaErrorFormatter: Symbol("fastify.schemaErrorFormatter"),
    kSchemaVisited: Symbol("fastify.schemas.visited"),
    kRequest: Symbol("fastify.Request"),
    kRequestPayloadStream: Symbol("fastify.RequestPayloadStream"),
    kRequestAcceptVersion: Symbol("fastify.RequestAcceptVersion"),
    kRequestCacheValidateFns: Symbol("fastify.request.cache.validateFns"),
    kRequestOriginalUrl: Symbol("fastify.request.originalUrl"),
    kFourOhFour: Symbol("fastify.404"),
    kCanSetNotFoundHandler: Symbol("fastify.canSetNotFoundHandler"),
    kFourOhFourLevelInstance: Symbol("fastify.404LogLevelInstance"),
    kFourOhFourContext: Symbol("fastify.404ContextKey"),
    kDefaultJsonParse: Symbol("fastify.defaultJSONParse"),
    kReply: Symbol("fastify.Reply"),
    kReplySerializer: Symbol("fastify.reply.serializer"),
    kReplyIsError: Symbol("fastify.reply.isError"),
    kReplyHeaders: Symbol("fastify.reply.headers"),
    kReplyTrailers: Symbol("fastify.reply.trailers"),
    kReplyHasStatusCode: Symbol("fastify.reply.hasStatusCode"),
    kReplyHijacked: Symbol("fastify.reply.hijacked"),
    kReplyStartTime: Symbol("fastify.reply.startTime"),
    kReplyNextErrorHandler: Symbol("fastify.reply.nextErrorHandler"),
    kReplyEndTime: Symbol("fastify.reply.endTime"),
    kReplyErrorHandlerCalled: Symbol("fastify.reply.errorHandlerCalled"),
    kReplyIsRunningOnErrorHook: Symbol("fastify.reply.isRunningOnErrorHook"),
    kReplySerializerDefault: Symbol("fastify.replySerializerDefault"),
    kReplyCacheSerializeFns: Symbol("fastify.reply.cache.serializeFns"),
    kTestInternals: Symbol("fastify.testInternals"),
    kErrorHandler: Symbol("fastify.errorHandler"),
    kChildLoggerFactory: Symbol("fastify.childLoggerFactory"),
    kHasBeenDecorated: Symbol("fastify.hasBeenDecorated"),
    kKeepAliveConnections: Symbol("fastify.keepAliveConnections"),
    kRouteByFastify: Symbol("fastify.routeByFastify"),
  };
  zv.exports = KL;
});
var Th = b((Pne, Ll) => {
  "use strict";
  var { format: Eh } = require("node:util");
  function GL(e) {
    return Vv({ ...e, name: "DeprecationWarning" });
  }
  function Vv({ name: e, code: t, message: r, unlimited: n = !1 } = {}) {
    if (!e) throw new Error("Warning name must not be empty");
    if (!t) throw new Error("Warning code must not be empty");
    if (!r) throw new Error("Warning message must not be empty");
    if (typeof n != "boolean") throw new Error("Warning opts.unlimited must be a boolean");
    t = t.toUpperCase();
    let s = {
      [e]: function (o, a, u) {
        (i.emitted === !0 && i.unlimited !== !0) ||
          ((i.emitted = !0), process.emitWarning(i.format(o, a, u), i.name, i.code));
      },
    };
    n &&
      (s = {
        [e]: function (o, a, u) {
          (i.emitted = !0), process.emitWarning(i.format(o, a, u), i.name, i.code);
        },
      });
    let i = s[e];
    return (
      (i.emitted = !1),
      (i.message = r),
      (i.unlimited = n),
      (i.code = t),
      (i.format = function (o, a, u) {
        let l;
        return (
          o && a && u
            ? (l = Eh(r, o, a, u))
            : o && a
              ? (l = Eh(r, o, a))
              : o
                ? (l = Eh(r, o))
                : (l = r),
          l
        );
      }),
      i
    );
  }
  var Rh = { createWarning: Vv, createDeprecation: GL };
  Ll.exports = Rh;
  Ll.exports.default = Rh;
  Ll.exports.processWarning = Rh;
});
var ts = b(($ne, Hv) => {
  "use strict";
  var { createDeprecation: Gt, createWarning: Uv } = Th(),
    JL = Gt({
      code: "FSTDEP005",
      message:
        'You are accessing the deprecated "request.connection" property. Use "request.socket" instead.',
    }),
    QL = Gt({
      code: "FSTDEP006",
      message:
        "You are decorating Request/Reply with a reference type. This reference is shared amongst all requests. Use onRequest hook instead. Property: %s",
    }),
    WL = Gt({
      code: "FSTDEP007",
      message:
        'You are trying to set a HEAD route using "exposeHeadRoute" route flag when a sibling route is already set. See documentation for more info.',
    }),
    YL = Gt({
      code: "FSTDEP008",
      message:
        'You are using route constraints via the route { version: "..." } option, use { constraints: { version: "..." } } option instead.',
    }),
    XL = Gt({
      code: "FSTDEP009",
      message:
        'You are using a custom route versioning strategy via the server { versioning: "..." } option, use { constraints: { version: "..." } } option instead.',
    }),
    ZL = Gt({
      code: "FSTDEP010",
      message:
        'Modifying the "reply.sent" property is deprecated. Use the "reply.hijack()" method instead.',
    }),
    ex = Gt({
      code: "FSTDEP011",
      message:
        'Variadic listen method is deprecated. Please use ".listen(optionsObject)" instead. The variadic signature will be removed in `fastify@5`.',
    }),
    tx = Gt({
      code: "FSTDEP012",
      message:
        'request.context property access is deprecated. Please use "request.routeOptions.config" or "request.routeOptions.schema" instead for accessing Route settings. The "request.context" will be removed in `fastify@5`.',
    }),
    rx = Gt({
      code: "FSTDEP013",
      message:
        'Direct return of "trailers" function is deprecated. Please use "callback" or "async-await" for return value. The support of direct return will removed in `fastify@5`.',
    }),
    nx = Gt({
      code: "FSTDEP014",
      message:
        "You are trying to set/access the default route. This property is deprecated. Please, use setNotFoundHandler if you want to custom a 404 handler or the wildcard (*) to match all routes.",
    }),
    sx = Gt({
      code: "FSTDEP015",
      message:
        'You are accessing the deprecated "request.routeSchema" property. Use "request.routeOptions.schema" instead. Property "req.routeSchema" will be removed in `fastify@5`.',
    }),
    ix = Gt({
      code: "FSTDEP016",
      message:
        'You are accessing the deprecated "request.routeConfig" property. Use "request.routeOptions.config" instead. Property "req.routeConfig" will be removed in `fastify@5`.',
    }),
    ox = Gt({
      code: "FSTDEP017",
      message:
        'You are accessing the deprecated "request.routerPath" property. Use "request.routeOptions.url" instead. Property "req.routerPath" will be removed in `fastify@5`.',
    }),
    ax = Gt({
      code: "FSTDEP018",
      message:
        'You are accessing the deprecated "request.routerMethod" property. Use "request.routeOptions.method" instead. Property "req.routerMethod" will be removed in `fastify@5`.',
    }),
    ux = Gt({
      code: "FSTDEP019",
      message:
        'reply.context property access is deprecated. Please use "request.routeOptions.config" or "request.routeOptions.schema" instead for accessing Route settings. The "reply.context" will be removed in `fastify@5`.',
    }),
    lx = Gt({
      code: "FSTDEP020",
      message:
        'You are using the deprecated "reply.getResponseTime()" method. Use the "reply.elapsedTime" property instead. Method "reply.getResponseTime()" will be removed in `fastify@5`.',
    }),
    cx = Gt({
      code: "FSTDEP021",
      message:
        "The `reply.redirect()` method has a new signature: `reply.redirect(url: string, code?: number)`. It will be enforced in `fastify@v5`",
    }),
    fx = Uv({
      name: "FastifyWarning",
      code: "FSTWRN001",
      message:
        "The %s schema for %s: %s is missing. This may indicate the schema is not well specified.",
      unlimited: !0,
    }),
    dx = Uv({
      name: "FastifyWarning",
      code: "FSTWRN002",
      message:
        "The %s plugin being registered mixes async and callback styles, which will result in an error in `fastify@5`",
      unlimited: !0,
    });
  Hv.exports = {
    FSTDEP005: JL,
    FSTDEP006: QL,
    FSTDEP007: WL,
    FSTDEP008: YL,
    FSTDEP009: XL,
    FSTDEP010: ZL,
    FSTDEP011: ex,
    FSTDEP012: tx,
    FSTDEP013: rx,
    FSTDEP014: nx,
    FSTDEP015: sx,
    FSTDEP016: ix,
    FSTDEP017: ox,
    FSTDEP018: ax,
    FSTDEP019: ux,
    FSTDEP020: lx,
    FSTDEP021: cx,
    FSTWRN001: fx,
    FSTWRN002: dx,
  };
});
var tr = b((One, xl) => {
  "use strict";
  var W = mh(),
    li = {
      FST_ERR_NOT_FOUND: W("FST_ERR_NOT_FOUND", "Not Found", 404),
      FST_ERR_OPTIONS_NOT_OBJ: W(
        "FST_ERR_OPTIONS_NOT_OBJ",
        "Options must be an object",
        500,
        TypeError,
      ),
      FST_ERR_QSP_NOT_FN: W(
        "FST_ERR_QSP_NOT_FN",
        "querystringParser option should be a function, instead got '%s'",
        500,
        TypeError,
      ),
      FST_ERR_SCHEMA_CONTROLLER_BUCKET_OPT_NOT_FN: W(
        "FST_ERR_SCHEMA_CONTROLLER_BUCKET_OPT_NOT_FN",
        "schemaController.bucket option should be a function, instead got '%s'",
        500,
        TypeError,
      ),
      FST_ERR_SCHEMA_ERROR_FORMATTER_NOT_FN: W(
        "FST_ERR_SCHEMA_ERROR_FORMATTER_NOT_FN",
        "schemaErrorFormatter option should be a non async function. Instead got '%s'.",
        500,
        TypeError,
      ),
      FST_ERR_AJV_CUSTOM_OPTIONS_OPT_NOT_OBJ: W(
        "FST_ERR_AJV_CUSTOM_OPTIONS_OPT_NOT_OBJ",
        "ajv.customOptions option should be an object, instead got '%s'",
        500,
        TypeError,
      ),
      FST_ERR_AJV_CUSTOM_OPTIONS_OPT_NOT_ARR: W(
        "FST_ERR_AJV_CUSTOM_OPTIONS_OPT_NOT_ARR",
        "ajv.plugins option should be an array, instead got '%s'",
        500,
        TypeError,
      ),
      FST_ERR_VERSION_CONSTRAINT_NOT_STR: W(
        "FST_ERR_VERSION_CONSTRAINT_NOT_STR",
        "Version constraint should be a string.",
        500,
        TypeError,
      ),
      FST_ERR_VALIDATION: W("FST_ERR_VALIDATION", "%s", 400),
      FST_ERR_LISTEN_OPTIONS_INVALID: W(
        "FST_ERR_LISTEN_OPTIONS_INVALID",
        "Invalid listen options: '%s'",
        500,
        TypeError,
      ),
      FST_ERR_ERROR_HANDLER_NOT_FN: W(
        "FST_ERR_ERROR_HANDLER_NOT_FN",
        "Error Handler must be a function",
        500,
        TypeError,
      ),
      FST_ERR_CTP_ALREADY_PRESENT: W(
        "FST_ERR_CTP_ALREADY_PRESENT",
        "Content type parser '%s' already present.",
      ),
      FST_ERR_CTP_INVALID_TYPE: W(
        "FST_ERR_CTP_INVALID_TYPE",
        "The content type should be a string or a RegExp",
        500,
        TypeError,
      ),
      FST_ERR_CTP_EMPTY_TYPE: W(
        "FST_ERR_CTP_EMPTY_TYPE",
        "The content type cannot be an empty string",
        500,
        TypeError,
      ),
      FST_ERR_CTP_INVALID_HANDLER: W(
        "FST_ERR_CTP_INVALID_HANDLER",
        "The content type handler should be a function",
        500,
        TypeError,
      ),
      FST_ERR_CTP_INVALID_PARSE_TYPE: W(
        "FST_ERR_CTP_INVALID_PARSE_TYPE",
        "The body parser can only parse your data as 'string' or 'buffer', you asked '%s' which is not supported.",
        500,
        TypeError,
      ),
      FST_ERR_CTP_BODY_TOO_LARGE: W(
        "FST_ERR_CTP_BODY_TOO_LARGE",
        "Request body is too large",
        413,
        RangeError,
      ),
      FST_ERR_CTP_INVALID_MEDIA_TYPE: W(
        "FST_ERR_CTP_INVALID_MEDIA_TYPE",
        "Unsupported Media Type: %s",
        415,
      ),
      FST_ERR_CTP_INVALID_CONTENT_LENGTH: W(
        "FST_ERR_CTP_INVALID_CONTENT_LENGTH",
        "Request body size did not match Content-Length",
        400,
        RangeError,
      ),
      FST_ERR_CTP_EMPTY_JSON_BODY: W(
        "FST_ERR_CTP_EMPTY_JSON_BODY",
        "Body cannot be empty when content-type is set to 'application/json'",
        400,
      ),
      FST_ERR_CTP_INSTANCE_ALREADY_STARTED: W(
        "FST_ERR_CTP_INSTANCE_ALREADY_STARTED",
        'Cannot call "%s" when fastify instance is already started!',
        400,
      ),
      FST_ERR_DEC_ALREADY_PRESENT: W(
        "FST_ERR_DEC_ALREADY_PRESENT",
        "The decorator '%s' has already been added!",
      ),
      FST_ERR_DEC_DEPENDENCY_INVALID_TYPE: W(
        "FST_ERR_DEC_DEPENDENCY_INVALID_TYPE",
        "The dependencies of decorator '%s' must be of type Array.",
        500,
        TypeError,
      ),
      FST_ERR_DEC_MISSING_DEPENDENCY: W(
        "FST_ERR_DEC_MISSING_DEPENDENCY",
        "The decorator is missing dependency '%s'.",
      ),
      FST_ERR_DEC_AFTER_START: W(
        "FST_ERR_DEC_AFTER_START",
        "The decorator '%s' has been added after start!",
      ),
      FST_ERR_HOOK_INVALID_TYPE: W(
        "FST_ERR_HOOK_INVALID_TYPE",
        "The hook name must be a string",
        500,
        TypeError,
      ),
      FST_ERR_HOOK_INVALID_HANDLER: W(
        "FST_ERR_HOOK_INVALID_HANDLER",
        "%s hook should be a function, instead got %s",
        500,
        TypeError,
      ),
      FST_ERR_HOOK_INVALID_ASYNC_HANDLER: W(
        "FST_ERR_HOOK_INVALID_ASYNC_HANDLER",
        "Async function has too many arguments. Async hooks should not use the 'done' argument.",
        500,
        TypeError,
      ),
      FST_ERR_HOOK_NOT_SUPPORTED: W(
        "FST_ERR_HOOK_NOT_SUPPORTED",
        "%s hook not supported!",
        500,
        TypeError,
      ),
      FST_ERR_MISSING_MIDDLEWARE: W(
        "FST_ERR_MISSING_MIDDLEWARE",
        "You must register a plugin for handling middlewares, visit fastify.dev/docs/latest/Reference/Middleware/ for more info.",
        500,
      ),
      FST_ERR_HOOK_TIMEOUT: W(
        "FST_ERR_HOOK_TIMEOUT",
        "A callback for '%s' hook timed out. You may have forgotten to call 'done' function or to resolve a Promise",
      ),
      FST_ERR_LOG_INVALID_DESTINATION: W(
        "FST_ERR_LOG_INVALID_DESTINATION",
        "Cannot specify both logger.stream and logger.file options",
      ),
      FST_ERR_LOG_INVALID_LOGGER: W(
        "FST_ERR_LOG_INVALID_LOGGER",
        "Invalid logger object provided. The logger instance should have these functions(s): '%s'.",
        500,
        TypeError,
      ),
      FST_ERR_REP_INVALID_PAYLOAD_TYPE: W(
        "FST_ERR_REP_INVALID_PAYLOAD_TYPE",
        "Attempted to send payload of invalid type '%s'. Expected a string or Buffer.",
        500,
        TypeError,
      ),
      FST_ERR_REP_RESPONSE_BODY_CONSUMED: W(
        "FST_ERR_REP_RESPONSE_BODY_CONSUMED",
        "Response.body is already consumed.",
      ),
      FST_ERR_REP_ALREADY_SENT: W(
        "FST_ERR_REP_ALREADY_SENT",
        'Reply was already sent, did you forget to "return reply" in "%s" (%s)?',
      ),
      FST_ERR_REP_SENT_VALUE: W(
        "FST_ERR_REP_SENT_VALUE",
        "The only possible value for reply.sent is true.",
        500,
        TypeError,
      ),
      FST_ERR_SEND_INSIDE_ONERR: W(
        "FST_ERR_SEND_INSIDE_ONERR",
        "You cannot use `send` inside the `onError` hook",
      ),
      FST_ERR_SEND_UNDEFINED_ERR: W("FST_ERR_SEND_UNDEFINED_ERR", "Undefined error has occurred"),
      FST_ERR_BAD_STATUS_CODE: W(
        "FST_ERR_BAD_STATUS_CODE",
        "Called reply with an invalid status code: %s",
      ),
      FST_ERR_BAD_TRAILER_NAME: W(
        "FST_ERR_BAD_TRAILER_NAME",
        "Called reply.trailer with an invalid header name: %s",
      ),
      FST_ERR_BAD_TRAILER_VALUE: W(
        "FST_ERR_BAD_TRAILER_VALUE",
        "Called reply.trailer('%s', fn) with an invalid type: %s. Expected a function.",
      ),
      FST_ERR_FAILED_ERROR_SERIALIZATION: W(
        "FST_ERR_FAILED_ERROR_SERIALIZATION",
        "Failed to serialize an error. Error: %s. Original error: %s",
      ),
      FST_ERR_MISSING_SERIALIZATION_FN: W(
        "FST_ERR_MISSING_SERIALIZATION_FN",
        'Missing serialization function. Key "%s"',
      ),
      FST_ERR_MISSING_CONTENTTYPE_SERIALIZATION_FN: W(
        "FST_ERR_MISSING_CONTENTTYPE_SERIALIZATION_FN",
        'Missing serialization function. Key "%s:%s"',
      ),
      FST_ERR_REQ_INVALID_VALIDATION_INVOCATION: W(
        "FST_ERR_REQ_INVALID_VALIDATION_INVOCATION",
        'Invalid validation invocation. Missing validation function for HTTP part "%s" nor schema provided.',
      ),
      FST_ERR_SCH_MISSING_ID: W("FST_ERR_SCH_MISSING_ID", "Missing schema $id property"),
      FST_ERR_SCH_ALREADY_PRESENT: W(
        "FST_ERR_SCH_ALREADY_PRESENT",
        "Schema with id '%s' already declared!",
      ),
      FST_ERR_SCH_CONTENT_MISSING_SCHEMA: W(
        "FST_ERR_SCH_CONTENT_MISSING_SCHEMA",
        "Schema is missing for the content type '%s'",
      ),
      FST_ERR_SCH_DUPLICATE: W("FST_ERR_SCH_DUPLICATE", "Schema with '%s' already present!"),
      FST_ERR_SCH_VALIDATION_BUILD: W(
        "FST_ERR_SCH_VALIDATION_BUILD",
        "Failed building the validation schema for %s: %s, due to error %s",
      ),
      FST_ERR_SCH_SERIALIZATION_BUILD: W(
        "FST_ERR_SCH_SERIALIZATION_BUILD",
        "Failed building the serialization schema for %s: %s, due to error %s",
      ),
      FST_ERR_SCH_RESPONSE_SCHEMA_NOT_NESTED_2XX: W(
        "FST_ERR_SCH_RESPONSE_SCHEMA_NOT_NESTED_2XX",
        'response schemas should be nested under a valid status code, e.g { 2xx: { type: "object" } }',
      ),
      FST_ERR_HTTP2_INVALID_VERSION: W(
        "FST_ERR_HTTP2_INVALID_VERSION",
        "HTTP2 is available only from node >= 8.8.1",
      ),
      FST_ERR_INIT_OPTS_INVALID: W(
        "FST_ERR_INIT_OPTS_INVALID",
        "Invalid initialization options: '%s'",
      ),
      FST_ERR_FORCE_CLOSE_CONNECTIONS_IDLE_NOT_AVAILABLE: W(
        "FST_ERR_FORCE_CLOSE_CONNECTIONS_IDLE_NOT_AVAILABLE",
        "Cannot set forceCloseConnections to 'idle' as your HTTP server does not support closeIdleConnections method",
      ),
      FST_ERR_DUPLICATED_ROUTE: W(
        "FST_ERR_DUPLICATED_ROUTE",
        "Method '%s' already declared for route '%s'",
      ),
      FST_ERR_BAD_URL: W("FST_ERR_BAD_URL", "'%s' is not a valid url component", 400, URIError),
      FST_ERR_ASYNC_CONSTRAINT: W(
        "FST_ERR_ASYNC_CONSTRAINT",
        "Unexpected error from async constraint",
        500,
      ),
      FST_ERR_DEFAULT_ROUTE_INVALID_TYPE: W(
        "FST_ERR_DEFAULT_ROUTE_INVALID_TYPE",
        "The defaultRoute type should be a function",
        500,
        TypeError,
      ),
      FST_ERR_INVALID_URL: W(
        "FST_ERR_INVALID_URL",
        "URL must be a string. Received '%s'",
        400,
        TypeError,
      ),
      FST_ERR_ROUTE_OPTIONS_NOT_OBJ: W(
        "FST_ERR_ROUTE_OPTIONS_NOT_OBJ",
        'Options for "%s:%s" route must be an object',
        500,
        TypeError,
      ),
      FST_ERR_ROUTE_DUPLICATED_HANDLER: W(
        "FST_ERR_ROUTE_DUPLICATED_HANDLER",
        'Duplicate handler for "%s:%s" route is not allowed!',
        500,
      ),
      FST_ERR_ROUTE_HANDLER_NOT_FN: W(
        "FST_ERR_ROUTE_HANDLER_NOT_FN",
        "Error Handler for %s:%s route, if defined, must be a function",
        500,
        TypeError,
      ),
      FST_ERR_ROUTE_MISSING_HANDLER: W(
        "FST_ERR_ROUTE_MISSING_HANDLER",
        'Missing handler function for "%s:%s" route.',
        500,
      ),
      FST_ERR_ROUTE_METHOD_INVALID: W(
        "FST_ERR_ROUTE_METHOD_INVALID",
        "Provided method is invalid!",
        500,
        TypeError,
      ),
      FST_ERR_ROUTE_METHOD_NOT_SUPPORTED: W(
        "FST_ERR_ROUTE_METHOD_NOT_SUPPORTED",
        "%s method is not supported.",
        500,
      ),
      FST_ERR_ROUTE_BODY_VALIDATION_SCHEMA_NOT_SUPPORTED: W(
        "FST_ERR_ROUTE_BODY_VALIDATION_SCHEMA_NOT_SUPPORTED",
        "Body validation schema for %s:%s route is not supported!",
        500,
      ),
      FST_ERR_ROUTE_BODY_LIMIT_OPTION_NOT_INT: W(
        "FST_ERR_ROUTE_BODY_LIMIT_OPTION_NOT_INT",
        "'bodyLimit' option must be an integer > 0. Got '%s'",
        500,
        TypeError,
      ),
      FST_ERR_ROUTE_REWRITE_NOT_STR: W(
        "FST_ERR_ROUTE_REWRITE_NOT_STR",
        'Rewrite url for "%s" needs to be of type "string" but received "%s"',
        500,
        TypeError,
      ),
      FST_ERR_REOPENED_CLOSE_SERVER: W(
        "FST_ERR_REOPENED_CLOSE_SERVER",
        "Fastify has already been closed and cannot be reopened",
      ),
      FST_ERR_REOPENED_SERVER: W("FST_ERR_REOPENED_SERVER", "Fastify is already listening"),
      FST_ERR_INSTANCE_ALREADY_LISTENING: W(
        "FST_ERR_INSTANCE_ALREADY_LISTENING",
        "Fastify instance is already listening. %s",
      ),
      FST_ERR_PLUGIN_VERSION_MISMATCH: W(
        "FST_ERR_PLUGIN_VERSION_MISMATCH",
        "fastify-plugin: %s - expected '%s' fastify version, '%s' is installed",
      ),
      FST_ERR_PLUGIN_NOT_PRESENT_IN_INSTANCE: W(
        "FST_ERR_PLUGIN_NOT_PRESENT_IN_INSTANCE",
        "The decorator '%s'%s is not present in %s",
      ),
      FST_ERR_PLUGIN_CALLBACK_NOT_FN: W(
        "FST_ERR_PLUGIN_CALLBACK_NOT_FN",
        "fastify-plugin: %s",
        500,
        TypeError,
      ),
      FST_ERR_PLUGIN_NOT_VALID: W("FST_ERR_PLUGIN_NOT_VALID", "fastify-plugin: %s"),
      FST_ERR_ROOT_PLG_BOOTED: W("FST_ERR_ROOT_PLG_BOOTED", "fastify-plugin: %s"),
      FST_ERR_PARENT_PLUGIN_BOOTED: W("FST_ERR_PARENT_PLUGIN_BOOTED", "fastify-plugin: %s"),
      FST_ERR_PLUGIN_TIMEOUT: W("FST_ERR_PLUGIN_TIMEOUT", "fastify-plugin: %s"),
    };
  function hx(e, t) {
    return (t.cause = e), t;
  }
  xl.exports = li;
  xl.exports.appendStackTrace = hx;
  xl.exports.AVVIO_ERRORS_MAP = {
    AVV_ERR_CALLBACK_NOT_FN: li.FST_ERR_PLUGIN_CALLBACK_NOT_FN,
    AVV_ERR_PLUGIN_NOT_VALID: li.FST_ERR_PLUGIN_NOT_VALID,
    AVV_ERR_ROOT_PLG_BOOTED: li.FST_ERR_ROOT_PLG_BOOTED,
    AVV_ERR_PARENT_PLG_LOADED: li.FST_ERR_PARENT_PLUGIN_BOOTED,
    AVV_ERR_READY_TIMEOUT: li.FST_ERR_PLUGIN_TIMEOUT,
    AVV_ERR_PLUGIN_EXEC_TIMEOUT: li.FST_ERR_PLUGIN_TIMEOUT,
  };
});
var Os = b((Nne, Zv) => {
  "use strict";
  var px = ["onRoute", "onRegister", "onReady", "onListen", "preClose", "onClose"],
    Jv = [
      "onTimeout",
      "onRequest",
      "preParsing",
      "preValidation",
      "preSerialization",
      "preHandler",
      "onSend",
      "onResponse",
      "onError",
      "onRequestAbort",
    ],
    mx = Jv.concat(px),
    {
      FST_ERR_HOOK_INVALID_TYPE: yx,
      FST_ERR_HOOK_INVALID_HANDLER: gx,
      FST_ERR_SEND_UNDEFINED_ERR: Fl,
      FST_ERR_HOOK_TIMEOUT: _x,
      FST_ERR_HOOK_NOT_SUPPORTED: Sx,
      AVVIO_ERRORS_MAP: Bv,
      appendStackTrace: Kv,
    } = tr(),
    { kChildren: ma, kHooks: Qv, kRequestPayloadStream: Gv } = Vt();
  function ya() {
    (this.onRequest = []),
      (this.preParsing = []),
      (this.preValidation = []),
      (this.preSerialization = []),
      (this.preHandler = []),
      (this.onResponse = []),
      (this.onSend = []),
      (this.onError = []),
      (this.onRoute = []),
      (this.onRegister = []),
      (this.onReady = []),
      (this.onListen = []),
      (this.onTimeout = []),
      (this.onRequestAbort = []),
      (this.preClose = []);
  }
  ya.prototype = Object.create(null);
  ya.prototype.validate = function (e, t) {
    if (typeof e != "string") throw new yx();
    if (Array.isArray(this[e]) === !1) throw new Sx(e);
    if (typeof t != "function") throw new gx(e, Object.prototype.toString.call(t));
  };
  ya.prototype.add = function (e, t) {
    this.validate(e, t), this[e].push(t);
  };
  function vx(e) {
    let t = new ya();
    return (
      (t.onRequest = e.onRequest.slice()),
      (t.preParsing = e.preParsing.slice()),
      (t.preValidation = e.preValidation.slice()),
      (t.preSerialization = e.preSerialization.slice()),
      (t.preHandler = e.preHandler.slice()),
      (t.onSend = e.onSend.slice()),
      (t.onResponse = e.onResponse.slice()),
      (t.onError = e.onError.slice()),
      (t.onRoute = e.onRoute.slice()),
      (t.onRegister = e.onRegister.slice()),
      (t.onTimeout = e.onTimeout.slice()),
      (t.onRequestAbort = e.onRequestAbort.slice()),
      (t.onReady = []),
      (t.onListen = []),
      (t.preClose = []),
      t
    );
  }
  function Wv(e, t, r, n) {
    let s = r[Qv][e],
      i = 0,
      o = 0;
    u();
    function a(c) {
      if (c) {
        c.code === "AVV_ERR_READY_TIMEOUT"
          ? (c = Kv(c, new _x(e)))
          : (c = Bv[c.code] != null ? Kv(c, new Bv[c.code](c.message)) : c),
          n(c);
        return;
      }
      n();
    }
    function u(c) {
      if (c) {
        a(c);
        return;
      }
      if (i === s.length && o === r[ma].length) {
        i === 0 && o === 0
          ? a()
          : t(function (d, h) {
              a(d), h(d);
            });
        return;
      }
      if (i === s.length && o < r[ma].length) {
        let f = r[ma][o++];
        Wv(e, t, f, u);
        return;
      }
      t(l(s[i++], r)), u();
    }
    function l(c, f) {
      return function (d, h) {
        if (d) {
          h(d);
          return;
        }
        if (c.length === 1) {
          try {
            c.call(f, h);
          } catch (p) {
            h(p);
          }
          return;
        }
        try {
          let p = c.call(f);
          if (p && typeof p.then == "function") {
            p.then(h, h);
            return;
          }
        } catch (p) {
          d = p;
        }
        h(d);
      };
    }
  }
  function Yv(e) {
    let t = e[Qv].onListen,
      r = t.length,
      n = 0,
      s = 0;
    i();
    function i(a) {
      if ((a && e.log.error(a), n === r)) {
        for (; s < e[ma].length; ) {
          let u = e[ma][s++];
          Yv(u);
        }
        return;
      }
      o(t[n++], e, i);
    }
    async function o(a, u, l) {
      if (a.length === 1) {
        try {
          a.call(u, l);
        } catch (c) {
          l(c);
        }
        return;
      }
      try {
        let c = a.call(u);
        if (c && typeof c.then == "function") {
          c.then(l, l);
          return;
        }
        l();
      } catch (c) {
        l(c);
      }
    }
  }
  function to(e) {
    return function (r, n, s, i) {
      let o = 0;
      function a(c) {
        if (c || o === r.length) {
          i(c, n, s);
          return;
        }
        let f;
        try {
          f = e(r[o++], n, s, a);
        } catch (d) {
          i(d, n, s);
          return;
        }
        f && typeof f.then == "function" && f.then(u, l);
      }
      function u() {
        a();
      }
      function l(c) {
        c || (c = new Fl()), i(c, n, s);
      }
      a();
    };
  }
  function bx(e, t, r, n) {
    return e(t, r, n);
  }
  var wx = to(bx),
    Ex = to(ga),
    Rx = to(ga),
    Tx = to(ga),
    Px = to(ga);
  function Xv(e, t, r, n, s) {
    let i = 0;
    function o(l, c) {
      if (l) {
        s(l, t, r, n);
        return;
      }
      if ((c !== void 0 && (n = c), i === e.length)) {
        s(null, t, r, n);
        return;
      }
      let f;
      try {
        f = e[i++](t, r, n, o);
      } catch (d) {
        s(d, t, r);
        return;
      }
      f && typeof f.then == "function" && f.then(a, u);
    }
    function a(l) {
      o(null, l);
    }
    function u(l) {
      l || (l = new Fl()), s(l, t, r, n);
    }
    o();
  }
  var $x = Xv;
  function Ox(e, t, r, n) {
    let s = 0;
    function i(u, l) {
      if (r.sent) return;
      if ((l !== void 0 && (t[Gv] = l), u || s === e.length)) {
        n(u, t, r);
        return;
      }
      let c;
      try {
        c = e[s++](t, r, t[Gv], i);
      } catch (f) {
        n(f, t, r);
        return;
      }
      c && typeof c.then == "function" && c.then(o, a);
    }
    function o(u) {
      i(null, u);
    }
    function a(u) {
      u || (u = new Fl()), n(u, t, r);
    }
    i();
  }
  function Nx(e, t, r) {
    let n = 0;
    function s(a) {
      if (a || n === e.length) {
        r(a, t);
        return;
      }
      let u;
      try {
        u = e[n++](t, s);
      } catch (l) {
        r(l, t);
        return;
      }
      u && typeof u.then == "function" && u.then(i, o);
    }
    function i() {
      s();
    }
    function o(a) {
      a || (a = new Fl()), r(a, t);
    }
    s();
  }
  function ga(e, t, r, n) {
    if (r.sent !== !0) return e(t, r, n);
  }
  Zv.exports = {
    Hooks: ya,
    buildHooks: vx,
    hookRunnerGenerator: to,
    preParsingHookRunner: Ox,
    onResponseHookRunner: wx,
    onSendHookRunner: Xv,
    preSerializationHookRunner: $x,
    onRequestAbortHookRunner: Nx,
    hookIterator: ga,
    hookRunnerApplication: Wv,
    onListenHookRunner: Yv,
    preHandlerHookRunner: Rx,
    preValidationHookRunner: Ex,
    onRequestHookRunner: Px,
    onTimeoutHookRunner: Tx,
    lifecycleHooks: Jv,
    supportedHooks: mx,
  };
});
var lb = b((Ane, $h) => {
  "use strict";
  var Ax = require("node:http"),
    Ix = require("node:https"),
    Cx = require("node:dns"),
    { FSTDEP011: eb } = ts(),
    { kState: rr, kOptions: kx, kServerBindings: Dx } = Vt(),
    { onListenHookRunner: Ml } = Os(),
    {
      FST_ERR_HTTP2_INVALID_VERSION: qx,
      FST_ERR_REOPENED_CLOSE_SERVER: nb,
      FST_ERR_REOPENED_SERVER: sb,
      FST_ERR_LISTEN_OPTIONS_INVALID: jx,
    } = tr();
  $h.exports.createServer = Lx;
  $h.exports.compileValidateHTTPVersion = Fx;
  function ib(e) {
    return `Server listening at ${e}`;
  }
  function Lx(e, t) {
    let r = ab(e, t);
    function n(s, ...i) {
      let o = i.slice(-1).pop(),
        a = Object.prototype.toString.call(arguments[0]);
      if (arguments.length === 0) s = Ph([]);
      else if (arguments.length > 0 && a !== "[object Object]" && a !== "[object Function]")
        eb(), (s = Ph(Array.from(arguments))), (o = s.cb);
      else if (i.length > 1) {
        eb();
        let l = s.path ? [s.path] : [s.port ?? 0, s.host ?? "localhost"];
        Object.assign(s, Ph([...l, ...i]));
      } else s.cb = o;
      if (s.signal) {
        if (typeof s.signal.on != "function" && typeof s.signal.addEventListener != "function")
          throw new jx("Invalid options.signal");
        if (s.signal.aborted) this.close();
        else {
          let l = () => {
            this.close();
          };
          s.signal.addEventListener("abort", l, { once: !0 });
        }
      }
      let u;
      if (
        (s.path == null ? (u = s.host ?? "localhost") : (u = s.host),
        Object.prototype.hasOwnProperty.call(s, "host") === !1 && (s.host = u),
        u === "localhost"
          ? (s.cb = (l, c) => {
              if (l) {
                o(l, c);
                return;
              }
              tb.call(this, r, t, e, s, () => {
                (this[rr].listening = !0), o(null, c), Ml(this);
              });
            })
          : (s.cb = (l, c) => {
              if (l) {
                o(l, c);
                return;
              }
              (this[rr].listening = !0), o(null, c), Ml(this);
            }),
        o === void 0)
      )
        return xx.call(this, r, s).then(
          (c) =>
            new Promise((f, d) => {
              u === "localhost"
                ? tb.call(this, r, t, e, s, () => {
                    (this[rr].listening = !0), f(c), Ml(this);
                  })
                : (f(c), Ml(this));
            }),
        );
      this.ready(ob.call(this, r, s));
    }
    return { server: r, listen: n };
  }
  function tb(e, t, r, n, s) {
    (this[rr].listening = !1),
      Cx.lookup(n.host, { all: !0 }, (i, o) => {
        if (i) {
          s();
          return;
        }
        let a = e.listening && r.serverFactory,
          u = 0,
          l = 0;
        if (!a) {
          let f = e.address();
          for (let d of o)
            if (d.address !== f.address) {
              u++;
              let h = Object.assign({}, n, {
                  host: d.address,
                  port: f.port,
                  cb: (_) => {
                    l++, _ || this[Dx].push(p), l === u && s();
                  },
                }),
                p = ab(r, t),
                y = () => {
                  p.close(() => {}),
                    r.forceCloseConnections === "idle"
                      ? p.closeIdleConnections()
                      : typeof p.closeAllConnections == "function" &&
                        r.forceCloseConnections &&
                        p.closeAllConnections();
                };
              p.on("upgrade", e.emit.bind(e, "upgrade")),
                e.on("unref", y),
                e.on("close", y),
                e.on("error", y),
                (this[rr].listening = !1),
                ob.call(this, p, h)();
            }
        }
        if (u === 0) {
          s();
          return;
        }
        let c = e.unref;
        e.unref = function () {
          c.call(e), e.emit("unref");
        };
      });
  }
  function ob(e, t) {
    let r = (n) => {
      if ((e.removeListener("error", r), n)) (this[rr].listening = !1), t.cb(n, null);
      else {
        let s = ub.call(this, e, t.listenTextResolver || ib);
        t.cb(null, s);
      }
    };
    return (n) => {
      if (n != null) return t.cb(n);
      if (this[rr].listening && this[rr].closing) return t.cb(new nb(), null);
      if (this[rr].listening) return t.cb(new sb(), null);
      e.once("error", r), this[rr].closing || (e.listen(t, r), (this[rr].listening = !0));
    };
  }
  function xx(e, t) {
    return this[rr].listening && this[rr].closing
      ? Promise.reject(new nb())
      : this[rr].listening
        ? Promise.reject(new sb())
        : this.ready().then(() => {
            let r,
              n = new Promise((i, o) => {
                (r = (a) => {
                  (this[rr].listening = !1), o(a);
                }),
                  e.once("error", r);
              }),
              s = new Promise((i, o) => {
                e.listen(t, () => {
                  e.removeListener("error", r), i(ub.call(this, e, t.listenTextResolver || ib));
                }),
                  (this[rr].listening = !0);
              });
            return Promise.race([n, s]);
          });
  }
  function Fx(e) {
    let t = !1,
      r = new Map();
    return (
      e.serverFactory && (t = !0),
      e.http2
        ? (r.set("2.0", !0),
          e.https && e.https.allowHTTP1 === !0 && (r.set("1.1", !0), r.set("1.0", !0)))
        : (r.set("1.1", !0), r.set("1.0", !0)),
      function (s) {
        return t || r.has(s);
      }
    );
  }
  function ab(e, t) {
    let r = null,
      n = e.https === !0 ? {} : e.https;
    return (
      e.serverFactory
        ? (r = e.serverFactory(t, e))
        : e.http2
          ? (typeof n == "object"
              ? (r = rb().createSecureServer(n, t))
              : (r = rb().createServer(t)),
            r.on("session", zx(e.http2SessionTimeout)))
          : (n ? (r = Ix.createServer(n, t)) : (r = Ax.createServer(e.http, t)),
            (r.keepAliveTimeout = e.keepAliveTimeout),
            (r.requestTimeout = e.requestTimeout),
            e.maxRequestsPerSocket > 0 && (r.maxRequestsPerSocket = e.maxRequestsPerSocket)),
      e.serverFactory || r.setTimeout(e.connectionTimeout),
      r
    );
  }
  function Ph(e) {
    if (e.length === 0) return { port: 0, host: "localhost" };
    let r = { cb: typeof e[e.length - 1] == "function" ? e.pop() : void 0 },
      n = e[0],
      s = e.length,
      i = e[s - 1];
    return (
      typeof n == "string" && isNaN(n)
        ? ((r.path = n), (r.backlog = s > 1 ? i : void 0))
        : ((r.port = s >= 1 && Number.isInteger(n) ? n : Mx(n)),
          (r.host = s >= 2 && e[1] ? e[1] : "localhost"),
          (r.backlog = s >= 3 ? e[2] : void 0)),
      r
    );
  }
  function Mx(e) {
    let t = Number(e);
    return t >= 0 && !Number.isNaN(t) && Number.isInteger(t) ? t : 0;
  }
  function ub(e, t) {
    let r = e.address(),
      n = typeof r == "string";
    n ||
      (r.address.indexOf(":") === -1
        ? (r = r.address + ":" + r.port)
        : (r = "[" + r.address + "]:" + r.port)),
      (r = (n ? "" : "http" + (this[kx].https ? "s" : "") + "://") + r);
    let s = t(r);
    return this.log.info(s), r;
  }
  function rb() {
    try {
      return require("node:http2");
    } catch {
      throw new qx();
    }
  }
  function zx(e) {
    return function (t) {
      t.setTimeout(e, Vx);
    };
  }
  function Vx() {
    this.close();
  }
});
var Ih = b((Ine, fb) => {
  "use strict";
  var {
      kSchemaHeaders: Ul,
      kSchemaParams: Oh,
      kSchemaQuerystring: Nh,
      kSchemaBody: Ah,
      kSchemaResponse: cb,
    } = Vt(),
    Ux = /^[1-5]{1}[0-9]{2}$|^[1-5]xx$|^default$/,
    { FST_ERR_SCH_RESPONSE_SCHEMA_NOT_NESTED_2XX: Hx } = tr(),
    { FSTWRN001: zl } = ts();
  function Bx(e, t) {
    if (!e.schema || !e.schema.response) return;
    let { method: r, url: n } = e.config || {};
    e[cb] = Object.keys(e.schema.response).reduce(function (s, i) {
      let o = e.schema.response[i];
      if (((i = i.toLowerCase()), !Ux.exec(i))) throw new Hx();
      if (o.content) {
        let a = {};
        for (let u of Object.keys(o.content)) {
          let l = o.content[u].schema;
          a[u] = t({ schema: l, url: n, method: r, httpStatus: i, contentType: u });
        }
        s[i] = a;
      } else s[i] = t({ schema: o, url: n, method: r, httpStatus: i });
      return s;
    }, {});
  }
  function Kx(e, t, r) {
    let { schema: n } = e;
    if (!n) return;
    let { method: s, url: i } = e.config || {},
      o = n.headers;
    if (o && (r || Object.getPrototypeOf(o) !== Object.prototype))
      e[Ul] = t({ schema: o, method: s, url: i, httpPart: "headers" });
    else if (o) {
      let a = {};
      Object.keys(o).forEach((u) => {
        a[u] = o[u];
      }),
        a.required instanceof Array && (a.required = a.required.map((u) => u.toLowerCase())),
        o.properties &&
          ((a.properties = {}),
          Object.keys(o.properties).forEach((u) => {
            a.properties[u.toLowerCase()] = o.properties[u];
          })),
        (e[Ul] = t({ schema: a, method: s, url: i, httpPart: "headers" }));
    } else Object.prototype.hasOwnProperty.call(n, "headers") && zl("headers", s, i);
    n.body
      ? (e[Ah] = t({ schema: n.body, method: s, url: i, httpPart: "body" }))
      : Object.prototype.hasOwnProperty.call(n, "body") && zl("body", s, i),
      n.querystring
        ? (e[Nh] = t({ schema: n.querystring, method: s, url: i, httpPart: "querystring" }))
        : Object.prototype.hasOwnProperty.call(n, "querystring") && zl("querystring", s, i),
      n.params
        ? (e[Oh] = t({ schema: n.params, method: s, url: i, httpPart: "params" }))
        : Object.prototype.hasOwnProperty.call(n, "params") && zl("params", s, i);
  }
  function Vl(e, t, r) {
    let n = t[r] === void 0,
      s = e && e(n ? null : t[r]);
    if (s?.then) return s.then((o) => i(o)).catch((o) => o);
    return i(s);
    function i(o) {
      return o === !1 ? e.errors : o && o.error ? o.error : (o && o.value && (t[r] = o.value), !1);
    }
  }
  function Hl(e, t, r) {
    let n = r === void 0;
    if (n || !r.skipParams) {
      let i = Vl(e[Oh], t, "params");
      if (i)
        return typeof i.then != "function" ? Ns(i, "params", e.schemaErrorFormatter) : Gx(i, e, t);
    }
    if (n || !r.skipBody) {
      let i = Vl(e[Ah], t, "body");
      if (i)
        return typeof i.then != "function" ? Ns(i, "body", e.schemaErrorFormatter) : Jx(i, e, t);
    }
    if (n || !r.skipQuery) {
      let i = Vl(e[Nh], t, "query");
      if (i)
        return typeof i.then != "function"
          ? Ns(i, "querystring", e.schemaErrorFormatter)
          : Qx(i, e, t);
    }
    let s = Vl(e[Ul], t, "headers");
    return s
      ? typeof s.then != "function"
        ? Ns(s, "headers", e.schemaErrorFormatter)
        : Wx(s, e, t)
      : !1;
  }
  function Gx(e, t, r) {
    return e.then((n) =>
      n ? Ns(n, "params", t.schemaErrorFormatter) : Hl(t, r, { skipParams: !0 }),
    );
  }
  function Jx(e, t, r) {
    return e.then((n) =>
      n ? Ns(n, "body", t.schemaErrorFormatter) : Hl(t, r, { skipParams: !0, skipBody: !0 }),
    );
  }
  function Qx(e, t, r) {
    return e.then((n) =>
      n
        ? Ns(n, "querystring", t.schemaErrorFormatter)
        : Hl(t, r, { skipParams: !0, skipBody: !0, skipQuery: !0 }),
    );
  }
  function Wx(e, t, r) {
    return e.then((n) => (n ? Ns(n, "headers", t.schemaErrorFormatter) : !1));
  }
  function Ns(e, t, r) {
    if (e instanceof Error)
      return (
        (e.statusCode = e.statusCode || 400),
        (e.code = e.code || "FST_ERR_VALIDATION"),
        (e.validationContext = e.validationContext || t),
        e
      );
    let n = r(e, t);
    return (
      (n.statusCode = n.statusCode || 400),
      (n.code = n.code || "FST_ERR_VALIDATION"),
      (n.validation = e),
      (n.validationContext = t),
      n
    );
  }
  fb.exports = {
    symbols: {
      bodySchema: Ah,
      querystringSchema: Nh,
      responseSchema: cb,
      paramsSchema: Oh,
      headersSchema: Ul,
    },
    compileSchemasForValidation: Kx,
    compileSchemasForSerialization: Bx,
    validate: Hl,
  };
});
var Ch = b((Cne, hb) => {
  "use strict";
  var { kReplyIsError: db, kReplyHijacked: Yx } = Vt();
  function Xx(e, t) {
    e.then(
      function (r) {
        if (
          t[Yx] !== !0 &&
          (r !== void 0 ||
            (t.sent === !1 && t.raw.headersSent === !1 && t.request.raw.aborted === !1))
        )
          try {
            t.send(r);
          } catch (n) {
            (t[db] = !0), t.send(n);
          }
      },
      function (r) {
        if (t.sent === !0) {
          t.log.error({ err: r }, "Promise errored, but reply.sent = true was set");
          return;
        }
        t[db] = !0;
        try {
          t.send(r);
        } catch (n) {
          t.send(n);
        }
      },
    );
  }
  hb.exports = Xx;
});
var jh = b((kne, qh) => {
  "use strict";
  var { validate: Zx } = Ih(),
    { preValidationHookRunner: eF, preHandlerHookRunner: tF } = Os(),
    rF = Ch(),
    { kReplyIsError: Bl, kRouteContext: Is } = Vt();
  function nF(e, t, r) {
    if (r.sent === !0) return;
    if (e != null) {
      (r[Bl] = !0), r.send(e);
      return;
    }
    let n = t.raw.method,
      s = t.headers,
      i = t[Is];
    if (n === "GET" || n === "HEAD") {
      As(t, r);
      return;
    }
    let o = s["content-type"];
    if (
      n === "POST" ||
      n === "PUT" ||
      n === "PATCH" ||
      n === "TRACE" ||
      n === "SEARCH" ||
      n === "PROPFIND" ||
      n === "PROPPATCH" ||
      n === "LOCK" ||
      n === "REPORT" ||
      n === "MKCALENDAR"
    ) {
      o === void 0
        ? s["transfer-encoding"] === void 0 &&
          (s["content-length"] === "0" || s["content-length"] === void 0)
          ? As(t, r)
          : i.contentTypeParser.run("", As, t, r)
        : i.contentTypeParser.run(o, As, t, r);
      return;
    }
    if (n === "OPTIONS" || n === "DELETE") {
      o !== void 0 && (s["transfer-encoding"] !== void 0 || s["content-length"] !== void 0)
        ? i.contentTypeParser.run(o, As, t, r)
        : As(t, r);
      return;
    }
    As(t, r);
  }
  function As(e, t) {
    try {
      e[Is].preValidation !== null ? eF(e[Is].preValidation, e, t, kh) : kh(null, e, t);
    } catch (r) {
      kh(r, e, t);
    }
  }
  function kh(e, t, r) {
    if (r.sent === !0) return;
    if (e != null) {
      (r[Bl] = !0), r.send(e);
      return;
    }
    let n = Zx(r[Is], t);
    if ((n && typeof n.then == "function") || !1) {
      let i = pb.bind(null, t, r);
      n.then(i, i);
    } else pb(t, r, n);
  }
  function pb(e, t, r) {
    if (r) {
      if (t[Is].attachValidation === !1) {
        t.send(r);
        return;
      }
      t.request.validationError = r;
    }
    e[Is].preHandler !== null ? tF(e[Is].preHandler, e, t, Dh) : Dh(null, e, t);
  }
  function Dh(e, t, r) {
    if (r.sent) return;
    if (e != null) {
      (r[Bl] = !0), r.send(e);
      return;
    }
    let n;
    try {
      n = t[Is].handler(t, r);
    } catch (s) {
      (r[Bl] = !0), r.send(s);
      return;
    }
    n !== void 0 && (n !== null && typeof n.then == "function" ? rF(n, r) : r.send(n));
  }
  qh.exports = nF;
  qh.exports[Symbol.for("internals")] = { handler: As, preHandlerCallback: Dh };
});
var yb = b((Dne, mb) => {
  "use strict";
  function ro() {}
  var sF = { fatal: ro, error: ro, warn: ro, info: ro, debug: ro, trace: ro };
  Object.defineProperty(mb, "exports", {
    get() {
      return Object.create(sF);
    },
  });
});
var xh = b((qne, Sb) => {
  "use strict";
  var _a = (e) => e && typeof e.message == "string",
    Lh = (e) => {
      if (!e) return;
      let t = e.cause;
      if (typeof t == "function") {
        let r = e.cause();
        return _a(r) ? r : void 0;
      } else return _a(t) ? t : void 0;
    },
    gb = (e, t) => {
      if (!_a(e)) return "";
      let r = e.stack || "";
      if (t.has(e))
        return (
          r +
          `
causes have become circular...`
        );
      let n = Lh(e);
      return n
        ? (t.add(e),
          r +
            `
caused by: ` +
            gb(n, t))
        : r;
    },
    iF = (e) => gb(e, new Set()),
    _b = (e, t, r) => {
      if (!_a(e)) return "";
      let n = r ? "" : e.message || "";
      if (t.has(e)) return n + ": ...";
      let s = Lh(e);
      if (s) {
        t.add(e);
        let i = typeof e.cause == "function";
        return n + (i ? "" : ": ") + _b(s, t, i);
      } else return n;
    },
    oF = (e) => _b(e, new Set());
  Sb.exports = { isErrorLike: _a, getErrorCause: Lh, stackWithCauses: iF, messageWithCauses: oF };
});
var Fh = b((jne, bb) => {
  "use strict";
  var aF = Symbol("circular-ref-tag"),
    Kl = Symbol("pino-raw-err-ref"),
    vb = Object.create(
      {},
      {
        type: { enumerable: !0, writable: !0, value: void 0 },
        message: { enumerable: !0, writable: !0, value: void 0 },
        stack: { enumerable: !0, writable: !0, value: void 0 },
        aggregateErrors: { enumerable: !0, writable: !0, value: void 0 },
        raw: {
          enumerable: !1,
          get: function () {
            return this[Kl];
          },
          set: function (e) {
            this[Kl] = e;
          },
        },
      },
    );
  Object.defineProperty(vb, Kl, { writable: !0, value: {} });
  bb.exports = { pinoErrProto: vb, pinoErrorSymbols: { seen: aF, rawSymbol: Kl } };
});
var Rb = b((Lne, Eb) => {
  "use strict";
  Eb.exports = zh;
  var { messageWithCauses: uF, stackWithCauses: lF, isErrorLike: wb } = xh(),
    { pinoErrProto: cF, pinoErrorSymbols: fF } = Fh(),
    { seen: Mh } = fF,
    { toString: dF } = Object.prototype;
  function zh(e) {
    if (!wb(e)) return e;
    e[Mh] = void 0;
    let t = Object.create(cF);
    (t.type = dF.call(e.constructor) === "[object Function]" ? e.constructor.name : e.name),
      (t.message = uF(e)),
      (t.stack = lF(e)),
      Array.isArray(e.errors) && (t.aggregateErrors = e.errors.map((r) => zh(r)));
    for (let r in e)
      if (t[r] === void 0) {
        let n = e[r];
        wb(n)
          ? r !== "cause" && !Object.prototype.hasOwnProperty.call(n, Mh) && (t[r] = zh(n))
          : (t[r] = n);
      }
    return delete e[Mh], (t.raw = e), t;
  }
});
var Pb = b((xne, Tb) => {
  "use strict";
  Tb.exports = Jl;
  var { isErrorLike: Vh } = xh(),
    { pinoErrProto: hF, pinoErrorSymbols: pF } = Fh(),
    { seen: Gl } = pF,
    { toString: mF } = Object.prototype;
  function Jl(e) {
    if (!Vh(e)) return e;
    e[Gl] = void 0;
    let t = Object.create(hF);
    (t.type = mF.call(e.constructor) === "[object Function]" ? e.constructor.name : e.name),
      (t.message = e.message),
      (t.stack = e.stack),
      Array.isArray(e.errors) && (t.aggregateErrors = e.errors.map((r) => Jl(r))),
      Vh(e.cause) && !Object.prototype.hasOwnProperty.call(e.cause, Gl) && (t.cause = Jl(e.cause));
    for (let r in e)
      if (t[r] === void 0) {
        let n = e[r];
        Vh(n) ? Object.prototype.hasOwnProperty.call(n, Gl) || (t[r] = Jl(n)) : (t[r] = n);
      }
    return delete e[Gl], (t.raw = e), t;
  }
});
var Ab = b((Fne, Nb) => {
  "use strict";
  Nb.exports = { mapHttpRequest: yF, reqSerializer: Ob };
  var Uh = Symbol("pino-raw-req-ref"),
    $b = Object.create(
      {},
      {
        id: { enumerable: !0, writable: !0, value: "" },
        method: { enumerable: !0, writable: !0, value: "" },
        url: { enumerable: !0, writable: !0, value: "" },
        query: { enumerable: !0, writable: !0, value: "" },
        params: { enumerable: !0, writable: !0, value: "" },
        headers: { enumerable: !0, writable: !0, value: {} },
        remoteAddress: { enumerable: !0, writable: !0, value: "" },
        remotePort: { enumerable: !0, writable: !0, value: "" },
        raw: {
          enumerable: !1,
          get: function () {
            return this[Uh];
          },
          set: function (e) {
            this[Uh] = e;
          },
        },
      },
    );
  Object.defineProperty($b, Uh, { writable: !0, value: {} });
  function Ob(e) {
    let t = e.info || e.socket,
      r = Object.create($b);
    if (
      ((r.id = typeof e.id == "function" ? e.id() : e.id || (e.info ? e.info.id : void 0)),
      (r.method = e.method),
      e.originalUrl)
    )
      r.url = e.originalUrl;
    else {
      let n = e.path;
      r.url = typeof n == "string" ? n : e.url ? e.url.path || e.url : void 0;
    }
    return (
      e.query && (r.query = e.query),
      e.params && (r.params = e.params),
      (r.headers = e.headers),
      (r.remoteAddress = t && t.remoteAddress),
      (r.remotePort = t && t.remotePort),
      (r.raw = e.raw || e),
      r
    );
  }
  function yF(e) {
    return { req: Ob(e) };
  }
});
var Db = b((Mne, kb) => {
  "use strict";
  kb.exports = { mapHttpResponse: gF, resSerializer: Cb };
  var Hh = Symbol("pino-raw-res-ref"),
    Ib = Object.create(
      {},
      {
        statusCode: { enumerable: !0, writable: !0, value: 0 },
        headers: { enumerable: !0, writable: !0, value: "" },
        raw: {
          enumerable: !1,
          get: function () {
            return this[Hh];
          },
          set: function (e) {
            this[Hh] = e;
          },
        },
      },
    );
  Object.defineProperty(Ib, Hh, { writable: !0, value: {} });
  function Cb(e) {
    let t = Object.create(Ib);
    return (
      (t.statusCode = e.headersSent ? e.statusCode : null),
      (t.headers = e.getHeaders ? e.getHeaders() : e._headers),
      (t.raw = e),
      t
    );
  }
  function gF(e) {
    return { res: Cb(e) };
  }
});
var Kh = b((zne, qb) => {
  "use strict";
  var Bh = Rb(),
    _F = Pb(),
    Ql = Ab(),
    Wl = Db();
  qb.exports = {
    err: Bh,
    errWithCause: _F,
    mapHttpRequest: Ql.mapHttpRequest,
    mapHttpResponse: Wl.mapHttpResponse,
    req: Ql.reqSerializer,
    res: Wl.resSerializer,
    wrapErrorSerializer: function (t) {
      return t === Bh
        ? t
        : function (n) {
            return t(Bh(n));
          };
    },
    wrapRequestSerializer: function (t) {
      return t === Ql.reqSerializer
        ? t
        : function (n) {
            return t(Ql.reqSerializer(n));
          };
    },
    wrapResponseSerializer: function (t) {
      return t === Wl.resSerializer
        ? t
        : function (n) {
            return t(Wl.resSerializer(n));
          };
    },
  };
});
var Gh = b((Vne, jb) => {
  "use strict";
  function SF(e, t) {
    return t;
  }
  jb.exports = function () {
    let t = Error.prepareStackTrace;
    Error.prepareStackTrace = SF;
    let r = new Error().stack;
    if (((Error.prepareStackTrace = t), !Array.isArray(r))) return;
    let n = r.slice(2),
      s = [];
    for (let i of n) i && s.push(i.getFileName());
    return s;
  };
});
var xb = b((Une, Lb) => {
  "use strict";
  Lb.exports = vF;
  function vF(e = {}) {
    let {
      ERR_PATHS_MUST_BE_STRINGS: t = () => "fast-redact - Paths must be (non-empty) strings",
      ERR_INVALID_PATH: r = (n) => `fast-redact \u2013 Invalid path (${n})`,
    } = e;
    return function ({ paths: s }) {
      s.forEach((i) => {
        if (typeof i != "string") throw Error(t());
        try {
          if (/〇/.test(i)) throw Error();
          let o =
            (i[0] === "[" ? "" : ".") +
            i
              .replace(/^\*/, "\u3007")
              .replace(/\.\*/g, ".\u3007")
              .replace(/\[\*\]/g, "[\u3007]");
          if (/\n|\r|;/.test(o) || /\/\*/.test(o)) throw Error();
          Function(`
            'use strict'
            const o = new Proxy({}, { get: () => o, set: () => { throw Error() } });
            const \u3007 = null;
            o${o}
            if ([o${o}].length !== 1) throw Error()`)();
        } catch {
          throw Error(r(i));
        }
      });
    };
  }
});
var Yl = b((Hne, Fb) => {
  "use strict";
  Fb.exports = /[^.[\]]+|\[((?:.)*?)\]/g;
});
var zb = b((Bne, Mb) => {
  "use strict";
  var bF = Yl();
  Mb.exports = wF;
  function wF({ paths: e }) {
    let t = [];
    var r = 0;
    let n = e.reduce(function (s, i, o) {
      var a = i.match(bF).map((c) => c.replace(/'|"|`/g, ""));
      let u = i[0] === "[";
      a = a.map((c) => (c[0] === "[" ? c.substr(1, c.length - 2) : c));
      let l = a.indexOf("*");
      if (l > -1) {
        let c = a.slice(0, l),
          f = c.join("."),
          d = a.slice(l + 1, a.length),
          h = d.length > 0;
        r++, t.push({ before: c, beforeStr: f, after: d, nested: h });
      } else
        s[i] = {
          path: a,
          val: void 0,
          precensored: !1,
          circle: "",
          escPath: JSON.stringify(i),
          leadingBracket: u,
        };
      return s;
    }, {});
    return { wildcards: t, wcLen: r, secret: n };
  }
});
var Ub = b((Kne, Vb) => {
  "use strict";
  var EF = Yl();
  Vb.exports = RF;
  function RF(
    { secret: e, serialize: t, wcLen: r, strict: n, isCensorFct: s, censorFctTakesPath: i },
    o,
  ) {
    let a = Function(
      "o",
      `
    if (typeof o !== 'object' || o == null) {
      ${OF(n, t)}
    }
    const { censor, secret } = this
    const originalSecret = {}
    const secretKeys = Object.keys(secret)
    for (var i = 0; i < secretKeys.length; i++) {
      originalSecret[secretKeys[i]] = secret[secretKeys[i]]
    }

    ${TF(e, s, i)}
    this.compileRestore()
    ${PF(r > 0, s, i)}
    this.secret = originalSecret
    ${$F(t)}
  `,
    ).bind(o);
    return (a.state = o), t === !1 && (a.restore = (u) => o.restore(u)), a;
  }
  function TF(e, t, r) {
    return Object.keys(e).map((n) => {
      let { escPath: s, leadingBracket: i, path: o } = e[n],
        a = i ? 1 : 0,
        u = i ? "" : ".",
        l = [];
      for (var c; (c = EF.exec(n)) !== null; ) {
        let [, p] = c,
          { index: y, input: _ } = c;
        y > a && l.push(_.substring(0, y - (p ? 0 : 1)));
      }
      var f = l.map((p) => `o${u}${p}`).join(" && ");
      f.length === 0 ? (f += `o${u}${n} != null`) : (f += ` && o${u}${n} != null`);
      let d = `
      switch (true) {
        ${l.reverse().map(
          (p) => `
          case o${u}${p} === censor:
            secret[${s}].circle = ${JSON.stringify(p)}
            break
        `,
        ).join(`
`)}
      }
    `,
        h = r ? `val, ${JSON.stringify(o)}` : "val";
      return `
      if (${f}) {
        const val = o${u}${n}
        if (val === censor) {
          secret[${s}].precensored = true
        } else {
          secret[${s}].val = val
          o${u}${n} = ${t ? `censor(${h})` : "censor"}
          ${d}
        }
      }
    `;
    }).join(`
`);
  }
  function PF(e, t, r) {
    return e === !0
      ? `
    {
      const { wildcards, wcLen, groupRedact, nestedRedact } = this
      for (var i = 0; i < wcLen; i++) {
        const { before, beforeStr, after, nested } = wildcards[i]
        if (nested === true) {
          secret[beforeStr] = secret[beforeStr] || []
          nestedRedact(secret[beforeStr], o, before, after, censor, ${t}, ${r})
        } else secret[beforeStr] = groupRedact(o, before, censor, ${t}, ${r})
      }
    }
  `
      : "";
  }
  function $F(e) {
    return e === !1
      ? "return o"
      : `
    var s = this.serialize(o)
    this.restore(o)
    return s
  `;
  }
  function OF(e, t) {
    return e === !0
      ? "throw Error('fast-redact: primitives cannot be redacted')"
      : t === !1
        ? "return o"
        : "return this.serialize(o)";
  }
});
var Qh = b((Gne, Kb) => {
  "use strict";
  Kb.exports = { groupRedact: AF, groupRestore: NF, nestedRedact: CF, nestedRestore: IF };
  function NF({ keys: e, values: t, target: r }) {
    if (r == null || typeof r == "string") return;
    let n = e.length;
    for (var s = 0; s < n; s++) {
      let i = e[s];
      r[i] = t[s];
    }
  }
  function AF(e, t, r, n, s) {
    let i = Hb(e, t);
    if (i == null || typeof i == "string") return { keys: null, values: null, target: i, flat: !0 };
    let o = Object.keys(i),
      a = o.length,
      u = t.length,
      l = s ? [...t] : void 0,
      c = new Array(a);
    for (var f = 0; f < a; f++) {
      let d = o[f];
      (c[f] = i[d]), s ? ((l[u] = d), (i[d] = r(i[d], l))) : n ? (i[d] = r(i[d])) : (i[d] = r);
    }
    return { keys: o, values: c, target: i, flat: !0 };
  }
  function IF(e) {
    for (let t = 0; t < e.length; t++) {
      let { target: r, path: n, value: s } = e[t],
        i = r;
      for (let o = n.length - 1; o > 0; o--) i = i[n[o]];
      i[n[0]] = s;
    }
  }
  function CF(e, t, r, n, s, i, o) {
    let a = Hb(t, r);
    if (a == null) return;
    let u = Object.keys(a),
      l = u.length;
    for (var c = 0; c < l; c++) {
      let f = u[c];
      kF(e, a, f, r, n, s, i, o);
    }
    return e;
  }
  function Jh(e, t) {
    return e != null
      ? "hasOwn" in Object
        ? Object.hasOwn(e, t)
        : Object.prototype.hasOwnProperty.call(e, t)
      : !1;
  }
  function kF(e, t, r, n, s, i, o, a) {
    let u = s.length,
      l = u - 1,
      c = r;
    var f = -1,
      d,
      h,
      p,
      y = null,
      _ = null,
      S,
      E,
      g = !1,
      m = 0,
      T = 0,
      N = DF();
    if (((p = d = t[r]), typeof d == "object")) {
      for (
        ;
        d != null &&
        ++f < u &&
        ((T += 1), (r = s[f]), (y = p), !(r !== "*" && !_ && !(typeof d == "object" && r in d)));

      )
        if (!(r === "*" && (_ === "*" && (g = !0), (_ = r), f !== l))) {
          if (_) {
            let $ = Object.keys(d);
            for (var w = 0; w < $.length; w++) {
              let D = $[w];
              if (((E = d[D]), (S = r === "*"), g))
                (N = rs(N, D, T)),
                  (m = f),
                  (p = Bb(E, m - 1, r, n, s, i, o, a, c, d, h, p, S, D, f, l, N, e, t[c], T + 1));
              else if (S || (typeof E == "object" && E !== null && r in E)) {
                if (
                  (S ? (p = E) : (p = E[r]),
                  (h = f !== l ? p : o ? (a ? i(p, [...n, c, ...s]) : i(p)) : i),
                  S)
                ) {
                  let v = Sa(rs(N, D, T), p, t[c]);
                  e.push(v), (d[D] = h);
                } else if (E[r] !== h)
                  if ((h === void 0 && i !== void 0) || (Jh(E, r) && h === p)) N = rs(N, D, T);
                  else {
                    N = rs(N, D, T);
                    let v = Sa(rs(N, r, T + 1), p, t[c]);
                    e.push(v), (E[r] = h);
                  }
              }
            }
            _ = null;
          } else {
            if (
              ((p = d[r]),
              (N = rs(N, r, T)),
              (h = f !== l ? p : o ? (a ? i(p, [...n, c, ...s]) : i(p)) : i),
              !((Jh(d, r) && h === p) || (h === void 0 && i !== void 0)))
            ) {
              let $ = Sa(N, p, t[c]);
              e.push($), (d[r] = h);
            }
            d = d[r];
          }
          if (typeof d != "object") break;
        }
    }
  }
  function Hb(e, t) {
    for (var r = -1, n = t.length, s = e; s != null && ++r < n; ) s = s[t[r]];
    return s;
  }
  function Bb(e, t, r, n, s, i, o, a, u, l, c, f, d, h, p, y, _, S, E, g) {
    if (t === 0 && (d || (typeof e == "object" && e !== null && r in e))) {
      if (
        (d ? (f = e) : (f = e[r]),
        (c = p !== y ? f : o ? (a ? i(f, [...n, u, ...s]) : i(f)) : i),
        d)
      ) {
        let m = Sa(_, f, E);
        S.push(m), (l[h] = c);
      } else if (e[r] !== c) {
        if (!((c === void 0 && i !== void 0) || (Jh(e, r) && c === f))) {
          let m = Sa(rs(_, r, g + 1), f, E);
          S.push(m), (e[r] = c);
        }
      }
    }
    for (let m in e)
      typeof e[m] == "object" &&
        ((_ = rs(_, m, g)),
        Bb(e[m], t - 1, r, n, s, i, o, a, u, l, c, f, d, h, p, y, _, S, E, g + 1));
  }
  function DF() {
    return { parent: null, key: null, children: [], depth: 0 };
  }
  function rs(e, t, r) {
    if (e.depth === r) return rs(e.parent, t, r);
    var n = { parent: e, key: t, depth: r, children: [] };
    return e.children.push(n), n;
  }
  function Sa(e, t, r) {
    let n = e,
      s = [];
    do s.push(n.key), (n = n.parent);
    while (n.parent != null);
    return { path: s, value: t, target: r };
  }
});
var Jb = b((Jne, Gb) => {
  "use strict";
  var { groupRestore: qF, nestedRestore: jF } = Qh();
  Gb.exports = LF;
  function LF() {
    return function () {
      if (this.restore) {
        this.restore.state.secret = this.secret;
        return;
      }
      let { secret: t, wcLen: r } = this,
        n = Object.keys(t),
        s = xF(t, n),
        i = r > 0,
        o = i ? { secret: t, groupRestore: qF, nestedRestore: jF } : { secret: t };
      (this.restore = Function("o", FF(s, n, i)).bind(o)), (this.restore.state = o);
    };
  }
  function xF(e, t) {
    return t
      .map((r) => {
        let { circle: n, escPath: s, leadingBracket: i } = e[r],
          a = n ? `o.${n} = secret[${s}].val` : `o${i ? "" : "."}${r} = secret[${s}].val`,
          u = `secret[${s}].val = undefined`;
        return `
      if (secret[${s}].val !== undefined) {
        try { ${a} } catch (e) {}
        ${u}
      }
    `;
      })
      .join("");
  }
  function FF(e, t, r) {
    return `
    const secret = this.secret
    ${
      r === !0
        ? `
    const keys = Object.keys(secret)
    const len = keys.length
    for (var i = len - 1; i >= ${t.length}; i--) {
      const k = keys[i]
      const o = secret[k]
      if (o) {
        if (o.flat === true) this.groupRestore(o)
        else this.nestedRestore(o)
        secret[k] = null
      }
    }
  `
        : ""
    }
    ${e}
    return o
  `;
  }
});
var Wb = b((Qne, Qb) => {
  "use strict";
  Qb.exports = MF;
  function MF(e) {
    let {
        secret: t,
        censor: r,
        compileRestore: n,
        serialize: s,
        groupRedact: i,
        nestedRedact: o,
        wildcards: a,
        wcLen: u,
      } = e,
      l = [{ secret: t, censor: r, compileRestore: n }];
    return (
      s !== !1 && l.push({ serialize: s }),
      u > 0 && l.push({ groupRedact: i, nestedRedact: o, wildcards: a, wcLen: u }),
      Object.assign(...l)
    );
  }
});
var Zb = b((Wne, Xb) => {
  "use strict";
  var Yb = xb(),
    zF = zb(),
    VF = Ub(),
    UF = Jb(),
    { groupRedact: HF, nestedRedact: BF } = Qh(),
    KF = Wb(),
    GF = Yl(),
    JF = Yb(),
    Wh = (e) => e;
  Wh.restore = Wh;
  var QF = "[REDACTED]";
  Yh.rx = GF;
  Yh.validator = Yb;
  Xb.exports = Yh;
  function Yh(e = {}) {
    let t = Array.from(new Set(e.paths || [])),
      r =
        "serialize" in e && (e.serialize === !1 || typeof e.serialize == "function")
          ? e.serialize
          : JSON.stringify,
      n = e.remove;
    if (n === !0 && r !== JSON.stringify)
      throw Error(
        "fast-redact \u2013 remove option may only be set when serializer is JSON.stringify",
      );
    let s = n === !0 ? void 0 : "censor" in e ? e.censor : QF,
      i = typeof s == "function",
      o = i && s.length > 1;
    if (t.length === 0) return r || Wh;
    JF({ paths: t, serialize: r, censor: s });
    let { wildcards: a, wcLen: u, secret: l } = zF({ paths: t, censor: s }),
      c = UF(),
      f = "strict" in e ? e.strict : !0;
    return VF(
      { secret: l, wcLen: u, serialize: r, strict: f, isCensorFct: i, censorFctTakesPath: o },
      KF({
        secret: l,
        censor: s,
        compileRestore: c,
        serialize: r,
        groupRedact: HF,
        nestedRedact: BF,
        wildcards: a,
        wcLen: u,
      }),
    );
  }
});
var no = b((Yne, ew) => {
  "use strict";
  var WF = Symbol("pino.setLevel"),
    YF = Symbol("pino.getLevel"),
    XF = Symbol("pino.levelVal"),
    ZF = Symbol("pino.levelComp"),
    e2 = Symbol("pino.useLevelLabels"),
    t2 = Symbol("pino.useOnlyCustomLevels"),
    r2 = Symbol("pino.mixin"),
    n2 = Symbol("pino.lsCache"),
    s2 = Symbol("pino.chindings"),
    i2 = Symbol("pino.asJson"),
    o2 = Symbol("pino.write"),
    a2 = Symbol("pino.redactFmt"),
    u2 = Symbol("pino.time"),
    l2 = Symbol("pino.timeSliceIndex"),
    c2 = Symbol("pino.stream"),
    f2 = Symbol("pino.stringify"),
    d2 = Symbol("pino.stringifySafe"),
    h2 = Symbol("pino.stringifiers"),
    p2 = Symbol("pino.end"),
    m2 = Symbol("pino.formatOpts"),
    y2 = Symbol("pino.messageKey"),
    g2 = Symbol("pino.errorKey"),
    _2 = Symbol("pino.nestedKey"),
    S2 = Symbol("pino.nestedKeyStr"),
    v2 = Symbol("pino.mixinMergeStrategy"),
    b2 = Symbol("pino.msgPrefix"),
    w2 = Symbol("pino.wildcardFirst"),
    E2 = Symbol.for("pino.serializers"),
    R2 = Symbol.for("pino.formatters"),
    T2 = Symbol.for("pino.hooks"),
    P2 = Symbol.for("pino.metadata");
  ew.exports = {
    setLevelSym: WF,
    getLevelSym: YF,
    levelValSym: XF,
    levelCompSym: ZF,
    useLevelLabelsSym: e2,
    mixinSym: r2,
    lsCacheSym: n2,
    chindingsSym: s2,
    asJsonSym: i2,
    writeSym: o2,
    serializersSym: E2,
    redactFmtSym: a2,
    timeSym: u2,
    timeSliceIndexSym: l2,
    streamSym: c2,
    stringifySym: f2,
    stringifySafeSym: d2,
    stringifiersSym: h2,
    endSym: p2,
    formatOptsSym: m2,
    messageKeySym: y2,
    errorKeySym: g2,
    nestedKeySym: _2,
    wildcardFirstSym: w2,
    needsMetadataGsym: P2,
    useOnlyCustomLevelsSym: t2,
    formattersSym: R2,
    hooksSym: T2,
    nestedKeyStrSym: S2,
    mixinMergeStrategySym: v2,
    msgPrefixSym: b2,
  };
});
var ep = b((Xne, sw) => {
  "use strict";
  var Zh = Zb(),
    { redactFmtSym: $2, wildcardFirstSym: Xl } = no(),
    { rx: Xh, validator: O2 } = Zh,
    tw = O2({
      ERR_PATHS_MUST_BE_STRINGS: () => "pino \u2013 redacted paths must be strings",
      ERR_INVALID_PATH: (e) => `pino \u2013 redact paths array contains an invalid path (${e})`,
    }),
    rw = "[Redacted]",
    nw = !1;
  function N2(e, t) {
    let { paths: r, censor: n } = A2(e),
      s = r.reduce((a, u) => {
        Xh.lastIndex = 0;
        let l = Xh.exec(u),
          c = Xh.exec(u),
          f = l[1] !== void 0 ? l[1].replace(/^(?:"|'|`)(.*)(?:"|'|`)$/, "$1") : l[0];
        if ((f === "*" && (f = Xl), c === null)) return (a[f] = null), a;
        if (a[f] === null) return a;
        let { index: d } = c,
          h = `${u.substr(d, u.length - 1)}`;
        return (
          (a[f] = a[f] || []),
          f !== Xl && a[f].length === 0 && a[f].push(...(a[Xl] || [])),
          f === Xl &&
            Object.keys(a).forEach(function (p) {
              a[p] && a[p].push(h);
            }),
          a[f].push(h),
          a
        );
      }, {}),
      i = { [$2]: Zh({ paths: r, censor: n, serialize: t, strict: nw }) },
      o = (...a) => t(typeof n == "function" ? n(...a) : n);
    return [...Object.keys(s), ...Object.getOwnPropertySymbols(s)].reduce((a, u) => {
      if (s[u] === null) a[u] = (l) => o(l, [u]);
      else {
        let l = typeof n == "function" ? (c, f) => n(c, [u, ...f]) : n;
        a[u] = Zh({ paths: s[u], censor: l, serialize: t, strict: nw });
      }
      return a;
    }, i);
  }
  function A2(e) {
    if (Array.isArray(e)) return (e = { paths: e, censor: rw }), tw(e), e;
    let { paths: t, censor: r = rw, remove: n } = e;
    if (Array.isArray(t) === !1) throw Error("pino \u2013 redact must contain an array of strings");
    return n === !0 && (r = void 0), tw({ paths: t, censor: r }), { paths: t, censor: r };
  }
  sw.exports = N2;
});
var ow = b((Zne, iw) => {
  "use strict";
  var I2 = () => "",
    C2 = () => `,"time":${Date.now()}`,
    k2 = () => `,"time":${Math.round(Date.now() / 1e3)}`,
    D2 = () => `,"time":"${new Date(Date.now()).toISOString()}"`;
  iw.exports = { nullTime: I2, epochTime: C2, unixTime: k2, isoTime: D2 };
});
var uw = b((ese, aw) => {
  "use strict";
  function q2(e) {
    try {
      return JSON.stringify(e);
    } catch {
      return '"[Circular]"';
    }
  }
  aw.exports = j2;
  function j2(e, t, r) {
    var n = (r && r.stringify) || q2,
      s = 1;
    if (typeof e == "object" && e !== null) {
      var i = t.length + s;
      if (i === 1) return e;
      var o = new Array(i);
      o[0] = n(e);
      for (var a = 1; a < i; a++) o[a] = n(t[a]);
      return o.join(" ");
    }
    if (typeof e != "string") return e;
    var u = t.length;
    if (u === 0) return e;
    for (var l = "", c = 1 - s, f = -1, d = (e && e.length) || 0, h = 0; h < d; ) {
      if (e.charCodeAt(h) === 37 && h + 1 < d) {
        switch (((f = f > -1 ? f : 0), e.charCodeAt(h + 1))) {
          case 100:
          case 102:
            if (c >= u || t[c] == null) break;
            f < h && (l += e.slice(f, h)), (l += Number(t[c])), (f = h + 2), h++;
            break;
          case 105:
            if (c >= u || t[c] == null) break;
            f < h && (l += e.slice(f, h)), (l += Math.floor(Number(t[c]))), (f = h + 2), h++;
            break;
          case 79:
          case 111:
          case 106:
            if (c >= u || t[c] === void 0) break;
            f < h && (l += e.slice(f, h));
            var p = typeof t[c];
            if (p === "string") {
              (l += "'" + t[c] + "'"), (f = h + 2), h++;
              break;
            }
            if (p === "function") {
              (l += t[c].name || "<anonymous>"), (f = h + 2), h++;
              break;
            }
            (l += n(t[c])), (f = h + 2), h++;
            break;
          case 115:
            if (c >= u) break;
            f < h && (l += e.slice(f, h)), (l += String(t[c])), (f = h + 2), h++;
            break;
          case 37:
            f < h && (l += e.slice(f, h)), (l += "%"), (f = h + 2), h++, c--;
            break;
        }
        ++c;
      }
      ++h;
    }
    return f === -1 ? e : (f < d && (l += e.slice(f)), l);
  }
});
var rp = b((tse, tp) => {
  "use strict";
  if (typeof SharedArrayBuffer < "u" && typeof Atomics < "u") {
    let t = function (r) {
        if ((r > 0 && r < 1 / 0) === !1)
          throw typeof r != "number" && typeof r != "bigint"
            ? TypeError("sleep: ms must be a number")
            : RangeError(
                "sleep: ms must be a number that is greater than 0 but less than Infinity",
              );
        Atomics.wait(e, 0, 0, Number(r));
      },
      e = new Int32Array(new SharedArrayBuffer(4));
    tp.exports = t;
  } else {
    let e = function (t) {
      if ((t > 0 && t < 1 / 0) === !1)
        throw typeof t != "number" && typeof t != "bigint"
          ? TypeError("sleep: ms must be a number")
          : RangeError("sleep: ms must be a number that is greater than 0 but less than Infinity");
      let n = Date.now() + Number(t);
      for (; n > Date.now(); );
    };
    tp.exports = e;
  }
});
var yw = b((rse, mw) => {
  "use strict";
  var It = require("fs"),
    L2 = require("events"),
    x2 = require("util").inherits,
    lw = require("path"),
    sp = rp(),
    Zl = 100,
    ec = Buffer.allocUnsafe(0),
    F2 = 16 * 1024,
    cw = "buffer",
    fw = "utf8";
  function dw(e, t) {
    (t._opening = !0), (t._writing = !0), (t._asyncDrainScheduled = !1);
    function r(i, o) {
      if (i) {
        (t._reopening = !1),
          (t._writing = !1),
          (t._opening = !1),
          t.sync
            ? process.nextTick(() => {
                t.listenerCount("error") > 0 && t.emit("error", i);
              })
            : t.emit("error", i);
        return;
      }
      let a = t._reopening;
      (t.fd = o),
        (t.file = e),
        (t._reopening = !1),
        (t._opening = !1),
        (t._writing = !1),
        t.sync ? process.nextTick(() => t.emit("ready")) : t.emit("ready"),
        !t.destroyed &&
          ((!t._writing && t._len > t.minLength) || t._flushPending
            ? t._actualWrite()
            : a && process.nextTick(() => t.emit("drain")));
    }
    let n = t.append ? "a" : "w",
      s = t.mode;
    if (t.sync)
      try {
        t.mkdir && It.mkdirSync(lw.dirname(e), { recursive: !0 });
        let i = It.openSync(e, n, s);
        r(null, i);
      } catch (i) {
        throw (r(i), i);
      }
    else
      t.mkdir
        ? It.mkdir(lw.dirname(e), { recursive: !0 }, (i) => {
            if (i) return r(i);
            It.open(e, n, s, r);
          })
        : It.open(e, n, s, r);
  }
  function pn(e) {
    if (!(this instanceof pn)) return new pn(e);
    let {
      fd: t,
      dest: r,
      minLength: n,
      maxLength: s,
      maxWrite: i,
      sync: o,
      append: a = !0,
      mkdir: u,
      retryEAGAIN: l,
      fsync: c,
      contentMode: f,
      mode: d,
    } = e || {};
    (t = t || r),
      (this._len = 0),
      (this.fd = -1),
      (this._bufs = []),
      (this._lens = []),
      (this._writing = !1),
      (this._ending = !1),
      (this._reopening = !1),
      (this._asyncDrainScheduled = !1),
      (this._flushPending = !1),
      (this._hwm = Math.max(n || 0, 16387)),
      (this.file = null),
      (this.destroyed = !1),
      (this.minLength = n || 0),
      (this.maxLength = s || 0),
      (this.maxWrite = i || F2),
      (this.sync = o || !1),
      (this.writable = !0),
      (this._fsync = c || !1),
      (this.append = a || !1),
      (this.mode = d),
      (this.retryEAGAIN = l || (() => !0)),
      (this.mkdir = u || !1);
    let h, p;
    if (f === cw)
      (this._writingBuf = ec),
        (this.write = V2),
        (this.flush = H2),
        (this.flushSync = K2),
        (this._actualWrite = J2),
        (h = () => It.writeSync(this.fd, this._writingBuf)),
        (p = () => It.write(this.fd, this._writingBuf, this.release));
    else if (f === void 0 || f === fw)
      (this._writingBuf = ""),
        (this.write = z2),
        (this.flush = U2),
        (this.flushSync = B2),
        (this._actualWrite = G2),
        (h = () => It.writeSync(this.fd, this._writingBuf, "utf8")),
        (p = () => It.write(this.fd, this._writingBuf, "utf8", this.release));
    else throw new Error(`SonicBoom supports "${fw}" and "${cw}", but passed ${f}`);
    if (typeof t == "number") (this.fd = t), process.nextTick(() => this.emit("ready"));
    else if (typeof t == "string") dw(t, this);
    else throw new Error("SonicBoom supports only file descriptors and files");
    if (this.minLength >= this.maxWrite)
      throw new Error(`minLength should be smaller than maxWrite (${this.maxWrite})`);
    (this.release = (y, _) => {
      if (y) {
        if (
          (y.code === "EAGAIN" || y.code === "EBUSY") &&
          this.retryEAGAIN(y, this._writingBuf.length, this._len - this._writingBuf.length)
        )
          if (this.sync)
            try {
              sp(Zl), this.release(void 0, 0);
            } catch (g) {
              this.release(g);
            }
          else setTimeout(p, Zl);
        else (this._writing = !1), this.emit("error", y);
        return;
      }
      this.emit("write", _);
      let S = np(this._writingBuf, this._len, _);
      if (((this._len = S.len), (this._writingBuf = S.writingBuf), this._writingBuf.length)) {
        if (!this.sync) {
          p();
          return;
        }
        try {
          do {
            let g = h(),
              m = np(this._writingBuf, this._len, g);
            (this._len = m.len), (this._writingBuf = m.writingBuf);
          } while (this._writingBuf.length);
        } catch (g) {
          this.release(g);
          return;
        }
      }
      this._fsync && It.fsyncSync(this.fd);
      let E = this._len;
      this._reopening
        ? ((this._writing = !1), (this._reopening = !1), this.reopen())
        : E > this.minLength
          ? this._actualWrite()
          : this._ending
            ? E > 0
              ? this._actualWrite()
              : ((this._writing = !1), tc(this))
            : ((this._writing = !1),
              this.sync
                ? this._asyncDrainScheduled ||
                  ((this._asyncDrainScheduled = !0), process.nextTick(M2, this))
                : this.emit("drain"));
    }),
      this.on("newListener", function (y) {
        y === "drain" && (this._asyncDrainScheduled = !1);
      });
  }
  function np(e, t, r) {
    return (
      typeof e == "string" &&
        Buffer.byteLength(e) !== r &&
        (r = Buffer.from(e).subarray(0, r).toString().length),
      (t = Math.max(t - r, 0)),
      (e = e.slice(r)),
      { writingBuf: e, len: t }
    );
  }
  function M2(e) {
    e.listenerCount("drain") > 0 && ((e._asyncDrainScheduled = !1), e.emit("drain"));
  }
  x2(pn, L2);
  function hw(e, t) {
    return e.length === 0 ? ec : e.length === 1 ? e[0] : Buffer.concat(e, t);
  }
  function z2(e) {
    if (this.destroyed) throw new Error("SonicBoom destroyed");
    let t = this._len + e.length,
      r = this._bufs;
    return this.maxLength && t > this.maxLength
      ? (this.emit("drop", e), this._len < this._hwm)
      : (r.length === 0 || r[r.length - 1].length + e.length > this.maxWrite
          ? r.push("" + e)
          : (r[r.length - 1] += e),
        (this._len = t),
        !this._writing && this._len >= this.minLength && this._actualWrite(),
        this._len < this._hwm);
  }
  function V2(e) {
    if (this.destroyed) throw new Error("SonicBoom destroyed");
    let t = this._len + e.length,
      r = this._bufs,
      n = this._lens;
    return this.maxLength && t > this.maxLength
      ? (this.emit("drop", e), this._len < this._hwm)
      : (r.length === 0 || n[n.length - 1] + e.length > this.maxWrite
          ? (r.push([e]), n.push(e.length))
          : (r[r.length - 1].push(e), (n[n.length - 1] += e.length)),
        (this._len = t),
        !this._writing && this._len >= this.minLength && this._actualWrite(),
        this._len < this._hwm);
  }
  function pw(e) {
    this._flushPending = !0;
    let t = () => {
        this._fsync
          ? ((this._flushPending = !1), e())
          : It.fsync(this.fd, (n) => {
              (this._flushPending = !1), e(n);
            }),
          this.off("error", r);
      },
      r = (n) => {
        (this._flushPending = !1), e(n), this.off("drain", t);
      };
    this.once("drain", t), this.once("error", r);
  }
  function U2(e) {
    if (e != null && typeof e != "function") throw new Error("flush cb must be a function");
    if (this.destroyed) {
      let t = new Error("SonicBoom destroyed");
      if (e) {
        e(t);
        return;
      }
      throw t;
    }
    if (this.minLength <= 0) {
      e?.();
      return;
    }
    e && pw.call(this, e),
      !this._writing && (this._bufs.length === 0 && this._bufs.push(""), this._actualWrite());
  }
  function H2(e) {
    if (e != null && typeof e != "function") throw new Error("flush cb must be a function");
    if (this.destroyed) {
      let t = new Error("SonicBoom destroyed");
      if (e) {
        e(t);
        return;
      }
      throw t;
    }
    if (this.minLength <= 0) {
      e?.();
      return;
    }
    e && pw.call(this, e),
      !this._writing &&
        (this._bufs.length === 0 && (this._bufs.push([]), this._lens.push(0)), this._actualWrite());
  }
  pn.prototype.reopen = function (e) {
    if (this.destroyed) throw new Error("SonicBoom destroyed");
    if (this._opening) {
      this.once("ready", () => {
        this.reopen(e);
      });
      return;
    }
    if (this._ending) return;
    if (!this.file)
      throw new Error("Unable to reopen a file descriptor, you must pass a file to SonicBoom");
    if ((e && (this.file = e), (this._reopening = !0), this._writing)) return;
    let t = this.fd;
    this.once("ready", () => {
      t !== this.fd &&
        It.close(t, (r) => {
          if (r) return this.emit("error", r);
        });
    }),
      dw(this.file, this);
  };
  pn.prototype.end = function () {
    if (this.destroyed) throw new Error("SonicBoom destroyed");
    if (this._opening) {
      this.once("ready", () => {
        this.end();
      });
      return;
    }
    this._ending ||
      ((this._ending = !0),
      !this._writing && (this._len > 0 && this.fd >= 0 ? this._actualWrite() : tc(this)));
  };
  function B2() {
    if (this.destroyed) throw new Error("SonicBoom destroyed");
    if (this.fd < 0) throw new Error("sonic boom is not ready yet");
    !this._writing &&
      this._writingBuf.length > 0 &&
      (this._bufs.unshift(this._writingBuf), (this._writingBuf = ""));
    let e = "";
    for (; this._bufs.length || e; ) {
      e.length <= 0 && (e = this._bufs[0]);
      try {
        let t = It.writeSync(this.fd, e, "utf8"),
          r = np(e, this._len, t);
        (e = r.writingBuf), (this._len = r.len), e.length <= 0 && this._bufs.shift();
      } catch (t) {
        if (
          (t.code === "EAGAIN" || t.code === "EBUSY") &&
          !this.retryEAGAIN(t, e.length, this._len - e.length)
        )
          throw t;
        sp(Zl);
      }
    }
    try {
      It.fsyncSync(this.fd);
    } catch {}
  }
  function K2() {
    if (this.destroyed) throw new Error("SonicBoom destroyed");
    if (this.fd < 0) throw new Error("sonic boom is not ready yet");
    !this._writing &&
      this._writingBuf.length > 0 &&
      (this._bufs.unshift([this._writingBuf]), (this._writingBuf = ec));
    let e = ec;
    for (; this._bufs.length || e.length; ) {
      e.length <= 0 && (e = hw(this._bufs[0], this._lens[0]));
      try {
        let t = It.writeSync(this.fd, e);
        (e = e.subarray(t)),
          (this._len = Math.max(this._len - t, 0)),
          e.length <= 0 && (this._bufs.shift(), this._lens.shift());
      } catch (t) {
        if (
          (t.code === "EAGAIN" || t.code === "EBUSY") &&
          !this.retryEAGAIN(t, e.length, this._len - e.length)
        )
          throw t;
        sp(Zl);
      }
    }
  }
  pn.prototype.destroy = function () {
    this.destroyed || tc(this);
  };
  function G2() {
    let e = this.release;
    if (
      ((this._writing = !0),
      (this._writingBuf = this._writingBuf || this._bufs.shift() || ""),
      this.sync)
    )
      try {
        let t = It.writeSync(this.fd, this._writingBuf, "utf8");
        e(null, t);
      } catch (t) {
        e(t);
      }
    else It.write(this.fd, this._writingBuf, "utf8", e);
  }
  function J2() {
    let e = this.release;
    if (
      ((this._writing = !0),
      (this._writingBuf = this._writingBuf.length
        ? this._writingBuf
        : hw(this._bufs.shift(), this._lens.shift())),
      this.sync)
    )
      try {
        let t = It.writeSync(this.fd, this._writingBuf);
        e(null, t);
      } catch (t) {
        e(t);
      }
    else It.write(this.fd, this._writingBuf, e);
  }
  function tc(e) {
    if (e.fd === -1) {
      e.once("ready", tc.bind(null, e));
      return;
    }
    (e.destroyed = !0), (e._bufs = []), (e._lens = []), It.fsync(e.fd, t);
    function t() {
      e.fd !== 1 && e.fd !== 2 ? It.close(e.fd, r) : r();
    }
    function r(n) {
      if (n) {
        e.emit("error", n);
        return;
      }
      e._ending && !e._writing && e.emit("finish"), e.emit("close");
    }
  }
  pn.SonicBoom = pn;
  pn.default = pn;
  mw.exports = pn;
});
var ip = b((nse, bw) => {
  "use strict";
  var mn = { exit: [], beforeExit: [] },
    gw = { exit: Y2, beforeExit: X2 },
    so;
  function Q2() {
    so === void 0 && (so = new FinalizationRegistry(Z2));
  }
  function W2(e) {
    mn[e].length > 0 || process.on(e, gw[e]);
  }
  function _w(e) {
    mn[e].length > 0 ||
      (process.removeListener(e, gw[e]),
      mn.exit.length === 0 && mn.beforeExit.length === 0 && (so = void 0));
  }
  function Y2() {
    Sw("exit");
  }
  function X2() {
    Sw("beforeExit");
  }
  function Sw(e) {
    for (let t of mn[e]) {
      let r = t.deref(),
        n = t.fn;
      r !== void 0 && n(r, e);
    }
    mn[e] = [];
  }
  function Z2(e) {
    for (let t of ["exit", "beforeExit"]) {
      let r = mn[t].indexOf(e);
      mn[t].splice(r, r + 1), _w(t);
    }
  }
  function vw(e, t, r) {
    if (t === void 0) throw new Error("the object can't be undefined");
    W2(e);
    let n = new WeakRef(t);
    (n.fn = r), Q2(), so.register(t, n), mn[e].push(n);
  }
  function eM(e, t) {
    vw("exit", e, t);
  }
  function tM(e, t) {
    vw("beforeExit", e, t);
  }
  function rM(e) {
    if (so !== void 0) {
      so.unregister(e);
      for (let t of ["exit", "beforeExit"])
        (mn[t] = mn[t].filter((r) => {
          let n = r.deref();
          return n && n !== e;
        })),
          _w(t);
    }
  }
  bw.exports = { register: eM, registerBeforeExit: tM, unregister: rM };
});
var ww = b((sse, nM) => {
  nM.exports = {
    name: "thread-stream",
    version: "3.1.0",
    description: "A streaming way to send data to a Node.js Worker Thread",
    main: "index.js",
    types: "index.d.ts",
    dependencies: { "real-require": "^0.2.0" },
    devDependencies: {
      "@types/node": "^20.1.0",
      "@types/tap": "^15.0.0",
      "@yao-pkg/pkg": "^5.11.5",
      desm: "^1.3.0",
      fastbench: "^1.0.1",
      husky: "^9.0.6",
      "pino-elasticsearch": "^8.0.0",
      "sonic-boom": "^4.0.1",
      standard: "^17.0.0",
      tap: "^16.2.0",
      "ts-node": "^10.8.0",
      typescript: "^5.3.2",
      "why-is-node-running": "^2.2.2",
    },
    scripts: {
      build: "tsc --noEmit",
      test: 'standard && npm run build && npm run transpile && tap "test/**/*.test.*js" && tap --ts test/*.test.*ts',
      "test:ci": "standard && npm run transpile && npm run test:ci:js && npm run test:ci:ts",
      "test:ci:js":
        'tap --no-check-coverage --timeout=120 --coverage-report=lcovonly "test/**/*.test.*js"',
      "test:ci:ts": 'tap --ts --no-check-coverage --coverage-report=lcovonly "test/**/*.test.*ts"',
      "test:yarn": 'npm run transpile && tap "test/**/*.test.js" --no-check-coverage',
      transpile: "sh ./test/ts/transpile.sh",
      prepare: "husky install",
    },
    standard: { ignore: ["test/ts/**/*", "test/syntax-error.mjs"] },
    repository: { type: "git", url: "git+https://github.com/mcollina/thread-stream.git" },
    keywords: ["worker", "thread", "threads", "stream"],
    author: "Matteo Collina <hello@matteocollina.com>",
    license: "MIT",
    bugs: { url: "https://github.com/mcollina/thread-stream/issues" },
    homepage: "https://github.com/mcollina/thread-stream#readme",
  };
});
var Rw = b((ise, Ew) => {
  "use strict";
  function sM(e, t, r, n, s) {
    let i = Date.now() + n,
      o = Atomics.load(e, t);
    if (o === r) {
      s(null, "ok");
      return;
    }
    let a = o,
      u = (l) => {
        Date.now() > i
          ? s(null, "timed-out")
          : setTimeout(() => {
              (a = o),
                (o = Atomics.load(e, t)),
                o === a
                  ? u(l >= 1e3 ? 1e3 : l * 2)
                  : o === r
                    ? s(null, "ok")
                    : s(null, "not-equal");
            }, l);
      };
    u(1);
  }
  function iM(e, t, r, n, s) {
    let i = Date.now() + n,
      o = Atomics.load(e, t);
    if (o !== r) {
      s(null, "ok");
      return;
    }
    let a = (u) => {
      Date.now() > i
        ? s(null, "timed-out")
        : setTimeout(() => {
            (o = Atomics.load(e, t)), o !== r ? s(null, "ok") : a(u >= 1e3 ? 1e3 : u * 2);
          }, u);
    };
    a(1);
  }
  Ew.exports = { wait: sM, waitDiff: iM };
});
var Pw = b((ose, Tw) => {
  "use strict";
  Tw.exports = { WRITE_INDEX: 4, READ_INDEX: 8 };
});
var Iw = b((ase, Aw) => {
  "use strict";
  var { version: oM } = ww(),
    { EventEmitter: aM } = require("events"),
    { Worker: uM } = require("worker_threads"),
    { join: lM } = require("path"),
    { pathToFileURL: cM } = require("url"),
    { wait: fM } = Rw(),
    { WRITE_INDEX: $r, READ_INDEX: An } = Pw(),
    dM = require("buffer"),
    hM = require("assert"),
    B = Symbol("kImpl"),
    pM = dM.constants.MAX_STRING_LENGTH,
    va = class {
      constructor(t) {
        this._value = t;
      }
      deref() {
        return this._value;
      }
    },
    nc = class {
      register() {}
      unregister() {}
    },
    mM = process.env.NODE_V8_COVERAGE ? nc : global.FinalizationRegistry || nc,
    yM = process.env.NODE_V8_COVERAGE ? va : global.WeakRef || va,
    $w = new mM((e) => {
      e.exited || e.terminate();
    });
  function gM(e, t) {
    let { filename: r, workerData: n } = t,
      i =
        ("__bundlerPathsOverrides" in globalThis ? globalThis.__bundlerPathsOverrides : {})[
          "thread-stream-worker"
        ] || lM(__dirname, "lib", "worker.js"),
      o = new uM(i, {
        ...t.workerOpts,
        trackUnmanagedFds: !1,
        workerData: {
          filename: r.indexOf("file://") === 0 ? r : cM(r).href,
          dataBuf: e[B].dataBuf,
          stateBuf: e[B].stateBuf,
          workerData: { $context: { threadStreamVersion: oM }, ...n },
        },
      });
    return (o.stream = new va(e)), o.on("message", _M), o.on("exit", Nw), $w.register(e, o), o;
  }
  function Ow(e) {
    hM(!e[B].sync), e[B].needDrain && ((e[B].needDrain = !1), e.emit("drain"));
  }
  function rc(e) {
    let t = Atomics.load(e[B].state, $r),
      r = e[B].data.length - t;
    if (r > 0) {
      if (e[B].buf.length === 0) {
        (e[B].flushing = !1), e[B].ending ? cp(e) : e[B].needDrain && process.nextTick(Ow, e);
        return;
      }
      let n = e[B].buf.slice(0, r),
        s = Buffer.byteLength(n);
      s <= r
        ? ((e[B].buf = e[B].buf.slice(r)), sc(e, n, rc.bind(null, e)))
        : e.flush(() => {
            if (!e.destroyed) {
              for (
                Atomics.store(e[B].state, An, 0), Atomics.store(e[B].state, $r, 0);
                s > e[B].data.length;

              )
                (r = r / 2), (n = e[B].buf.slice(0, r)), (s = Buffer.byteLength(n));
              (e[B].buf = e[B].buf.slice(r)), sc(e, n, rc.bind(null, e));
            }
          });
    } else if (r === 0) {
      if (t === 0 && e[B].buf.length === 0) return;
      e.flush(() => {
        Atomics.store(e[B].state, An, 0), Atomics.store(e[B].state, $r, 0), rc(e);
      });
    } else In(e, new Error("overwritten"));
  }
  function _M(e) {
    let t = this.stream.deref();
    if (t === void 0) {
      (this.exited = !0), this.terminate();
      return;
    }
    switch (e.code) {
      case "READY":
        (this.stream = new yM(t)),
          t.flush(() => {
            (t[B].ready = !0), t.emit("ready");
          });
        break;
      case "ERROR":
        In(t, e.err);
        break;
      case "EVENT":
        Array.isArray(e.args) ? t.emit(e.name, ...e.args) : t.emit(e.name, e.args);
        break;
      case "WARNING":
        process.emitWarning(e.err);
        break;
      default:
        In(t, new Error("this should not happen: " + e.code));
    }
  }
  function Nw(e) {
    let t = this.stream.deref();
    t !== void 0 &&
      ($w.unregister(t),
      (t.worker.exited = !0),
      t.worker.off("exit", Nw),
      In(t, e !== 0 ? new Error("the worker thread exited") : null));
  }
  var ap = class extends aM {
    constructor(t = {}) {
      if ((super(), t.bufferSize < 4))
        throw new Error("bufferSize must at least fit a 4-byte utf-8 char");
      (this[B] = {}),
        (this[B].stateBuf = new SharedArrayBuffer(128)),
        (this[B].state = new Int32Array(this[B].stateBuf)),
        (this[B].dataBuf = new SharedArrayBuffer(t.bufferSize || 4 * 1024 * 1024)),
        (this[B].data = Buffer.from(this[B].dataBuf)),
        (this[B].sync = t.sync || !1),
        (this[B].ending = !1),
        (this[B].ended = !1),
        (this[B].needDrain = !1),
        (this[B].destroyed = !1),
        (this[B].flushing = !1),
        (this[B].ready = !1),
        (this[B].finished = !1),
        (this[B].errored = null),
        (this[B].closed = !1),
        (this[B].buf = ""),
        (this.worker = gM(this, t)),
        this.on("message", (r, n) => {
          this.worker.postMessage(r, n);
        });
    }
    write(t) {
      if (this[B].destroyed) return up(this, new Error("the worker has exited")), !1;
      if (this[B].ending) return up(this, new Error("the worker is ending")), !1;
      if (this[B].flushing && this[B].buf.length + t.length >= pM)
        try {
          op(this), (this[B].flushing = !0);
        } catch (r) {
          return In(this, r), !1;
        }
      if (((this[B].buf += t), this[B].sync))
        try {
          return op(this), !0;
        } catch (r) {
          return In(this, r), !1;
        }
      return (
        this[B].flushing || ((this[B].flushing = !0), setImmediate(rc, this)),
        (this[B].needDrain =
          this[B].data.length - this[B].buf.length - Atomics.load(this[B].state, $r) <= 0),
        !this[B].needDrain
      );
    }
    end() {
      this[B].destroyed || ((this[B].ending = !0), cp(this));
    }
    flush(t) {
      if (this[B].destroyed) {
        typeof t == "function" && process.nextTick(t, new Error("the worker has exited"));
        return;
      }
      let r = Atomics.load(this[B].state, $r);
      fM(this[B].state, An, r, 1 / 0, (n, s) => {
        if (n) {
          In(this, n), process.nextTick(t, n);
          return;
        }
        if (s === "not-equal") {
          this.flush(t);
          return;
        }
        process.nextTick(t);
      });
    }
    flushSync() {
      this[B].destroyed || (op(this), lp(this));
    }
    unref() {
      this.worker.unref();
    }
    ref() {
      this.worker.ref();
    }
    get ready() {
      return this[B].ready;
    }
    get destroyed() {
      return this[B].destroyed;
    }
    get closed() {
      return this[B].closed;
    }
    get writable() {
      return !this[B].destroyed && !this[B].ending;
    }
    get writableEnded() {
      return this[B].ending;
    }
    get writableFinished() {
      return this[B].finished;
    }
    get writableNeedDrain() {
      return this[B].needDrain;
    }
    get writableObjectMode() {
      return !1;
    }
    get writableErrored() {
      return this[B].errored;
    }
  };
  function up(e, t) {
    setImmediate(() => {
      e.emit("error", t);
    });
  }
  function In(e, t) {
    e[B].destroyed ||
      ((e[B].destroyed = !0),
      t && ((e[B].errored = t), up(e, t)),
      e.worker.exited
        ? setImmediate(() => {
            (e[B].closed = !0), e.emit("close");
          })
        : e.worker
            .terminate()
            .catch(() => {})
            .then(() => {
              (e[B].closed = !0), e.emit("close");
            }));
  }
  function sc(e, t, r) {
    let n = Atomics.load(e[B].state, $r),
      s = Buffer.byteLength(t);
    return (
      e[B].data.write(t, n),
      Atomics.store(e[B].state, $r, n + s),
      Atomics.notify(e[B].state, $r),
      r(),
      !0
    );
  }
  function cp(e) {
    if (!(e[B].ended || !e[B].ending || e[B].flushing)) {
      e[B].ended = !0;
      try {
        e.flushSync();
        let t = Atomics.load(e[B].state, An);
        Atomics.store(e[B].state, $r, -1), Atomics.notify(e[B].state, $r);
        let r = 0;
        for (; t !== -1; ) {
          if (
            (Atomics.wait(e[B].state, An, t, 1e3), (t = Atomics.load(e[B].state, An)), t === -2)
          ) {
            In(e, new Error("end() failed"));
            return;
          }
          if (++r === 10) {
            In(e, new Error("end() took too long (10s)"));
            return;
          }
        }
        process.nextTick(() => {
          (e[B].finished = !0), e.emit("finish");
        });
      } catch (t) {
        In(e, t);
      }
    }
  }
  function op(e) {
    let t = () => {
      e[B].ending ? cp(e) : e[B].needDrain && process.nextTick(Ow, e);
    };
    for (e[B].flushing = !1; e[B].buf.length !== 0; ) {
      let r = Atomics.load(e[B].state, $r),
        n = e[B].data.length - r;
      if (n === 0) {
        lp(e), Atomics.store(e[B].state, An, 0), Atomics.store(e[B].state, $r, 0);
        continue;
      } else if (n < 0) throw new Error("overwritten");
      let s = e[B].buf.slice(0, n),
        i = Buffer.byteLength(s);
      if (i <= n) (e[B].buf = e[B].buf.slice(n)), sc(e, s, t);
      else {
        for (
          lp(e), Atomics.store(e[B].state, An, 0), Atomics.store(e[B].state, $r, 0);
          i > e[B].buf.length;

        )
          (n = n / 2), (s = e[B].buf.slice(0, n)), (i = Buffer.byteLength(s));
        (e[B].buf = e[B].buf.slice(n)), sc(e, s, t);
      }
    }
  }
  function lp(e) {
    if (e[B].flushing) throw new Error("unable to flush while flushing");
    let t = Atomics.load(e[B].state, $r),
      r = 0;
    for (;;) {
      let n = Atomics.load(e[B].state, An);
      if (n === -2) throw Error("_flushSync failed");
      if (n !== t) Atomics.wait(e[B].state, An, n, 1e3);
      else break;
      if (++r === 10) throw new Error("_flushSync took too long (10s)");
    }
  }
  Aw.exports = ap;
});
var hp = b((use, Cw) => {
  "use strict";
  var { createRequire: SM } = require("module"),
    vM = Gh(),
    { join: fp, isAbsolute: bM, sep: wM } = require("path"),
    EM = rp(),
    dp = ip(),
    RM = Iw();
  function TM(e) {
    dp.register(e, $M),
      dp.registerBeforeExit(e, OM),
      e.on("close", function () {
        dp.unregister(e);
      });
  }
  function PM(e, t, r) {
    let n = new RM({ filename: e, workerData: t, workerOpts: r });
    n.on("ready", s),
      n.on("close", function () {
        process.removeListener("exit", i);
      }),
      process.on("exit", i);
    function s() {
      process.removeListener("exit", i), n.unref(), r.autoEnd !== !1 && TM(n);
    }
    function i() {
      n.closed || (n.flushSync(), EM(100), n.end());
    }
    return n;
  }
  function $M(e) {
    e.ref(),
      e.flushSync(),
      e.end(),
      e.once("close", function () {
        e.unref();
      });
  }
  function OM(e) {
    e.flushSync();
  }
  function NM(e) {
    let { pipeline: t, targets: r, levels: n, dedupe: s, worker: i = {}, caller: o = vM() } = e,
      a = { ...e.options },
      u = typeof o == "string" ? [o] : o,
      l = "__bundlerPathsOverrides" in globalThis ? globalThis.__bundlerPathsOverrides : {},
      c = e.target;
    if (c && r) throw new Error("only one of target or targets can be specified");
    return (
      r
        ? ((c = l["pino-worker"] || fp(__dirname, "worker.js")),
          (a.targets = r.filter((d) => d.target).map((d) => ({ ...d, target: f(d.target) }))),
          (a.pipelines = r
            .filter((d) => d.pipeline)
            .map((d) => d.pipeline.map((h) => ({ ...h, level: d.level, target: f(h.target) })))))
        : t &&
          ((c = l["pino-worker"] || fp(__dirname, "worker.js")),
          (a.pipelines = [t.map((d) => ({ ...d, target: f(d.target) }))])),
      n && (a.levels = n),
      s && (a.dedupe = s),
      (a.pinoWillSendConfig = !0),
      PM(f(c), a, i)
    );
    function f(d) {
      if (((d = l[d] || d), bM(d) || d.indexOf("file://") === 0)) return d;
      if (d === "pino/file") return fp(__dirname, "..", "file.js");
      let h;
      for (let p of u)
        try {
          let y = p === "node:repl" ? process.cwd() + wM : p;
          h = SM(y).resolve(d);
          break;
        } catch {
          continue;
        }
      if (!h) throw new Error(`unable to determine transport target for "${d}"`);
      return h;
    }
  }
  Cw.exports = NM;
});
var ac = b((lse, Uw) => {
  "use strict";
  var kw = uw(),
    { mapHttpRequest: AM, mapHttpResponse: IM } = Kh(),
    mp = yw(),
    Dw = ip(),
    {
      lsCacheSym: CM,
      chindingsSym: Lw,
      writeSym: qw,
      serializersSym: xw,
      formatOptsSym: jw,
      endSym: kM,
      stringifiersSym: Fw,
      stringifySym: Mw,
      stringifySafeSym: yp,
      wildcardFirstSym: zw,
      nestedKeySym: DM,
      formattersSym: Vw,
      messageKeySym: qM,
      errorKeySym: jM,
      nestedKeyStrSym: LM,
      msgPrefixSym: ic,
    } = no(),
    { isMainThread: xM } = require("worker_threads"),
    FM = hp();
  function io() {}
  function MM(e, t) {
    if (!t) return r;
    return function (...s) {
      t.call(this, s, r, e);
    };
    function r(n, ...s) {
      if (typeof n == "object") {
        let i = n;
        n !== null &&
          (n.method && n.headers && n.socket
            ? (n = AM(n))
            : typeof n.setHeader == "function" && (n = IM(n)));
        let o;
        i === null && s.length === 0 ? (o = [null]) : ((i = s.shift()), (o = s)),
          typeof this[ic] == "string" && i !== void 0 && i !== null && (i = this[ic] + i),
          this[qw](n, kw(i, o, this[jw]), e);
      } else {
        let i = n === void 0 ? s.shift() : n;
        typeof this[ic] == "string" && i !== void 0 && i !== null && (i = this[ic] + i),
          this[qw](null, kw(i, s, this[jw]), e);
      }
    }
  }
  function pp(e) {
    let t = "",
      r = 0,
      n = !1,
      s = 255,
      i = e.length;
    if (i > 100) return JSON.stringify(e);
    for (var o = 0; o < i && s >= 32; o++)
      (s = e.charCodeAt(o)),
        (s === 34 || s === 92) && ((t += e.slice(r, o) + "\\"), (r = o), (n = !0));
    return n ? (t += e.slice(r)) : (t = e), s < 32 ? JSON.stringify(e) : '"' + t + '"';
  }
  function zM(e, t, r, n) {
    let s = this[Mw],
      i = this[yp],
      o = this[Fw],
      a = this[kM],
      u = this[Lw],
      l = this[xw],
      c = this[Vw],
      f = this[qM],
      d = this[jM],
      h = this[CM][r] + n;
    h = h + u;
    let p;
    c.log && (e = c.log(e));
    let y = o[zw],
      _ = "";
    for (let E in e)
      if (((p = e[E]), Object.prototype.hasOwnProperty.call(e, E) && p !== void 0)) {
        l[E] ? (p = l[E](p)) : E === d && l.err && (p = l.err(p));
        let g = o[E] || y;
        switch (typeof p) {
          case "undefined":
          case "function":
            continue;
          case "number":
            Number.isFinite(p) === !1 && (p = null);
          case "boolean":
            g && (p = g(p));
            break;
          case "string":
            p = (g || pp)(p);
            break;
          default:
            p = (g || s)(p, i);
        }
        if (p === void 0) continue;
        let m = pp(E);
        _ += "," + m + ":" + p;
      }
    let S = "";
    if (t !== void 0) {
      p = l[f] ? l[f](t) : t;
      let E = o[f] || y;
      switch (typeof p) {
        case "function":
          break;
        case "number":
          Number.isFinite(p) === !1 && (p = null);
        case "boolean":
          E && (p = E(p)), (S = ',"' + f + '":' + p);
          break;
        case "string":
          (p = (E || pp)(p)), (S = ',"' + f + '":' + p);
          break;
        default:
          (p = (E || s)(p, i)), (S = ',"' + f + '":' + p);
      }
    }
    return this[DM] && _ ? h + this[LM] + _.slice(1) + "}" + S + a : h + _ + S + a;
  }
  function VM(e, t) {
    let r,
      n = e[Lw],
      s = e[Mw],
      i = e[yp],
      o = e[Fw],
      a = o[zw],
      u = e[xw],
      l = e[Vw].bindings;
    t = l(t);
    for (let c in t)
      if (
        ((r = t[c]),
        (c !== "level" &&
          c !== "serializers" &&
          c !== "formatters" &&
          c !== "customLevels" &&
          t.hasOwnProperty(c) &&
          r !== void 0) === !0)
      ) {
        if (((r = u[c] ? u[c](r) : r), (r = (o[c] || a || s)(r, i)), r === void 0)) continue;
        n += ',"' + c + '":' + r;
      }
    return n;
  }
  function UM(e) {
    return e.write !== e.constructor.prototype.write;
  }
  var HM = process.env.NODE_V8_COVERAGE || process.env.V8_COVERAGE;
  function oc(e) {
    let t = new mp(e);
    return (
      t.on("error", r),
      !HM &&
        !e.sync &&
        xM &&
        (Dw.register(t, BM),
        t.on("close", function () {
          Dw.unregister(t);
        })),
      t
    );
    function r(n) {
      if (n.code === "EPIPE") {
        (t.write = io), (t.end = io), (t.flushSync = io), (t.destroy = io);
        return;
      }
      t.removeListener("error", r), t.emit("error", n);
    }
  }
  function BM(e, t) {
    e.destroyed ||
      (t === "beforeExit"
        ? (e.flush(),
          e.on("drain", function () {
            e.end();
          }))
        : e.flushSync());
  }
  function KM(e) {
    return function (r, n, s = {}, i) {
      if (typeof s == "string") (i = oc({ dest: s })), (s = {});
      else if (typeof i == "string") {
        if (s && s.transport)
          throw Error("only one of option.transport or stream can be specified");
        i = oc({ dest: i });
      } else if (s instanceof mp || s.writable || s._writableState) (i = s), (s = {});
      else if (s.transport) {
        if (s.transport instanceof mp || s.transport.writable || s.transport._writableState)
          throw Error(
            "option.transport do not allow stream, please pass to option directly. e.g. pino(transport)",
          );
        if (
          s.transport.targets &&
          s.transport.targets.length &&
          s.formatters &&
          typeof s.formatters.level == "function"
        )
          throw Error("option.transport.targets do not allow custom level formatters");
        let u;
        s.customLevels &&
          (u = s.useOnlyCustomLevels
            ? s.customLevels
            : Object.assign({}, s.levels, s.customLevels)),
          (i = FM({ caller: n, ...s.transport, levels: u }));
      }
      if (
        ((s = Object.assign({}, e, s)),
        (s.serializers = Object.assign({}, e.serializers, s.serializers)),
        (s.formatters = Object.assign({}, e.formatters, s.formatters)),
        s.prettyPrint)
      )
        throw new Error(
          "prettyPrint option is no longer supported, see the pino-pretty package (https://github.com/pinojs/pino-pretty)",
        );
      let { enabled: o, onChild: a } = s;
      return (
        o === !1 && (s.level = "silent"),
        a || (s.onChild = io),
        i || (UM(process.stdout) ? (i = process.stdout) : (i = oc({ fd: process.stdout.fd || 1 }))),
        { opts: s, stream: i }
      );
    };
  }
  function GM(e, t) {
    try {
      return JSON.stringify(e);
    } catch {
      try {
        return (t || this[yp])(e);
      } catch {
        return '"[unable to serialize, circular reference is too complex to analyze]"';
      }
    }
  }
  function JM(e, t, r) {
    return { level: e, bindings: t, log: r };
  }
  function QM(e) {
    let t = Number(e);
    return typeof e == "string" && Number.isFinite(t) ? t : e === void 0 ? 1 : e;
  }
  Uw.exports = {
    noop: io,
    buildSafeSonicBoom: oc,
    asChindings: VM,
    asJson: zM,
    genLog: MM,
    createArgsNormalizer: KM,
    stringify: GM,
    buildFormatters: JM,
    normalizeDestFileDescriptor: QM,
  };
});
var uc = b((cse, Hw) => {
  var WM = { trace: 10, debug: 20, info: 30, warn: 40, error: 50, fatal: 60 },
    YM = { ASC: "ASC", DESC: "DESC" };
  Hw.exports = { DEFAULT_LEVELS: WM, SORTING_ORDER: YM };
});
var Sp = b((fse, Jw) => {
  "use strict";
  var {
      lsCacheSym: XM,
      levelValSym: gp,
      useOnlyCustomLevelsSym: ZM,
      streamSym: ez,
      formattersSym: tz,
      hooksSym: rz,
      levelCompSym: Bw,
    } = no(),
    { noop: nz, genLog: ci } = ac(),
    { DEFAULT_LEVELS: Cn, SORTING_ORDER: Kw } = uc(),
    Gw = {
      fatal: (e) => {
        let t = ci(Cn.fatal, e);
        return function (...r) {
          let n = this[ez];
          if ((t.call(this, ...r), typeof n.flushSync == "function"))
            try {
              n.flushSync();
            } catch {}
        };
      },
      error: (e) => ci(Cn.error, e),
      warn: (e) => ci(Cn.warn, e),
      info: (e) => ci(Cn.info, e),
      debug: (e) => ci(Cn.debug, e),
      trace: (e) => ci(Cn.trace, e),
    },
    _p = Object.keys(Cn).reduce((e, t) => ((e[Cn[t]] = t), e), {}),
    sz = Object.keys(_p).reduce((e, t) => ((e[t] = '{"level":' + Number(t)), e), {});
  function iz(e) {
    let t = e[tz].level,
      { labels: r } = e.levels,
      n = {};
    for (let s in r) {
      let i = t(r[s], Number(s));
      n[s] = JSON.stringify(i).slice(0, -1);
    }
    return (e[XM] = n), e;
  }
  function oz(e, t) {
    if (t) return !1;
    switch (e) {
      case "fatal":
      case "error":
      case "warn":
      case "info":
      case "debug":
      case "trace":
        return !0;
      default:
        return !1;
    }
  }
  function az(e) {
    let { labels: t, values: r } = this.levels;
    if (typeof e == "number") {
      if (t[e] === void 0) throw Error("unknown level value" + e);
      e = t[e];
    }
    if (r[e] === void 0) throw Error("unknown level " + e);
    let n = this[gp],
      s = (this[gp] = r[e]),
      i = this[ZM],
      o = this[Bw],
      a = this[rz].logMethod;
    for (let u in r) {
      if (o(r[u], s) === !1) {
        this[u] = nz;
        continue;
      }
      this[u] = oz(u, i) ? Gw[u](a) : ci(r[u], a);
    }
    this.emit("level-change", e, s, t[n], n, this);
  }
  function uz(e) {
    let { levels: t, levelVal: r } = this;
    return t && t.labels ? t.labels[r] : "";
  }
  function lz(e) {
    let { values: t } = this.levels,
      r = t[e];
    return r !== void 0 && this[Bw](r, this[gp]);
  }
  function cz(e, t, r) {
    return e === Kw.DESC ? t <= r : t >= r;
  }
  function fz(e) {
    return typeof e == "string" ? cz.bind(null, e) : e;
  }
  function dz(e = null, t = !1) {
    let r = e ? Object.keys(e).reduce((i, o) => ((i[e[o]] = o), i), {}) : null,
      n = Object.assign(
        Object.create(Object.prototype, { Infinity: { value: "silent" } }),
        t ? null : _p,
        r,
      ),
      s = Object.assign(
        Object.create(Object.prototype, { silent: { value: 1 / 0 } }),
        t ? null : Cn,
        e,
      );
    return { labels: n, values: s };
  }
  function hz(e, t, r) {
    if (typeof e == "number") {
      if (
        ![]
          .concat(
            Object.keys(t || {}).map((i) => t[i]),
            r ? [] : Object.keys(_p).map((i) => +i),
            1 / 0,
          )
          .includes(e)
      )
        throw Error(`default level:${e} must be included in custom levels`);
      return;
    }
    let n = Object.assign(
      Object.create(Object.prototype, { silent: { value: 1 / 0 } }),
      r ? null : Cn,
      t,
    );
    if (!(e in n)) throw Error(`default level:${e} must be included in custom levels`);
  }
  function pz(e, t) {
    let { labels: r, values: n } = e;
    for (let s in t) {
      if (s in n) throw Error("levels cannot be overridden");
      if (t[s] in r) throw Error("pre-existing level values cannot be used for new levels");
    }
  }
  function mz(e) {
    if (typeof e != "function" && !(typeof e == "string" && Object.values(Kw).includes(e)))
      throw new Error('Levels comparison should be one of "ASC", "DESC" or "function" type');
  }
  Jw.exports = {
    initialLsCache: sz,
    genLsCache: iz,
    levelMethods: Gw,
    getLevel: uz,
    setLevel: az,
    isLevelEnabled: lz,
    mappings: dz,
    assertNoLevelCollisions: pz,
    assertDefaultLevelFound: hz,
    genLevelComparison: fz,
    assertLevelComparison: mz,
  };
});
var vp = b((dse, Qw) => {
  "use strict";
  Qw.exports = { version: "9.2.0" };
});
var oE = b((pse, iE) => {
  "use strict";
  var { EventEmitter: yz } = require("events"),
    {
      lsCacheSym: gz,
      levelValSym: _z,
      setLevelSym: wp,
      getLevelSym: Ww,
      chindingsSym: Ep,
      parsedChindingsSym: Sz,
      mixinSym: vz,
      asJsonSym: tE,
      writeSym: bz,
      mixinMergeStrategySym: wz,
      timeSym: Ez,
      timeSliceIndexSym: Rz,
      streamSym: rE,
      serializersSym: fi,
      formattersSym: bp,
      errorKeySym: Tz,
      messageKeySym: Pz,
      useOnlyCustomLevelsSym: $z,
      needsMetadataGsym: Oz,
      redactFmtSym: Nz,
      stringifySym: Az,
      formatOptsSym: Iz,
      stringifiersSym: Cz,
      msgPrefixSym: Yw,
    } = no(),
    {
      getLevel: kz,
      setLevel: Dz,
      isLevelEnabled: qz,
      mappings: jz,
      initialLsCache: Lz,
      genLsCache: xz,
      assertNoLevelCollisions: Fz,
    } = Sp(),
    { asChindings: nE, asJson: Mz, buildFormatters: Xw, stringify: Zw } = ac(),
    { version: zz } = vp(),
    Vz = ep(),
    Uz = class {},
    sE = {
      constructor: Uz,
      child: Hz,
      bindings: Bz,
      setBindings: Kz,
      flush: Wz,
      isLevelEnabled: qz,
      version: zz,
      get level() {
        return this[Ww]();
      },
      set level(e) {
        this[wp](e);
      },
      get levelVal() {
        return this[_z];
      },
      set levelVal(e) {
        throw Error("levelVal is read-only");
      },
      [gz]: Lz,
      [bz]: Jz,
      [tE]: Mz,
      [Ww]: kz,
      [wp]: Dz,
    };
  Object.setPrototypeOf(sE, yz.prototype);
  iE.exports = function () {
    return Object.create(sE);
  };
  var eE = (e) => e;
  function Hz(e, t) {
    if (!e) throw Error("missing bindings for child Pino");
    t = t || {};
    let r = this[fi],
      n = this[bp],
      s = Object.create(this);
    if (t.hasOwnProperty("serializers") === !0) {
      s[fi] = Object.create(null);
      for (let c in r) s[fi][c] = r[c];
      let u = Object.getOwnPropertySymbols(r);
      for (var i = 0; i < u.length; i++) {
        let c = u[i];
        s[fi][c] = r[c];
      }
      for (let c in t.serializers) s[fi][c] = t.serializers[c];
      let l = Object.getOwnPropertySymbols(t.serializers);
      for (var o = 0; o < l.length; o++) {
        let c = l[o];
        s[fi][c] = t.serializers[c];
      }
    } else s[fi] = r;
    if (t.hasOwnProperty("formatters")) {
      let { level: u, bindings: l, log: c } = t.formatters;
      s[bp] = Xw(u || n.level, l || eE, c || n.log);
    } else s[bp] = Xw(n.level, eE, n.log);
    if (
      (t.hasOwnProperty("customLevels") === !0 &&
        (Fz(this.levels, t.customLevels), (s.levels = jz(t.customLevels, s[$z])), xz(s)),
      (typeof t.redact == "object" && t.redact !== null) || Array.isArray(t.redact))
    ) {
      s.redact = t.redact;
      let u = Vz(s.redact, Zw),
        l = { stringify: u[Nz] };
      (s[Az] = Zw), (s[Cz] = u), (s[Iz] = l);
    }
    typeof t.msgPrefix == "string" && (s[Yw] = (this[Yw] || "") + t.msgPrefix), (s[Ep] = nE(s, e));
    let a = t.level || this.level;
    return s[wp](a), this.onChild(s), s;
  }
  function Bz() {
    let t = `{${this[Ep].substr(1)}}`,
      r = JSON.parse(t);
    return delete r.pid, delete r.hostname, r;
  }
  function Kz(e) {
    let t = nE(this, e);
    (this[Ep] = t), delete this[Sz];
  }
  function Gz(e, t) {
    return Object.assign(t, e);
  }
  function Jz(e, t, r) {
    let n = this[Ez](),
      s = this[vz],
      i = this[Tz],
      o = this[Pz],
      a = this[wz] || Gz,
      u;
    e == null
      ? (u = {})
      : e instanceof Error
        ? ((u = { [i]: e }), t === void 0 && (t = e.message))
        : ((u = e), t === void 0 && e[o] === void 0 && e[i] && (t = e[i].message)),
      s && (u = a(u, s(u, r, this)));
    let l = this[tE](u, t, r, n),
      c = this[rE];
    c[Oz] === !0 &&
      ((c.lastLevel = r),
      (c.lastObj = u),
      (c.lastMsg = t),
      (c.lastTime = n.slice(this[Rz])),
      (c.lastLogger = this)),
      c.write(l);
  }
  function Qz() {}
  function Wz(e) {
    if (e != null && typeof e != "function") throw Error("callback must be a function");
    let t = this[rE];
    typeof t.flush == "function" ? t.flush(e || Qz) : e && e();
  }
});
var fE = b(($p, cE) => {
  "use strict";
  var { hasOwnProperty: lc } = Object.prototype,
    hi = Pp();
  hi.configure = Pp;
  hi.stringify = hi;
  hi.default = hi;
  $p.stringify = hi;
  $p.configure = Pp;
  cE.exports = hi;
  var Yz =
    /[\u0000-\u001f\u0022\u005c\ud800-\udfff]|[\ud800-\udbff](?![\udc00-\udfff])|(?:[^\ud800-\udbff]|^)[\udc00-\udfff]/;
  function Cs(e) {
    return e.length < 5e3 && !Yz.test(e) ? `"${e}"` : JSON.stringify(e);
  }
  function Rp(e) {
    if (e.length > 200) return e.sort();
    for (let t = 1; t < e.length; t++) {
      let r = e[t],
        n = t;
      for (; n !== 0 && e[n - 1] > r; ) (e[n] = e[n - 1]), n--;
      e[n] = r;
    }
    return e;
  }
  var Xz = Object.getOwnPropertyDescriptor(
    Object.getPrototypeOf(Object.getPrototypeOf(new Int8Array())),
    Symbol.toStringTag,
  ).get;
  function Tp(e) {
    return Xz.call(e) !== void 0 && e.length !== 0;
  }
  function aE(e, t, r) {
    e.length < r && (r = e.length);
    let n = t === "," ? "" : " ",
      s = `"0":${n}${e[0]}`;
    for (let i = 1; i < r; i++) s += `${t}"${i}":${n}${e[i]}`;
    return s;
  }
  function Zz(e) {
    if (lc.call(e, "circularValue")) {
      let t = e.circularValue;
      if (typeof t == "string") return `"${t}"`;
      if (t == null) return t;
      if (t === Error || t === TypeError)
        return {
          toString() {
            throw new TypeError("Converting circular structure to JSON");
          },
        };
      throw new TypeError(
        'The "circularValue" argument must be of type string or the value null or undefined',
      );
    }
    return '"[Circular]"';
  }
  function uE(e, t) {
    let r;
    if (lc.call(e, t) && ((r = e[t]), typeof r != "boolean"))
      throw new TypeError(`The "${t}" argument must be of type boolean`);
    return r === void 0 ? !0 : r;
  }
  function lE(e, t) {
    let r;
    if (lc.call(e, t)) {
      if (((r = e[t]), typeof r != "number"))
        throw new TypeError(`The "${t}" argument must be of type number`);
      if (!Number.isInteger(r)) throw new TypeError(`The "${t}" argument must be an integer`);
      if (r < 1) throw new RangeError(`The "${t}" argument must be >= 1`);
    }
    return r === void 0 ? 1 / 0 : r;
  }
  function di(e) {
    return e === 1 ? "1 item" : `${e} items`;
  }
  function eV(e) {
    let t = new Set();
    for (let r of e) (typeof r == "string" || typeof r == "number") && t.add(String(r));
    return t;
  }
  function tV(e) {
    if (lc.call(e, "strict")) {
      let t = e.strict;
      if (typeof t != "boolean")
        throw new TypeError('The "strict" argument must be of type boolean');
      if (t)
        return (r) => {
          let n = `Object can not safely be stringified. Received type ${typeof r}`;
          throw (typeof r != "function" && (n += ` (${r.toString()})`), new Error(n));
        };
    }
  }
  function Pp(e) {
    e = { ...e };
    let t = tV(e);
    t &&
      (e.bigint === void 0 && (e.bigint = !1), "circularValue" in e || (e.circularValue = Error));
    let r = Zz(e),
      n = uE(e, "bigint"),
      s = uE(e, "deterministic"),
      i = lE(e, "maximumDepth"),
      o = lE(e, "maximumBreadth");
    function a(d, h, p, y, _, S) {
      let E = h[d];
      switch (
        (typeof E == "object" && E !== null && typeof E.toJSON == "function" && (E = E.toJSON(d)),
        (E = y.call(h, d, E)),
        typeof E)
      ) {
        case "string":
          return Cs(E);
        case "object": {
          if (E === null) return "null";
          if (p.indexOf(E) !== -1) return r;
          let g = "",
            m = ",",
            T = S;
          if (Array.isArray(E)) {
            if (E.length === 0) return "[]";
            if (i < p.length + 1) return '"[Array]"';
            p.push(E),
              _ !== "" &&
                ((S += _),
                (g += `
${S}`),
                (m = `,
${S}`));
            let M = Math.min(E.length, o),
              k = 0;
            for (; k < M - 1; k++) {
              let ie = a(String(k), E, p, y, _, S);
              (g += ie !== void 0 ? ie : "null"), (g += m);
            }
            let x = a(String(k), E, p, y, _, S);
            if (((g += x !== void 0 ? x : "null"), E.length - 1 > o)) {
              let ie = E.length - o - 1;
              g += `${m}"... ${di(ie)} not stringified"`;
            }
            return (
              _ !== "" &&
                (g += `
${T}`),
              p.pop(),
              `[${g}]`
            );
          }
          let N = Object.keys(E),
            w = N.length;
          if (w === 0) return "{}";
          if (i < p.length + 1) return '"[Object]"';
          let $ = "",
            D = "";
          _ !== "" &&
            ((S += _),
            (m = `,
${S}`),
            ($ = " "));
          let v = Math.min(w, o);
          s && !Tp(E) && (N = Rp(N)), p.push(E);
          for (let M = 0; M < v; M++) {
            let k = N[M],
              x = a(k, E, p, y, _, S);
            x !== void 0 && ((g += `${D}${Cs(k)}:${$}${x}`), (D = m));
          }
          if (w > o) {
            let M = w - o;
            (g += `${D}"...":${$}"${di(M)} not stringified"`), (D = m);
          }
          return (
            _ !== "" &&
              D.length > 1 &&
              (g = `
${S}${g}
${T}`),
            p.pop(),
            `{${g}}`
          );
        }
        case "number":
          return isFinite(E) ? String(E) : t ? t(E) : "null";
        case "boolean":
          return E === !0 ? "true" : "false";
        case "undefined":
          return;
        case "bigint":
          if (n) return String(E);
        default:
          return t ? t(E) : void 0;
      }
    }
    function u(d, h, p, y, _, S) {
      switch (
        (typeof h == "object" && h !== null && typeof h.toJSON == "function" && (h = h.toJSON(d)),
        typeof h)
      ) {
        case "string":
          return Cs(h);
        case "object": {
          if (h === null) return "null";
          if (p.indexOf(h) !== -1) return r;
          let E = S,
            g = "",
            m = ",";
          if (Array.isArray(h)) {
            if (h.length === 0) return "[]";
            if (i < p.length + 1) return '"[Array]"';
            p.push(h),
              _ !== "" &&
                ((S += _),
                (g += `
${S}`),
                (m = `,
${S}`));
            let w = Math.min(h.length, o),
              $ = 0;
            for (; $ < w - 1; $++) {
              let v = u(String($), h[$], p, y, _, S);
              (g += v !== void 0 ? v : "null"), (g += m);
            }
            let D = u(String($), h[$], p, y, _, S);
            if (((g += D !== void 0 ? D : "null"), h.length - 1 > o)) {
              let v = h.length - o - 1;
              g += `${m}"... ${di(v)} not stringified"`;
            }
            return (
              _ !== "" &&
                (g += `
${E}`),
              p.pop(),
              `[${g}]`
            );
          }
          p.push(h);
          let T = "";
          _ !== "" &&
            ((S += _),
            (m = `,
${S}`),
            (T = " "));
          let N = "";
          for (let w of y) {
            let $ = u(w, h[w], p, y, _, S);
            $ !== void 0 && ((g += `${N}${Cs(w)}:${T}${$}`), (N = m));
          }
          return (
            _ !== "" &&
              N.length > 1 &&
              (g = `
${S}${g}
${E}`),
            p.pop(),
            `{${g}}`
          );
        }
        case "number":
          return isFinite(h) ? String(h) : t ? t(h) : "null";
        case "boolean":
          return h === !0 ? "true" : "false";
        case "undefined":
          return;
        case "bigint":
          if (n) return String(h);
        default:
          return t ? t(h) : void 0;
      }
    }
    function l(d, h, p, y, _) {
      switch (typeof h) {
        case "string":
          return Cs(h);
        case "object": {
          if (h === null) return "null";
          if (typeof h.toJSON == "function") {
            if (((h = h.toJSON(d)), typeof h != "object")) return l(d, h, p, y, _);
            if (h === null) return "null";
          }
          if (p.indexOf(h) !== -1) return r;
          let S = _;
          if (Array.isArray(h)) {
            if (h.length === 0) return "[]";
            if (i < p.length + 1) return '"[Array]"';
            p.push(h), (_ += y);
            let $ = `
${_}`,
              D = `,
${_}`,
              v = Math.min(h.length, o),
              M = 0;
            for (; M < v - 1; M++) {
              let x = l(String(M), h[M], p, y, _);
              ($ += x !== void 0 ? x : "null"), ($ += D);
            }
            let k = l(String(M), h[M], p, y, _);
            if ((($ += k !== void 0 ? k : "null"), h.length - 1 > o)) {
              let x = h.length - o - 1;
              $ += `${D}"... ${di(x)} not stringified"`;
            }
            return (
              ($ += `
${S}`),
              p.pop(),
              `[${$}]`
            );
          }
          let E = Object.keys(h),
            g = E.length;
          if (g === 0) return "{}";
          if (i < p.length + 1) return '"[Object]"';
          _ += y;
          let m = `,
${_}`,
            T = "",
            N = "",
            w = Math.min(g, o);
          Tp(h) && ((T += aE(h, m, o)), (E = E.slice(h.length)), (w -= h.length), (N = m)),
            s && (E = Rp(E)),
            p.push(h);
          for (let $ = 0; $ < w; $++) {
            let D = E[$],
              v = l(D, h[D], p, y, _);
            v !== void 0 && ((T += `${N}${Cs(D)}: ${v}`), (N = m));
          }
          if (g > o) {
            let $ = g - o;
            (T += `${N}"...": "${di($)} not stringified"`), (N = m);
          }
          return (
            N !== "" &&
              (T = `
${_}${T}
${S}`),
            p.pop(),
            `{${T}}`
          );
        }
        case "number":
          return isFinite(h) ? String(h) : t ? t(h) : "null";
        case "boolean":
          return h === !0 ? "true" : "false";
        case "undefined":
          return;
        case "bigint":
          if (n) return String(h);
        default:
          return t ? t(h) : void 0;
      }
    }
    function c(d, h, p) {
      switch (typeof h) {
        case "string":
          return Cs(h);
        case "object": {
          if (h === null) return "null";
          if (typeof h.toJSON == "function") {
            if (((h = h.toJSON(d)), typeof h != "object")) return c(d, h, p);
            if (h === null) return "null";
          }
          if (p.indexOf(h) !== -1) return r;
          let y = "";
          if (Array.isArray(h)) {
            if (h.length === 0) return "[]";
            if (i < p.length + 1) return '"[Array]"';
            p.push(h);
            let m = Math.min(h.length, o),
              T = 0;
            for (; T < m - 1; T++) {
              let w = c(String(T), h[T], p);
              (y += w !== void 0 ? w : "null"), (y += ",");
            }
            let N = c(String(T), h[T], p);
            if (((y += N !== void 0 ? N : "null"), h.length - 1 > o)) {
              let w = h.length - o - 1;
              y += `,"... ${di(w)} not stringified"`;
            }
            return p.pop(), `[${y}]`;
          }
          let _ = Object.keys(h),
            S = _.length;
          if (S === 0) return "{}";
          if (i < p.length + 1) return '"[Object]"';
          let E = "",
            g = Math.min(S, o);
          Tp(h) && ((y += aE(h, ",", o)), (_ = _.slice(h.length)), (g -= h.length), (E = ",")),
            s && (_ = Rp(_)),
            p.push(h);
          for (let m = 0; m < g; m++) {
            let T = _[m],
              N = c(T, h[T], p);
            N !== void 0 && ((y += `${E}${Cs(T)}:${N}`), (E = ","));
          }
          if (S > o) {
            let m = S - o;
            y += `${E}"...":"${di(m)} not stringified"`;
          }
          return p.pop(), `{${y}}`;
        }
        case "number":
          return isFinite(h) ? String(h) : t ? t(h) : "null";
        case "boolean":
          return h === !0 ? "true" : "false";
        case "undefined":
          return;
        case "bigint":
          if (n) return String(h);
        default:
          return t ? t(h) : void 0;
      }
    }
    function f(d, h, p) {
      if (arguments.length > 1) {
        let y = "";
        if (
          (typeof p == "number"
            ? (y = " ".repeat(Math.min(p, 10)))
            : typeof p == "string" && (y = p.slice(0, 10)),
          h != null)
        ) {
          if (typeof h == "function") return a("", { "": d }, [], h, y, "");
          if (Array.isArray(h)) return u("", d, [], eV(h), y, "");
        }
        if (y.length !== 0) return l("", d, [], y, "");
      }
      return c("", d, []);
    }
    return f;
  }
});
var pE = b((mse, hE) => {
  "use strict";
  var Op = Symbol.for("pino.metadata"),
    { DEFAULT_LEVELS: dE } = uc(),
    rV = dE.info;
  function nV(e, t) {
    let r = 0;
    (e = e || []), (t = t || { dedupe: !1 });
    let n = Object.create(dE);
    (n.silent = 1 / 0),
      t.levels &&
        typeof t.levels == "object" &&
        Object.keys(t.levels).forEach((f) => {
          n[f] = t.levels[f];
        });
    let s = {
      write: i,
      add: u,
      emit: o,
      flushSync: a,
      end: l,
      minLevel: 0,
      streams: [],
      clone: c,
      [Op]: !0,
      streamLevels: n,
    };
    return Array.isArray(e) ? e.forEach(u, s) : u.call(s, e), (e = null), s;
    function i(f) {
      let d,
        h = this.lastLevel,
        { streams: p } = this,
        y = 0,
        _;
      for (let S = iV(p.length, t.dedupe); aV(S, p.length, t.dedupe); S = oV(S, t.dedupe))
        if (((d = p[S]), d.level <= h)) {
          if (y !== 0 && y !== d.level) break;
          if (((_ = d.stream), _[Op])) {
            let { lastTime: E, lastMsg: g, lastObj: m, lastLogger: T } = this;
            (_.lastLevel = h),
              (_.lastTime = E),
              (_.lastMsg = g),
              (_.lastObj = m),
              (_.lastLogger = T);
          }
          _.write(f), t.dedupe && (y = d.level);
        } else if (!t.dedupe) break;
    }
    function o(...f) {
      for (let { stream: d } of this.streams) typeof d.emit == "function" && d.emit(...f);
    }
    function a() {
      for (let { stream: f } of this.streams) typeof f.flushSync == "function" && f.flushSync();
    }
    function u(f) {
      if (!f) return s;
      let d = typeof f.write == "function" || f.stream,
        h = f.write ? f : f.stream;
      if (!d)
        throw Error(
          "stream object needs to implement either StreamEntry or DestinationStream interface",
        );
      let { streams: p, streamLevels: y } = this,
        _;
      typeof f.levelVal == "number"
        ? (_ = f.levelVal)
        : typeof f.level == "string"
          ? (_ = y[f.level])
          : typeof f.level == "number"
            ? (_ = f.level)
            : (_ = rV);
      let S = { stream: h, level: _, levelVal: void 0, id: r++ };
      return p.unshift(S), p.sort(sV), (this.minLevel = p[0].level), s;
    }
    function l() {
      for (let { stream: f } of this.streams)
        typeof f.flushSync == "function" && f.flushSync(), f.end();
    }
    function c(f) {
      let d = new Array(this.streams.length);
      for (let h = 0; h < d.length; h++) d[h] = { level: f, stream: this.streams[h].stream };
      return {
        write: i,
        add: u,
        minLevel: f,
        streams: d,
        clone: c,
        emit: o,
        flushSync: a,
        [Op]: !0,
      };
    }
  }
  function sV(e, t) {
    return e.level - t.level;
  }
  function iV(e, t) {
    return t ? e - 1 : 0;
  }
  function oV(e, t) {
    return t ? e - 1 : e + 1;
  }
  function aV(e, t, r) {
    return r ? e >= 0 : e < t;
  }
  hE.exports = nV;
});
var Cp = b((yse, Yr) => {
  function cc(e) {
    try {
      return require("path").join(
        `${process.cwd()}${require("path").sep}build`.replace(/\\/g, "/"),
        e,
      );
    } catch {
      return new Function("p", "return new URL(p, import.meta.url).pathname")(e);
    }
  }
  globalThis.__bundlerPathsOverrides = {
    ...(globalThis.__bundlerPathsOverrides || {}),
    "thread-stream-worker": cc("./thread-stream-worker.js"),
    "pino-worker": cc("./pino-worker.js"),
    "pino/file": cc("./pino-file.js"),
    "pino-pretty": cc("./pino-pretty.js"),
  };
  var uV = require("os"),
    wE = Kh(),
    lV = Gh(),
    cV = ep(),
    EE = ow(),
    fV = oE(),
    RE = no(),
    { configure: dV } = fE(),
    {
      assertDefaultLevelFound: hV,
      mappings: TE,
      genLsCache: pV,
      genLevelComparison: mV,
      assertLevelComparison: yV,
    } = Sp(),
    { DEFAULT_LEVELS: gV, SORTING_ORDER: _V } = uc(),
    {
      createArgsNormalizer: SV,
      asChindings: vV,
      buildSafeSonicBoom: mE,
      buildFormatters: bV,
      stringify: Np,
      normalizeDestFileDescriptor: yE,
      noop: wV,
    } = ac(),
    { version: EV } = vp(),
    {
      chindingsSym: gE,
      redactFmtSym: RV,
      serializersSym: _E,
      timeSym: TV,
      timeSliceIndexSym: PV,
      streamSym: $V,
      stringifySym: SE,
      stringifySafeSym: Ap,
      stringifiersSym: vE,
      setLevelSym: OV,
      endSym: NV,
      formatOptsSym: AV,
      messageKeySym: IV,
      errorKeySym: CV,
      nestedKeySym: kV,
      mixinSym: DV,
      levelCompSym: qV,
      useOnlyCustomLevelsSym: jV,
      formattersSym: bE,
      hooksSym: LV,
      nestedKeyStrSym: xV,
      mixinMergeStrategySym: FV,
      msgPrefixSym: MV,
    } = RE,
    { epochTime: PE, nullTime: zV } = EE,
    { pid: VV } = process,
    UV = uV.hostname(),
    HV = wE.err,
    BV = {
      level: "info",
      levelComparison: _V.ASC,
      levels: gV,
      messageKey: "msg",
      errorKey: "err",
      nestedKey: null,
      enabled: !0,
      base: { pid: VV, hostname: UV },
      serializers: Object.assign(Object.create(null), { err: HV }),
      formatters: Object.assign(Object.create(null), {
        bindings(e) {
          return e;
        },
        level(e, t) {
          return { level: t };
        },
      }),
      hooks: { logMethod: void 0 },
      timestamp: PE,
      name: void 0,
      redact: null,
      customLevels: null,
      useOnlyCustomLevels: !1,
      depthLimit: 5,
      edgeLimit: 100,
    },
    KV = SV(BV),
    GV = Object.assign(Object.create(null), wE);
  function Ip(...e) {
    let t = {},
      { opts: r, stream: n } = KV(t, lV(), ...e),
      {
        redact: s,
        crlf: i,
        serializers: o,
        timestamp: a,
        messageKey: u,
        errorKey: l,
        nestedKey: c,
        base: f,
        name: d,
        level: h,
        customLevels: p,
        levelComparison: y,
        mixin: _,
        mixinMergeStrategy: S,
        useOnlyCustomLevels: E,
        formatters: g,
        hooks: m,
        depthLimit: T,
        edgeLimit: N,
        onChild: w,
        msgPrefix: $,
      } = r,
      D = dV({ maximumDepth: T, maximumBreadth: N }),
      v = bV(g.level, g.bindings, g.log),
      M = Np.bind({ [Ap]: D }),
      k = s ? cV(s, M) : {},
      x = s ? { stringify: k[RV] } : { stringify: M },
      ie =
        "}" +
        (i
          ? `\r
`
          : `
`),
      Z = vV.bind(null, { [gE]: "", [_E]: o, [vE]: k, [SE]: Np, [Ap]: D, [bE]: v }),
      G = "";
    f !== null && (d === void 0 ? (G = Z(f)) : (G = Z(Object.assign({}, f, { name: d }))));
    let Y = a instanceof Function ? a : a ? PE : zV,
      U = Y().indexOf(":") + 1;
    if (E && !p) throw Error("customLevels is required if useOnlyCustomLevels is set true");
    if (_ && typeof _ != "function")
      throw Error(`Unknown mixin type "${typeof _}" - expected "function"`);
    if ($ && typeof $ != "string")
      throw Error(`Unknown msgPrefix type "${typeof $}" - expected "string"`);
    hV(h, p, E);
    let z = TE(p, E);
    typeof n.emit == "function" &&
      n.emit("message", { code: "PINO_CONFIG", config: { levels: z, messageKey: u, errorKey: l } }),
      yV(y);
    let oe = mV(y);
    return (
      Object.assign(t, {
        levels: z,
        [qV]: oe,
        [jV]: E,
        [$V]: n,
        [TV]: Y,
        [PV]: U,
        [SE]: Np,
        [Ap]: D,
        [vE]: k,
        [NV]: ie,
        [AV]: x,
        [IV]: u,
        [CV]: l,
        [kV]: c,
        [xV]: c ? `,${JSON.stringify(c)}:{` : "",
        [_E]: o,
        [DV]: _,
        [FV]: S,
        [gE]: G,
        [bE]: v,
        [LV]: m,
        silent: wV,
        onChild: w,
        [MV]: $,
      }),
      Object.setPrototypeOf(t, fV()),
      pV(t),
      t[OV](h),
      t
    );
  }
  Yr.exports = Ip;
  Yr.exports.destination = (e = process.stdout.fd) =>
    typeof e == "object"
      ? ((e.dest = yE(e.dest || process.stdout.fd)), mE(e))
      : mE({ dest: yE(e), minLength: 0 });
  Yr.exports.transport = hp();
  Yr.exports.multistream = pE();
  Yr.exports.levels = TE();
  Yr.exports.stdSerializers = GV;
  Yr.exports.stdTimeFunctions = Object.assign({}, EE);
  Yr.exports.symbols = RE;
  Yr.exports.version = EV;
  Yr.exports.default = Ip;
  Yr.exports.pino = Ip;
});
var ba = b((gse, IE) => {
  "use strict";
  var JV = yb(),
    fc = Cp(),
    { serializersSym: $E } = fc.symbols,
    { FST_ERR_LOG_INVALID_DESTINATION: QV, FST_ERR_LOG_INVALID_LOGGER: WV } = tr();
  function OE(e) {
    if (e.stream && e.file) throw new QV();
    e.file && ((e.stream = fc.destination(e.file)), delete e.file);
    let t = e.logger,
      r = e.genReqId,
      n = null;
    return (
      t
        ? ((e.logger = void 0),
          (e.genReqId = void 0),
          t[$E] && (e.serializers = Object.assign({}, e.serializers, t[$E])),
          (n = t.child({}, e)),
          (e.logger = t),
          (e.genReqId = r))
        : (n = fc(e, e.stream)),
      n
    );
  }
  var kp = {
    req: function (t) {
      return {
        method: t.method,
        url: t.url,
        version: t.headers && t.headers["accept-version"],
        hostname: t.hostname,
        remoteAddress: t.ip,
        remotePort: t.socket ? t.socket.remotePort : void 0,
      };
    },
    err: fc.stdSerializers.err,
    res: function (t) {
      return { statusCode: t.statusCode };
    },
  };
  function YV() {
    let e = process.hrtime();
    return e[0] * 1e3 + e[1] / 1e6;
  }
  function XV(e) {
    if (!e.logger) {
      let n = JV;
      return (n.child = () => n), { logger: n, hasLogger: !1 };
    }
    if (NE(e.logger))
      return {
        logger: OE({ logger: e.logger, serializers: Object.assign({}, kp, e.logger.serializers) }),
        hasLogger: !0,
      };
    let t = {};
    return (
      Object.prototype.toString.call(e.logger) === "[object Object]" &&
        Reflect.ownKeys(e.logger).forEach((n) => {
          Object.defineProperty(t, n, {
            value: e.logger[n],
            writable: !0,
            enumerable: !0,
            configurable: !0,
          });
        }),
      (t.level = t.level || "info"),
      (t.serializers = Object.assign({}, kp, t.serializers)),
      (e.logger = t),
      { logger: OE(e.logger), hasLogger: !0 }
    );
  }
  function NE(e, t) {
    let r = ["info", "error", "debug", "fatal", "warn", "trace", "child"],
      n = e ? r.filter((s) => !e[s] || typeof e[s] != "function") : r;
    if (n.length) {
      if (n.length === r.length && !t) return !1;
      throw WV(n.join(","));
    } else return !0;
  }
  function ZV(e, t, r, n, s) {
    let i = { [e.requestIdLogLabel]: n },
      o = e.childLoggerFactory.call(e.server, t, i, s || {}, r);
    return e.childLoggerFactory !== AE && NE(o, !0), o;
  }
  function AE(e, t, r) {
    return e.child(t, r);
  }
  IE.exports = {
    createLogger: XV,
    createChildLogger: ZV,
    defaultChildLoggerFactory: AE,
    serializers: kp,
    now: YV,
  };
});
var dc = b((_se, CE) => {
  "use strict";
  CE.exports = e4;
  function oo(e) {
    return e instanceof Buffer
      ? Buffer.from(e)
      : new e.constructor(e.buffer.slice(), e.byteOffset, e.length);
  }
  function e4(e) {
    if (((e = e || {}), e.circles)) return t4(e);
    let t = new Map();
    if (
      (t.set(Date, (o) => new Date(o)),
      t.set(Map, (o, a) => new Map(n(Array.from(o), a))),
      t.set(Set, (o, a) => new Set(n(Array.from(o), a))),
      e.constructorHandlers)
    )
      for (let o of e.constructorHandlers) t.set(o[0], o[1]);
    let r = null;
    return e.proto ? i : s;
    function n(o, a) {
      let u = Object.keys(o),
        l = new Array(u.length);
      for (let c = 0; c < u.length; c++) {
        let f = u[c],
          d = o[f];
        typeof d != "object" || d === null
          ? (l[f] = d)
          : d.constructor !== Object && (r = t.get(d.constructor))
            ? (l[f] = r(d, a))
            : ArrayBuffer.isView(d)
              ? (l[f] = oo(d))
              : (l[f] = a(d));
      }
      return l;
    }
    function s(o) {
      if (typeof o != "object" || o === null) return o;
      if (Array.isArray(o)) return n(o, s);
      if (o.constructor !== Object && (r = t.get(o.constructor))) return r(o, s);
      let a = {};
      for (let u in o) {
        if (Object.hasOwnProperty.call(o, u) === !1) continue;
        let l = o[u];
        typeof l != "object" || l === null
          ? (a[u] = l)
          : l.constructor !== Object && (r = t.get(l.constructor))
            ? (a[u] = r(l, s))
            : ArrayBuffer.isView(l)
              ? (a[u] = oo(l))
              : (a[u] = s(l));
      }
      return a;
    }
    function i(o) {
      if (typeof o != "object" || o === null) return o;
      if (Array.isArray(o)) return n(o, i);
      if (o.constructor !== Object && (r = t.get(o.constructor))) return r(o, i);
      let a = {};
      for (let u in o) {
        let l = o[u];
        typeof l != "object" || l === null
          ? (a[u] = l)
          : l.constructor !== Object && (r = t.get(l.constructor))
            ? (a[u] = r(l, i))
            : ArrayBuffer.isView(l)
              ? (a[u] = oo(l))
              : (a[u] = i(l));
      }
      return a;
    }
  }
  function t4(e) {
    let t = [],
      r = [],
      n = new Map();
    if (
      (n.set(Date, (u) => new Date(u)),
      n.set(Map, (u, l) => new Map(i(Array.from(u), l))),
      n.set(Set, (u, l) => new Set(i(Array.from(u), l))),
      e.constructorHandlers)
    )
      for (let u of e.constructorHandlers) n.set(u[0], u[1]);
    let s = null;
    return e.proto ? a : o;
    function i(u, l) {
      let c = Object.keys(u),
        f = new Array(c.length);
      for (let d = 0; d < c.length; d++) {
        let h = c[d],
          p = u[h];
        if (typeof p != "object" || p === null) f[h] = p;
        else if (p.constructor !== Object && (s = n.get(p.constructor))) f[h] = s(p, l);
        else if (ArrayBuffer.isView(p)) f[h] = oo(p);
        else {
          let y = t.indexOf(p);
          y !== -1 ? (f[h] = r[y]) : (f[h] = l(p));
        }
      }
      return f;
    }
    function o(u) {
      if (typeof u != "object" || u === null) return u;
      if (Array.isArray(u)) return i(u, o);
      if (u.constructor !== Object && (s = n.get(u.constructor))) return s(u, o);
      let l = {};
      t.push(u), r.push(l);
      for (let c in u) {
        if (Object.hasOwnProperty.call(u, c) === !1) continue;
        let f = u[c];
        if (typeof f != "object" || f === null) l[c] = f;
        else if (f.constructor !== Object && (s = n.get(f.constructor))) l[c] = s(f, o);
        else if (ArrayBuffer.isView(f)) l[c] = oo(f);
        else {
          let d = t.indexOf(f);
          d !== -1 ? (l[c] = r[d]) : (l[c] = o(f));
        }
      }
      return t.pop(), r.pop(), l;
    }
    function a(u) {
      if (typeof u != "object" || u === null) return u;
      if (Array.isArray(u)) return i(u, a);
      if (u.constructor !== Object && (s = n.get(u.constructor))) return s(u, a);
      let l = {};
      t.push(u), r.push(l);
      for (let c in u) {
        let f = u[c];
        if (typeof f != "object" || f === null) l[c] = f;
        else if (f.constructor !== Object && (s = n.get(f.constructor))) l[c] = s(f, a);
        else if (ArrayBuffer.isView(f)) l[c] = oo(f);
        else {
          let d = t.indexOf(f);
          d !== -1 ? (l[c] = r[d]) : (l[c] = a(f));
        }
      }
      return t.pop(), r.pop(), l;
    }
  }
});
var wa = b((Sse, jE) => {
  "use strict";
  var r4 = dc()({ circles: !1, proto: !0 }),
    { kSchemaVisited: kE, kSchemaResponse: n4 } = Vt(),
    qp = Symbol.for("fluent-schema-object"),
    {
      FST_ERR_SCH_MISSING_ID: s4,
      FST_ERR_SCH_ALREADY_PRESENT: i4,
      FST_ERR_SCH_DUPLICATE: o4,
      FST_ERR_SCH_CONTENT_MISSING_SCHEMA: a4,
    } = tr(),
    qE = ["params", "body", "querystring", "query", "headers"];
  function hc(e) {
    this.store = e || {};
  }
  hc.prototype.add = function (e) {
    let t = r4(e.isFluentSchema || e.isFluentJSONSchema || e[qp] ? e.valueOf() : e),
      r = t.$id;
    if (!r) throw new s4();
    if (this.store[r]) throw new i4(r);
    this.store[r] = t;
  };
  hc.prototype.getSchemas = function () {
    return Object.assign({}, this.store);
  };
  hc.prototype.getSchema = function (e) {
    return this.store[e];
  };
  function DE(e) {
    return typeof e == "object" && Object.getPrototypeOf(e) !== Object.prototype;
  }
  function u4(e, t) {
    if (e[kE]) return e;
    if (e.query) {
      if (e.querystring) throw new o4("querystring");
      e.querystring = e.query;
    }
    l4(e);
    for (let r of qE) {
      let n = e[r];
      n && !DE(n) && (e[r] = Dp(n, t.jsonShorthand));
    }
    if (e.response) {
      let r = Object.keys(e.response);
      for (let n of r) {
        if (DE(e.response[n])) continue;
        let s = e.response[n].content,
          i = !1;
        if (s) {
          let o = Object.keys(s);
          for (let a = 0; a < o.length; a++) {
            let u = o[a];
            if (!s[u].schema) {
              if (o.length === 1) break;
              throw new a4(u);
            }
            (e.response[n].content[u].schema = Dp(s[u].schema, t.jsonShorthand)),
              a === o.length - 1 && (i = !0);
          }
        }
        i || (e.response[n] = Dp(e.response[n], t.jsonShorthand));
      }
    }
    return (e[kE] = !0), e;
  }
  function l4(e) {
    for (let t of qE) e[t] && (e[t].isFluentSchema || e[t][qp]) && (e[t] = e[t].valueOf());
    if (e.response) {
      let t = Object.keys(e.response);
      for (let r of t)
        (e.response[r].isFluentSchema || e.response[r][qp]) &&
          (e.response[r] = e.response[r].valueOf());
    }
  }
  function Dp(e, t) {
    return !t || e.$ref || e.oneOf || e.allOf || e.anyOf || e.$merge || e.$patch
      ? e
      : !e.type && !e.properties
        ? { type: "object", properties: e }
        : e;
  }
  function c4(e, t, r) {
    let n = e[n4];
    if (!n) return !1;
    if (n[t]) {
      if (n[t].constructor === Object && r) {
        let i = r.split(";", 1)[0];
        return n[t][i] ? n[t][i] : !1;
      }
      return n[t];
    }
    let s = (t + "")[0] + "xx";
    if (n[s]) {
      if (n[s].constructor === Object && r) {
        let i = r.split(";", 1)[0];
        return n[s][i] ? n[s][i] : !1;
      }
      return n[s];
    }
    if (n.default) {
      if (n.default.constructor === Object && r) {
        let i = r.split(";", 1)[0];
        return n.default[i] ? n.default[i] : !1;
      }
      return n.default;
    }
    return !1;
  }
  jE.exports = {
    buildSchemas(e) {
      return new hc(e);
    },
    getSchemaSerializer: c4,
    normalizeSchema: u4,
  };
});
var pc = b((vse, xE) => {
  "use strict";
  var f4 = /[\u0000-\u001f\u0022\u005c\ud800-\udfff]/;
  xE.exports = class LE {
    constructor(t) {
      switch (t && t.rounding) {
        case "floor":
          this.parseInteger = Math.floor;
          break;
        case "ceil":
          this.parseInteger = Math.ceil;
          break;
        case "round":
          this.parseInteger = Math.round;
          break;
        case "trunc":
        default:
          this.parseInteger = Math.trunc;
          break;
      }
      this._options = t;
    }
    asInteger(t) {
      if (Number.isInteger(t)) return "" + t;
      if (typeof t == "bigint") return t.toString();
      let r = this.parseInteger(t);
      if (r === 1 / 0 || r === -1 / 0 || r !== r)
        throw new Error(`The value "${t}" cannot be converted to an integer.`);
      return "" + r;
    }
    asNumber(t) {
      let r = +t;
      if (r !== r) throw new Error(`The value "${t}" cannot be converted to a number.`);
      return r === 1 / 0 || r === -1 / 0 ? "null" : "" + r;
    }
    asBoolean(t) {
      return (t && "true") || "false";
    }
    asDateTime(t) {
      if (t === null) return '""';
      if (t instanceof Date) return '"' + t.toISOString() + '"';
      if (typeof t == "string") return '"' + t + '"';
      throw new Error(`The value "${t}" cannot be converted to a date-time.`);
    }
    asDate(t) {
      if (t === null) return '""';
      if (t instanceof Date)
        return (
          '"' + new Date(t.getTime() - t.getTimezoneOffset() * 6e4).toISOString().slice(0, 10) + '"'
        );
      if (typeof t == "string") return '"' + t + '"';
      throw new Error(`The value "${t}" cannot be converted to a date.`);
    }
    asTime(t) {
      if (t === null) return '""';
      if (t instanceof Date)
        return (
          '"' +
          new Date(t.getTime() - t.getTimezoneOffset() * 6e4).toISOString().slice(11, 19) +
          '"'
        );
      if (typeof t == "string") return '"' + t + '"';
      throw new Error(`The value "${t}" cannot be converted to a time.`);
    }
    asString(t) {
      let r = t.length;
      if (r < 42) {
        let s = "",
          i = -1,
          o = 255;
        for (var n = 0; n < r; n++)
          if (((o = t.charCodeAt(n)), o === 34 || o === 92))
            i === -1 && (i = 0), (s += t.slice(i, n) + "\\"), (i = n);
          else if (o < 32 || (o >= 55296 && o <= 57343)) return JSON.stringify(t);
        return (i === -1 && '"' + t + '"') || '"' + s + t.slice(i) + '"';
      } else return r < 5e3 && f4.test(t) === !1 ? '"' + t + '"' : JSON.stringify(t);
    }
    asUnsafeString(t) {
      return '"' + t + '"';
    }
    getState() {
      return this._options;
    }
    static restoreFromState(t) {
      return new LE(t);
    }
  };
});
var ME = b((bse, FE) => {
  "use strict";
  var d4 = pc(),
    h4 = { mode: "standalone" },
    p4 = d4.restoreFromState(h4),
    m4 = null;
  FE.exports = (function (t, r) {
    let n = "{",
      s = "}",
      i = "[",
      o = "]",
      a = ",",
      u = ":",
      l = '"',
      c = n + s,
      f = i + o,
      d = l + l,
      h = "null";
    function p(_) {
      let S = _ && typeof _.toJSON == "function" ? _.toJSON() : _;
      if (S === null) return c;
      let E,
        g = n,
        m = !1;
      return (
        (E = S.statusCode),
        E !== void 0 &&
          ((!m && (m = !0)) || (g += a), (g += '"statusCode":'), (g += r.asNumber(E))),
        (E = S.code),
        E !== void 0 &&
          ((!m && (m = !0)) || (g += a),
          (g += '"code":'),
          typeof E != "string"
            ? E === null
              ? (g += d)
              : E instanceof Date
                ? (g += l + E.toISOString() + l)
                : E instanceof RegExp
                  ? (g += r.asString(E.source))
                  : (g += r.asString(E.toString()))
            : (g += r.asString(E))),
        (E = S.error),
        E !== void 0 &&
          ((!m && (m = !0)) || (g += a),
          (g += '"error":'),
          typeof E != "string"
            ? E === null
              ? (g += d)
              : E instanceof Date
                ? (g += l + E.toISOString() + l)
                : E instanceof RegExp
                  ? (g += r.asString(E.source))
                  : (g += r.asString(E.toString()))
            : (g += r.asString(E))),
        (E = S.message),
        E !== void 0 &&
          ((!m && (m = !0)) || (g += a),
          (g += '"message":'),
          typeof E != "string"
            ? E === null
              ? (g += d)
              : E instanceof Date
                ? (g += l + E.toISOString() + l)
                : E instanceof RegExp
                  ? (g += r.asString(E.source))
                  : (g += r.asString(E.toString()))
            : (g += r.asString(E))),
        g + s
      );
    }
    return p;
  })(m4, p4);
});
var Ea = b((wse, HE) => {
  "use strict";
  var zE = require("node:http").STATUS_CODES,
    y4 = Ch(),
    {
      kReplyHeaders: pi,
      kReplyNextErrorHandler: mc,
      kReplyIsRunningOnErrorHook: g4,
      kReplyHasStatusCode: _4,
      kRouteContext: UE,
      kDisableRequestLogging: yc,
    } = Vt(),
    { FST_ERR_REP_INVALID_PAYLOAD_TYPE: S4, FST_ERR_FAILED_ERROR_SERIALIZATION: v4 } = tr(),
    { getSchemaSerializer: b4 } = wa(),
    jp = ME(),
    w4 = {
      func: R4,
      toJSON() {
        return this.func.name.toString() + "()";
      },
    };
  function E4(e, t, r) {
    e[g4] = !1;
    let n = e[UE];
    if (e[mc] === !1) {
      VE(t, e, function (o, a) {
        try {
          o.raw.writeHead(o.raw.statusCode, o[pi]);
        } catch (u) {
          o.log[yc] || o.log.warn({ req: o.request, res: o, err: u }, u && u.message),
            o.raw.writeHead(o.raw.statusCode);
        }
        o.raw.end(a);
      });
      return;
    }
    let s = e[mc] || n.errorHandler;
    (e[mc] = Object.getPrototypeOf(s)),
      delete e[pi]["content-type"],
      delete e[pi]["content-length"];
    let i = s.func;
    if (!i) {
      (e[mc] = !1), VE(t, e, r);
      return;
    }
    try {
      let o = i(t, e.request, e);
      o !== void 0 && (o !== null && typeof o.then == "function" ? y4(o, e) : e.send(o));
    } catch (o) {
      e.send(o);
    }
  }
  function R4(e, t, r) {
    if ((P4(e, r), !r[_4] || r.statusCode === 200)) {
      let n = e.statusCode || e.status;
      r.code(n >= 400 ? n : 500);
    }
    r.statusCode < 500
      ? r.log[yc] || r.log.info({ res: r, err: e }, e && e.message)
      : r.log[yc] || r.log.error({ req: t, res: r, err: e }, e && e.message),
      r.send(e);
  }
  function VE(e, t, r) {
    let n = t.raw,
      s = t.statusCode;
    t[pi]["content-type"] = t[pi]["content-type"] ?? "application/json; charset=utf-8";
    let i;
    try {
      let o = b4(t[UE], s, t[pi]["content-type"]);
      i =
        o === !1
          ? jp({ error: zE[s + ""], code: e.code, message: e.message, statusCode: s })
          : o(
              Object.create(e, {
                error: { value: zE[s + ""] },
                message: { value: e.message },
                statusCode: { value: s },
              }),
            );
    } catch (o) {
      t.log[yc] ||
        t.log.error(
          { err: o, statusCode: n.statusCode },
          "The serializer for the given status code failed",
        ),
        t.code(500),
        (i = jp(new v4(o.message, e.message)));
    }
    typeof i != "string" && !Buffer.isBuffer(i) && (i = jp(new S4(typeof i))),
      (t[pi]["content-length"] = "" + Buffer.byteLength(i)),
      r(t, i);
  }
  function T4(e = w4, t) {
    if (!t) return e;
    let r = Object.create(e);
    return (r.func = t), r;
  }
  function P4(e, t) {
    let r = t.raw,
      n = r.statusCode;
    (n = n >= 400 ? n : 500),
      e != null &&
        (e.headers !== void 0 && t.headers(e.headers),
        e.status >= 400 ? (n = e.status) : e.statusCode >= 400 && (n = e.statusCode)),
      (r.statusCode = n);
  }
  HE.exports = { buildErrorHandler: T4, handleError: E4 };
});
var wc = b((Ese, bc) => {
  "use strict";
  var Mp = require("node:stream").finished,
    $4 = require("node:stream").Readable,
    {
      kFourOhFourContext: BE,
      kPublicRouteContext: KE,
      kReplyErrorHandlerCalled: eR,
      kReplyHijacked: Ra,
      kReplyStartTime: Ta,
      kReplyEndTime: Vp,
      kReplySerializer: ns,
      kReplySerializerDefault: _c,
      kReplyIsError: Sc,
      kReplyHeaders: ct,
      kReplyTrailers: Ut,
      kReplyHasStatusCode: Up,
      kReplyIsRunningOnErrorHook: Hp,
      kReplyNextErrorHandler: O4,
      kDisableRequestLogging: tR,
      kSchemaResponse: vc,
      kReplyCacheSerializeFns: ks,
      kSchemaController: Lp,
      kOptions: N4,
      kRouteContext: ke,
    } = Vt(),
    {
      onSendHookRunner: rR,
      onResponseHookRunner: A4,
      preHandlerHookRunner: I4,
      preSerializationHookRunner: C4,
    } = Os(),
    GE = jh()[Symbol.for("internals")],
    k4 = ba(),
    zp = k4.now,
    { handleError: JE } = Ea(),
    { getSchemaSerializer: D4 } = wa(),
    xp = {
      JSON: "application/json; charset=utf-8",
      PLAIN: "text/plain; charset=utf-8",
      OCTET: "application/octet-stream",
    },
    {
      FST_ERR_REP_INVALID_PAYLOAD_TYPE: q4,
      FST_ERR_REP_RESPONSE_BODY_CONSUMED: j4,
      FST_ERR_REP_ALREADY_SENT: nR,
      FST_ERR_REP_SENT_VALUE: L4,
      FST_ERR_SEND_INSIDE_ONERR: x4,
      FST_ERR_BAD_STATUS_CODE: F4,
      FST_ERR_BAD_TRAILER_NAME: M4,
      FST_ERR_BAD_TRAILER_VALUE: z4,
      FST_ERR_MISSING_SERIALIZATION_FN: V4,
      FST_ERR_MISSING_CONTENTTYPE_SERIALIZATION_FN: U4,
    } = tr(),
    { FSTDEP010: H4, FSTDEP013: B4, FSTDEP019: K4, FSTDEP020: G4, FSTDEP021: J4 } = ts(),
    sR = Object.prototype.toString;
  function st(e, t, r) {
    (this.raw = e),
      (this[ns] = null),
      (this[eR] = !1),
      (this[Sc] = !1),
      (this[Hp] = !1),
      (this.request = t),
      (this[ct] = {}),
      (this[Ut] = null),
      (this[Up] = !1),
      (this[Ta] = void 0),
      (this.log = r);
  }
  st.props = [];
  Object.defineProperties(st.prototype, {
    [ke]: {
      get() {
        return this.request[ke];
      },
    },
    context: {
      get() {
        return K4(), this.request[ke];
      },
    },
    elapsedTime: {
      get() {
        return this[Ta] === void 0 ? 0 : (this[Vp] || zp()) - this[Ta];
      },
    },
    server: {
      get() {
        return this.request[ke].server;
      },
    },
    sent: {
      enumerable: !0,
      get() {
        return (this[Ra] || this.raw.writableEnded) === !0;
      },
      set(e) {
        if ((H4(), e !== !0)) throw new L4();
        if (this.sent && this[Ra]) throw new nR(this.request.url, this.request.method);
        this[Ra] = !0;
      },
    },
    statusCode: {
      get() {
        return this.raw.statusCode;
      },
      set(e) {
        this.code(e);
      },
    },
    [KE]: {
      get() {
        return this.request[KE];
      },
    },
  });
  st.prototype.hijack = function () {
    return (this[Ra] = !0), this;
  };
  st.prototype.send = function (e) {
    if (this[Hp] === !0) throw new x4();
    if (this.sent)
      return this.log.warn({ err: new nR(this.request.url, this.request.method) }), this;
    if (e instanceof Error || this[Sc] === !0) return (this[Sc] = !1), Pa(this, e, mi), this;
    if (e === void 0) return mi(this, e), this;
    let t = this.getHeader("content-type"),
      r = t !== void 0;
    if (e !== null) {
      if (
        typeof e.pipe == "function" ||
        typeof e.getReader == "function" ||
        sR.call(e) === "[object Response]"
      )
        return mi(this, e), this;
      if (e?.buffer instanceof ArrayBuffer) {
        r === !1 && (this[ct]["content-type"] = xp.OCTET);
        let n = Buffer.isBuffer(e) ? e : Buffer.from(e.buffer, e.byteOffset, e.byteLength);
        return mi(this, n), this;
      }
      if (r === !1 && typeof e == "string")
        return (this[ct]["content-type"] = xp.PLAIN), mi(this, e), this;
    }
    if (this[ns] !== null) {
      if (typeof e != "string") return QE(this, e), this;
      e = this[ns](e);
    } else if (r === !1 || t.indexOf("json") > -1) {
      if (r === !1) this[ct]["content-type"] = xp.JSON;
      else if (t.indexOf("charset") === -1) {
        let n = t.trim();
        n.endsWith(";")
          ? (this[ct]["content-type"] = `${n} charset=utf-8`)
          : (this[ct]["content-type"] = `${n}; charset=utf-8`);
      }
      if (typeof e != "string") return QE(this, e), this;
    }
    return mi(this, e), this;
  };
  st.prototype.getHeader = function (e) {
    e = e.toLowerCase();
    let t = this.raw,
      r = this[ct][e];
    return r === void 0 && t.hasHeader(e) && (r = t.getHeader(e)), r;
  };
  st.prototype.getHeaders = function () {
    return { ...this.raw.getHeaders(), ...this[ct] };
  };
  st.prototype.hasHeader = function (e) {
    return (e = e.toLowerCase()), this[ct][e] !== void 0 || this.raw.hasHeader(e);
  };
  st.prototype.removeHeader = function (e) {
    return delete this[ct][e.toLowerCase()], this;
  };
  st.prototype.header = function (e, t = "") {
    return (
      (e = e.toLowerCase()),
      this[ct][e] && e === "set-cookie"
        ? (typeof this[ct][e] == "string" && (this[ct][e] = [this[ct][e]]),
          Array.isArray(t) ? Array.prototype.push.apply(this[ct][e], t) : this[ct][e].push(t))
        : (this[ct][e] = t),
      this
    );
  };
  st.prototype.headers = function (e) {
    let t = Object.keys(e);
    for (var r = 0; r !== t.length; ++r) {
      let n = t[r];
      this.header(n, e[n]);
    }
    return this;
  };
  var Q4 = new Set([
    "transfer-encoding",
    "content-length",
    "host",
    "cache-control",
    "max-forwards",
    "te",
    "authorization",
    "set-cookie",
    "content-encoding",
    "content-type",
    "content-range",
    "trailer",
  ]);
  st.prototype.trailer = function (e, t) {
    if (((e = e.toLowerCase()), Q4.has(e))) throw new M4(e);
    if (typeof t != "function") throw new z4(e, typeof t);
    return this[Ut] === null && (this[Ut] = {}), (this[Ut][e] = t), this;
  };
  st.prototype.hasTrailer = function (e) {
    return this[Ut]?.[e.toLowerCase()] !== void 0;
  };
  st.prototype.removeTrailer = function (e) {
    return this[Ut] === null ? this : ((this[Ut][e.toLowerCase()] = void 0), this);
  };
  st.prototype.code = function (e) {
    let t = Number(e);
    if (isNaN(t) || t < 100 || t > 599) throw new F4(e || String(e));
    return (this.raw.statusCode = t), (this[Up] = !0), this;
  };
  st.prototype.status = st.prototype.code;
  st.prototype.getSerializationFunction = function (e, t) {
    let r;
    return (
      typeof e == "string" || typeof e == "number"
        ? typeof t == "string"
          ? (r = this[ke][vc]?.[e]?.[t])
          : (r = this[ke][vc]?.[e])
        : typeof e == "object" && (r = this[ke][ks]?.get(e)),
      r
    );
  };
  st.prototype.compileSerializationSchema = function (e, t = null, r = null) {
    let { request: n } = this,
      { method: s, url: i } = n;
    if (this[ke][ks]?.has(e)) return this[ke][ks].get(e);
    let a = (
      this[ke].serializerCompiler ||
      this.server[Lp].serializerCompiler ||
      this.server[Lp].setupSerializer(this.server[N4]) ||
      this.server[Lp].serializerCompiler
    )({ schema: e, method: s, url: i, httpStatus: t, contentType: r });
    return this[ke][ks] == null && (this[ke][ks] = new WeakMap()), this[ke][ks].set(e, a), a;
  };
  st.prototype.serializeInput = function (e, t, r, n) {
    let s = r,
      i;
    if (
      ((r = typeof t == "string" || typeof t == "number" ? t : r),
      (n = r && s !== r ? s : n),
      r != null)
    ) {
      if ((n != null ? (i = this[ke][vc]?.[r]?.[n]) : (i = this[ke][vc]?.[r]), i == null))
        throw n ? new U4(r, n) : new V4(r);
    } else
      this[ke][ks]?.has(t)
        ? (i = this[ke][ks].get(t))
        : (i = this.compileSerializationSchema(t, r, n));
    return i(e);
  };
  st.prototype.serialize = function (e) {
    return this[ns] !== null
      ? this[ns](e)
      : this[ke] && this[ke][_c]
        ? this[ke][_c](e, this.raw.statusCode)
        : aR(this[ke], e, this.raw.statusCode);
  };
  st.prototype.serializer = function (e) {
    return (this[ns] = e), this;
  };
  st.prototype.type = function (e) {
    return (this[ct]["content-type"] = e), this;
  };
  st.prototype.redirect = function (e, t) {
    if (typeof e == "number") {
      J4();
      let r = t;
      (t = e), (e = r);
    }
    return (
      t || (t = this[Up] ? this.raw.statusCode : 302), this.header("location", e).code(t).send()
    );
  };
  st.prototype.callNotFound = function () {
    return tU(this), this;
  };
  st.prototype.getResponseTime = function () {
    return G4(), this.elapsedTime;
  };
  st.prototype.then = function (e, t) {
    if (this.sent) {
      e();
      return;
    }
    Mp(this.raw, (r) => {
      r && r.code !== "ERR_STREAM_PREMATURE_CLOSE"
        ? t
          ? t(r)
          : this.log && this.log.warn("unhandled rejection on reply.then")
        : e();
    });
  };
  function QE(e, t) {
    e[ke].preSerialization !== null
      ? C4(e[ke].preSerialization, e.request, e, t, WE)
      : WE(null, e.request, e, t);
  }
  function WE(e, t, r, n) {
    if (e != null) {
      Pa(r, e);
      return;
    }
    try {
      r[ns] !== null
        ? (n = r[ns](n))
        : r[ke] && r[ke][_c]
          ? (n = r[ke][_c](n, r.raw.statusCode))
          : (n = aR(r[ke], n, r.raw.statusCode, r[ct]["content-type"]));
    } catch (s) {
      W4(s, r), Pa(r, s);
      return;
    }
    mi(r, n);
  }
  function W4(e, t) {
    e.serialization = t[ke].config;
  }
  function mi(e, t) {
    e[ke].onSend !== null ? rR(e[ke].onSend, e.request, e, t, Y4) : iR(e, t);
  }
  function Y4(e, t, r, n) {
    e != null ? Pa(r, e) : iR(r, n);
  }
  function Fp(e, t) {
    let r = e.raw;
    try {
      r.writeHead(t, e[ct]);
    } catch (n) {
      throw (
        (n.code === "ERR_HTTP_HEADERS_SENT" &&
          e.log.warn(
            `Reply was already sent, did you forget to "return reply" in the "${e.request.raw.url}" (${e.request.raw.method}) route?`,
          ),
        n)
      );
    }
  }
  function iR(e, t) {
    let r = e.raw,
      n = e.request;
    if (e[Ut] !== null) {
      let o = Object.keys(e[Ut]),
        a = "";
      for (let u of o) typeof e[Ut][u] == "function" && ((a += " "), (a += u));
      e.header("Transfer-Encoding", "chunked"), e.header("Trailer", a.trim());
    }
    let s = sR.call(t) === "[object Response]";
    s && typeof t.status == "number" && e.code(t.status);
    let i = r.statusCode;
    if (t == null) {
      i >= 200 &&
        i !== 204 &&
        i !== 304 &&
        n.method !== "HEAD" &&
        e[Ut] === null &&
        (e[ct]["content-length"] = "0"),
        Fp(e, i),
        gc(t, r, e);
      return;
    }
    if ((i >= 100 && i < 200) || i === 204) {
      e.removeHeader("content-type"),
        e.removeHeader("content-length"),
        Fp(e, i),
        gc(void 0, r, e),
        typeof t.resume == "function" && (t.on("error", uR), t.resume());
      return;
    }
    if (typeof t.pipe == "function") {
      oR(t, r, e);
      return;
    }
    if (typeof t.getReader == "function") {
      XE(t, r, e);
      return;
    }
    if (s) {
      if (typeof t.headers == "object" && typeof t.headers.forEach == "function")
        for (let [o, a] of t.headers) e.header(o, a);
      if (t.body != null) {
        if (t.bodyUsed) throw new j4();
        XE(t.body, r, e);
      }
      return;
    }
    if (typeof t != "string" && !Buffer.isBuffer(t)) throw new q4(typeof t);
    if (e[Ut] === null) {
      let o = e[ct]["content-length"];
      (!o || (n.raw.method !== "HEAD" && Number(o) !== Buffer.byteLength(t))) &&
        (e[ct]["content-length"] = "" + Buffer.byteLength(t));
    }
    Fp(e, i), r.write(t), gc(t, r, e);
  }
  function YE(e, t, r) {
    t.code === "ERR_STREAM_PREMATURE_CLOSE"
      ? e[tR] || e.info({ res: r }, "stream closed prematurely")
      : e.warn({ err: t }, "response terminated with an error with headers already sent");
  }
  function XE(e, t, r) {
    let n = $4.fromWeb(e);
    oR(n, t, r);
  }
  function oR(e, t, r) {
    let n = !0,
      s = !1;
    if (
      (X4(e, t, r),
      Mp(e, { readable: !0, writable: !1 }, function (i) {
        (n = !1),
          i != null &&
            (t.headersSent || r.request.raw.aborted === !0
              ? (s || ((s = !0), YE(r.log, i, t)), t.destroy())
              : Pa(r, i));
      }),
      Mp(t, function (i) {
        n &&
          (i != null && t.headersSent && !s && ((s = !0), YE(r.log, i, t)),
          typeof e.destroy == "function"
            ? e.destroy()
            : typeof e.close == "function"
              ? e.close(uR)
              : typeof e.abort == "function"
                ? e.abort()
                : r.log.warn("stream payload does not end properly"));
      }),
      t.headersSent)
    )
      r.log.warn("response will send, but you shouldn't use res.writeHead in stream mode");
    else for (let i in r[ct]) t.setHeader(i, r[ct][i]);
    e.pipe(t);
  }
  function gc(e, t, r) {
    if (r[Ut] === null) {
      t.end(null, null, null);
      return;
    }
    let n = Object.keys(r[Ut]),
      s = {},
      i = 0,
      o = !0;
    function a() {
      i === 0 && (t.addTrailers(s), t.end(null, null, null));
    }
    for (let u of n) {
      let l = function (f, d) {
        i++, f ? r.log.debug(f) : (s[u] = d), process.nextTick(a);
      };
      if (typeof r[Ut][u] != "function") continue;
      (o = !1), i--;
      let c = r[Ut][u](r, e, l);
      typeof c == "object" && typeof c.then == "function"
        ? c.then((f) => l(null, f), l)
        : c != null && (B4(), l(null, c));
    }
    o && t.end(null, null, null);
  }
  function X4(e, t, r) {
    r[Ut] !== null && e.on("end", () => gc(null, t, r));
  }
  function Pa(e, t, r) {
    e[ke].onError !== null && !e[O4]
      ? ((e[Hp] = !0), rR(e[ke].onError, e.request, e, t, () => JE(e, t, r)))
      : JE(e, t, r);
  }
  function Z4(e) {
    e[Ta] = zp();
    let t = (r) => {
      (e[Vp] = zp()), e.raw.removeListener("finish", t), e.raw.removeListener("error", t);
      let n = e[ke];
      n && n.onResponse !== null ? A4(n.onResponse, e.request, e, ZE) : ZE(r, e.request, e);
    };
    e.raw.on("finish", t), e.raw.on("error", t);
  }
  function ZE(e, t, r) {
    if (r.log[tR]) return;
    let n = r.elapsedTime;
    if (e != null) {
      r.log.error({ res: r, err: e, responseTime: n }, "request errored");
      return;
    }
    r.log.info({ res: r, responseTime: n }, "request completed");
  }
  function eU(e) {
    let t = e.props.slice();
    function r(n, s, i) {
      (this.raw = n),
        (this[Sc] = !1),
        (this[eR] = !1),
        (this[Ra] = !1),
        (this[ns] = null),
        (this.request = s),
        (this[ct] = {}),
        (this[Ut] = null),
        (this[Ta] = void 0),
        (this[Vp] = void 0),
        (this.log = i);
      for (var o, a = 0; a < t.length; a++) (o = t[a]), (this[o.key] = o.value);
    }
    return (
      Object.setPrototypeOf(r.prototype, e.prototype),
      Object.setPrototypeOf(r, e),
      (r.parent = e),
      (r.props = t),
      r
    );
  }
  function tU(e) {
    if (e[ke][BE] === null) {
      e.log.warn(
        "Trying to send a NotFound error inside a 404 handler. Sending basic 404 response.",
      ),
        e.code(404).send("404 Not Found");
      return;
    }
    (e.request[ke] = e[ke][BE]),
      e[ke].preHandler !== null
        ? I4(e[ke].preHandler, e.request, e, GE.preHandlerCallback)
        : GE.preHandlerCallback(null, e.request, e);
  }
  function aR(e, t, r, n) {
    let s = D4(e, r, n);
    return s ? s(t) : JSON.stringify(t);
  }
  function uR() {}
  bc.exports = st;
  bc.exports.buildReply = eU;
  bc.exports.setupResponseListeners = Z4;
});
var cR = b((Rse, lR) => {
  "use strict";
  lR.exports = rU;
  function rU(e) {
    if (!e) throw new TypeError("argument req is required");
    var t = sU(e.headers["x-forwarded-for"] || ""),
      r = nU(e),
      n = [r].concat(t);
    return n;
  }
  function nU(e) {
    return e.socket ? e.socket.remoteAddress : e.connection.remoteAddress;
  }
  function sU(e) {
    for (var t = e.length, r = [], n = e.length, s = e.length - 1; s >= 0; s--)
      switch (e.charCodeAt(s)) {
        case 32:
          n === t && (n = t = s);
          break;
        case 44:
          n !== t && r.push(e.substring(n, t)), (n = t = s);
          break;
        default:
          n = s;
          break;
      }
    return n !== t && r.push(e.substring(n, t)), r;
  }
});
var dR = b((fR, $a) => {
  (function () {
    var e, t, r, n, s, i, o, a, u;
    (t = {}),
      (a = this),
      typeof $a < "u" && $a !== null && $a.exports ? ($a.exports = t) : (a.ipaddr = t),
      (o = function (l, c, f, d) {
        var h, p;
        if (l.length !== c.length)
          throw new Error("ipaddr: cannot match CIDR for objects with different lengths");
        for (h = 0; d > 0; ) {
          if (((p = f - d), p < 0 && (p = 0), l[h] >> p !== c[h] >> p)) return !1;
          (d -= f), (h += 1);
        }
        return !0;
      }),
      (t.subnetMatch = function (l, c, f) {
        var d, h, p, y, _;
        f == null && (f = "unicast");
        for (p in c)
          for (
            y = c[p], y[0] && !(y[0] instanceof Array) && (y = [y]), d = 0, h = y.length;
            d < h;
            d++
          )
            if (((_ = y[d]), l.kind() === _[0].kind() && l.match.apply(l, _))) return p;
        return f;
      }),
      (t.IPv4 = (function () {
        function l(c) {
          var f, d, h;
          if (c.length !== 4) throw new Error("ipaddr: ipv4 octet count should be 4");
          for (f = 0, d = c.length; f < d; f++)
            if (((h = c[f]), !(0 <= h && h <= 255)))
              throw new Error("ipaddr: ipv4 octet should fit in 8 bits");
          this.octets = c;
        }
        return (
          (l.prototype.kind = function () {
            return "ipv4";
          }),
          (l.prototype.toString = function () {
            return this.octets.join(".");
          }),
          (l.prototype.toNormalizedString = function () {
            return this.toString();
          }),
          (l.prototype.toByteArray = function () {
            return this.octets.slice(0);
          }),
          (l.prototype.match = function (c, f) {
            var d;
            if ((f === void 0 && ((d = c), (c = d[0]), (f = d[1])), c.kind() !== "ipv4"))
              throw new Error("ipaddr: cannot match ipv4 address with non-ipv4 one");
            return o(this.octets, c.octets, 8, f);
          }),
          (l.prototype.SpecialRanges = {
            unspecified: [[new l([0, 0, 0, 0]), 8]],
            broadcast: [[new l([255, 255, 255, 255]), 32]],
            multicast: [[new l([224, 0, 0, 0]), 4]],
            linkLocal: [[new l([169, 254, 0, 0]), 16]],
            loopback: [[new l([127, 0, 0, 0]), 8]],
            carrierGradeNat: [[new l([100, 64, 0, 0]), 10]],
            private: [
              [new l([10, 0, 0, 0]), 8],
              [new l([172, 16, 0, 0]), 12],
              [new l([192, 168, 0, 0]), 16],
            ],
            reserved: [
              [new l([192, 0, 0, 0]), 24],
              [new l([192, 0, 2, 0]), 24],
              [new l([192, 88, 99, 0]), 24],
              [new l([198, 51, 100, 0]), 24],
              [new l([203, 0, 113, 0]), 24],
              [new l([240, 0, 0, 0]), 4],
            ],
          }),
          (l.prototype.range = function () {
            return t.subnetMatch(this, this.SpecialRanges);
          }),
          (l.prototype.toIPv4MappedAddress = function () {
            return t.IPv6.parse("::ffff:" + this.toString());
          }),
          (l.prototype.prefixLengthFromSubnetMask = function () {
            var c, f, d, h, p, y, _;
            for (
              _ = { 0: 8, 128: 7, 192: 6, 224: 5, 240: 4, 248: 3, 252: 2, 254: 1, 255: 0 },
                c = 0,
                p = !1,
                f = d = 3;
              d >= 0;
              f = d += -1
            )
              if (((h = this.octets[f]), h in _)) {
                if (((y = _[h]), p && y !== 0)) return null;
                y !== 8 && (p = !0), (c += y);
              } else return null;
            return 32 - c;
          }),
          l
        );
      })()),
      (r = "(0?\\d+|0x[a-f0-9]+)"),
      (n = {
        fourOctet: new RegExp("^" + r + "\\." + r + "\\." + r + "\\." + r + "$", "i"),
        longValue: new RegExp("^" + r + "$", "i"),
      }),
      (t.IPv4.parser = function (l) {
        var c, f, d, h, p;
        if (
          ((f = function (y) {
            return y[0] === "0" && y[1] !== "x" ? parseInt(y, 8) : parseInt(y);
          }),
          (c = l.match(n.fourOctet)))
        )
          return (function () {
            var y, _, S, E;
            for (S = c.slice(1, 6), E = [], y = 0, _ = S.length; y < _; y++)
              (d = S[y]), E.push(f(d));
            return E;
          })();
        if ((c = l.match(n.longValue))) {
          if (((p = f(c[1])), p > 4294967295 || p < 0))
            throw new Error("ipaddr: address outside defined range");
          return (function () {
            var y, _;
            for (_ = [], h = y = 0; y <= 24; h = y += 8) _.push((p >> h) & 255);
            return _;
          })().reverse();
        } else return null;
      }),
      (t.IPv6 = (function () {
        function l(c, f) {
          var d, h, p, y, _, S;
          if (c.length === 16)
            for (this.parts = [], d = h = 0; h <= 14; d = h += 2)
              this.parts.push((c[d] << 8) | c[d + 1]);
          else if (c.length === 8) this.parts = c;
          else throw new Error("ipaddr: ipv6 part count should be 8 or 16");
          for (S = this.parts, p = 0, y = S.length; p < y; p++)
            if (((_ = S[p]), !(0 <= _ && _ <= 65535)))
              throw new Error("ipaddr: ipv6 part should fit in 16 bits");
          f && (this.zoneId = f);
        }
        return (
          (l.prototype.kind = function () {
            return "ipv6";
          }),
          (l.prototype.toString = function () {
            return this.toNormalizedString().replace(/((^|:)(0(:|$))+)/, "::");
          }),
          (l.prototype.toRFC5952String = function () {
            var c, f, d, h, p;
            for (
              h = /((^|:)(0(:|$)){2,})/g, p = this.toNormalizedString(), c = 0, f = -1;
              (d = h.exec(p));

            )
              d[0].length > f && ((c = d.index), (f = d[0].length));
            return f < 0 ? p : p.substring(0, c) + "::" + p.substring(c + f);
          }),
          (l.prototype.toByteArray = function () {
            var c, f, d, h, p;
            for (c = [], p = this.parts, f = 0, d = p.length; f < d; f++)
              (h = p[f]), c.push(h >> 8), c.push(h & 255);
            return c;
          }),
          (l.prototype.toNormalizedString = function () {
            var c, f, d;
            return (
              (c = function () {
                var h, p, y, _;
                for (y = this.parts, _ = [], h = 0, p = y.length; h < p; h++)
                  (f = y[h]), _.push(f.toString(16));
                return _;
              }
                .call(this)
                .join(":")),
              (d = ""),
              this.zoneId && (d = "%" + this.zoneId),
              c + d
            );
          }),
          (l.prototype.toFixedLengthString = function () {
            var c, f, d;
            return (
              (c = function () {
                var h, p, y, _;
                for (y = this.parts, _ = [], h = 0, p = y.length; h < p; h++)
                  (f = y[h]), _.push(f.toString(16).padStart(4, "0"));
                return _;
              }
                .call(this)
                .join(":")),
              (d = ""),
              this.zoneId && (d = "%" + this.zoneId),
              c + d
            );
          }),
          (l.prototype.match = function (c, f) {
            var d;
            if ((f === void 0 && ((d = c), (c = d[0]), (f = d[1])), c.kind() !== "ipv6"))
              throw new Error("ipaddr: cannot match ipv6 address with non-ipv6 one");
            return o(this.parts, c.parts, 16, f);
          }),
          (l.prototype.SpecialRanges = {
            unspecified: [new l([0, 0, 0, 0, 0, 0, 0, 0]), 128],
            linkLocal: [new l([65152, 0, 0, 0, 0, 0, 0, 0]), 10],
            multicast: [new l([65280, 0, 0, 0, 0, 0, 0, 0]), 8],
            loopback: [new l([0, 0, 0, 0, 0, 0, 0, 1]), 128],
            uniqueLocal: [new l([64512, 0, 0, 0, 0, 0, 0, 0]), 7],
            ipv4Mapped: [new l([0, 0, 0, 0, 0, 65535, 0, 0]), 96],
            rfc6145: [new l([0, 0, 0, 0, 65535, 0, 0, 0]), 96],
            rfc6052: [new l([100, 65435, 0, 0, 0, 0, 0, 0]), 96],
            "6to4": [new l([8194, 0, 0, 0, 0, 0, 0, 0]), 16],
            teredo: [new l([8193, 0, 0, 0, 0, 0, 0, 0]), 32],
            reserved: [[new l([8193, 3512, 0, 0, 0, 0, 0, 0]), 32]],
          }),
          (l.prototype.range = function () {
            return t.subnetMatch(this, this.SpecialRanges);
          }),
          (l.prototype.isIPv4MappedAddress = function () {
            return this.range() === "ipv4Mapped";
          }),
          (l.prototype.toIPv4Address = function () {
            var c, f, d;
            if (!this.isIPv4MappedAddress())
              throw new Error("ipaddr: trying to convert a generic ipv6 address to ipv4");
            return (
              (d = this.parts.slice(-2)),
              (c = d[0]),
              (f = d[1]),
              new t.IPv4([c >> 8, c & 255, f >> 8, f & 255])
            );
          }),
          (l.prototype.prefixLengthFromSubnetMask = function () {
            var c, f, d, h, p, y, _;
            for (
              _ = {
                0: 16,
                32768: 15,
                49152: 14,
                57344: 13,
                61440: 12,
                63488: 11,
                64512: 10,
                65024: 9,
                65280: 8,
                65408: 7,
                65472: 6,
                65504: 5,
                65520: 4,
                65528: 3,
                65532: 2,
                65534: 1,
                65535: 0,
              },
                c = 0,
                p = !1,
                f = d = 7;
              d >= 0;
              f = d += -1
            )
              if (((h = this.parts[f]), h in _)) {
                if (((y = _[h]), p && y !== 0)) return null;
                y !== 16 && (p = !0), (c += y);
              } else return null;
            return 128 - c;
          }),
          l
        );
      })()),
      (s = "(?:[0-9a-f]+::?)+"),
      (u = "%[0-9a-z]{1,}"),
      (i = {
        zoneIndex: new RegExp(u, "i"),
        native: new RegExp("^(::)?(" + s + ")?([0-9a-f]+)?(::)?(" + u + ")?$", "i"),
        transitional: new RegExp(
          "^((?:" +
            s +
            ")|(?:::)(?:" +
            s +
            ")?)" +
            (r + "\\." + r + "\\." + r + "\\." + r) +
            ("(" + u + ")?$"),
          "i",
        ),
      }),
      (e = function (l, c) {
        var f, d, h, p, y, _;
        if (l.indexOf("::") !== l.lastIndexOf("::")) return null;
        for (
          _ = (l.match(i.zoneIndex) || [])[0],
            _ && ((_ = _.substring(1)), (l = l.replace(/%.+$/, ""))),
            f = 0,
            d = -1;
          (d = l.indexOf(":", d + 1)) >= 0;

        )
          f++;
        if ((l.substr(0, 2) === "::" && f--, l.substr(-2, 2) === "::" && f--, f > c)) return null;
        for (y = c - f, p = ":"; y--; ) p += "0:";
        return (
          (l = l.replace("::", p)),
          l[0] === ":" && (l = l.slice(1)),
          l[l.length - 1] === ":" && (l = l.slice(0, -1)),
          (c = (function () {
            var S, E, g, m;
            for (g = l.split(":"), m = [], S = 0, E = g.length; S < E; S++)
              (h = g[S]), m.push(parseInt(h, 16));
            return m;
          })()),
          { parts: c, zoneId: _ }
        );
      }),
      (t.IPv6.parser = function (l) {
        var c, f, d, h, p, y, _;
        if (i.native.test(l)) return e(l, 8);
        if (
          (h = l.match(i.transitional)) &&
          ((_ = h[6] || ""), (c = e(h[1].slice(0, -1) + _, 6)), c.parts)
        ) {
          for (
            y = [parseInt(h[2]), parseInt(h[3]), parseInt(h[4]), parseInt(h[5])],
              f = 0,
              d = y.length;
            f < d;
            f++
          )
            if (((p = y[f]), !(0 <= p && p <= 255))) return null;
          return (
            c.parts.push((y[0] << 8) | y[1]),
            c.parts.push((y[2] << 8) | y[3]),
            { parts: c.parts, zoneId: c.zoneId }
          );
        }
        return null;
      }),
      (t.IPv4.isIPv4 = t.IPv6.isIPv6 =
        function (l) {
          return this.parser(l) !== null;
        }),
      (t.IPv4.isValid = function (l) {
        var c;
        try {
          return new this(this.parser(l)), !0;
        } catch (f) {
          return (c = f), !1;
        }
      }),
      (t.IPv4.isValidFourPartDecimal = function (l) {
        return !!(t.IPv4.isValid(l) && l.match(/^(0|[1-9]\d*)(\.(0|[1-9]\d*)){3}$/));
      }),
      (t.IPv6.isValid = function (l) {
        var c, f;
        if (typeof l == "string" && l.indexOf(":") === -1) return !1;
        try {
          return (c = this.parser(l)), new this(c.parts, c.zoneId), !0;
        } catch (d) {
          return (f = d), !1;
        }
      }),
      (t.IPv4.parse = function (l) {
        var c;
        if (((c = this.parser(l)), c === null))
          throw new Error("ipaddr: string is not formatted like ip address");
        return new this(c);
      }),
      (t.IPv6.parse = function (l) {
        var c;
        if (((c = this.parser(l)), c.parts === null))
          throw new Error("ipaddr: string is not formatted like ip address");
        return new this(c.parts, c.zoneId);
      }),
      (t.IPv4.parseCIDR = function (l) {
        var c, f, d;
        if ((f = l.match(/^(.+)\/(\d+)$/)) && ((c = parseInt(f[2])), c >= 0 && c <= 32))
          return (
            (d = [this.parse(f[1]), c]),
            Object.defineProperty(d, "toString", {
              value: function () {
                return this.join("/");
              },
            }),
            d
          );
        throw new Error("ipaddr: string is not formatted like an IPv4 CIDR range");
      }),
      (t.IPv4.subnetMaskFromPrefixLength = function (l) {
        var c, f, d;
        if (((l = parseInt(l)), l < 0 || l > 32))
          throw new Error("ipaddr: invalid IPv4 prefix length");
        for (d = [0, 0, 0, 0], f = 0, c = Math.floor(l / 8); f < c; ) (d[f] = 255), f++;
        return c < 4 && (d[c] = (Math.pow(2, l % 8) - 1) << (8 - (l % 8))), new this(d);
      }),
      (t.IPv4.broadcastAddressFromCIDR = function (l) {
        var c, f, d, h, p, y;
        try {
          for (
            c = this.parseCIDR(l),
              h = c[0].toByteArray(),
              y = this.subnetMaskFromPrefixLength(c[1]).toByteArray(),
              p = [],
              d = 0;
            d < 4;

          )
            p.push(parseInt(h[d], 10) | (parseInt(y[d], 10) ^ 255)), d++;
          return new this(p);
        } catch (_) {
          throw ((f = _), new Error("ipaddr: the address does not have IPv4 CIDR format"));
        }
      }),
      (t.IPv4.networkAddressFromCIDR = function (l) {
        var c, f, d, h, p, y;
        try {
          for (
            c = this.parseCIDR(l),
              h = c[0].toByteArray(),
              y = this.subnetMaskFromPrefixLength(c[1]).toByteArray(),
              p = [],
              d = 0;
            d < 4;

          )
            p.push(parseInt(h[d], 10) & parseInt(y[d], 10)), d++;
          return new this(p);
        } catch (_) {
          throw ((f = _), new Error("ipaddr: the address does not have IPv4 CIDR format"));
        }
      }),
      (t.IPv6.parseCIDR = function (l) {
        var c, f, d;
        if ((f = l.match(/^(.+)\/(\d+)$/)) && ((c = parseInt(f[2])), c >= 0 && c <= 128))
          return (
            (d = [this.parse(f[1]), c]),
            Object.defineProperty(d, "toString", {
              value: function () {
                return this.join("/");
              },
            }),
            d
          );
        throw new Error("ipaddr: string is not formatted like an IPv6 CIDR range");
      }),
      (t.isValid = function (l) {
        return t.IPv6.isValid(l) || t.IPv4.isValid(l);
      }),
      (t.parse = function (l) {
        if (t.IPv6.isValid(l)) return t.IPv6.parse(l);
        if (t.IPv4.isValid(l)) return t.IPv4.parse(l);
        throw new Error("ipaddr: the address has neither IPv6 nor IPv4 format");
      }),
      (t.parseCIDR = function (l) {
        var c;
        try {
          return t.IPv6.parseCIDR(l);
        } catch (f) {
          c = f;
          try {
            return t.IPv4.parseCIDR(l);
          } catch (d) {
            throw ((c = d), new Error("ipaddr: the address has neither IPv6 nor IPv4 CIDR format"));
          }
        }
      }),
      (t.fromByteArray = function (l) {
        var c;
        if (((c = l.length), c === 4)) return new t.IPv4(l);
        if (c === 16) return new t.IPv6(l);
        throw new Error("ipaddr: the binary input is neither an IPv6 nor IPv4 address");
      }),
      (t.process = function (l) {
        var c;
        return (
          (c = this.parse(l)),
          c.kind() === "ipv6" && c.isIPv4MappedAddress() ? c.toIPv4Address() : c
        );
      });
  }).call(fR);
});
var gR = b((Tse, Tc) => {
  "use strict";
  Tc.exports = fU;
  Tc.exports.all = mR;
  Tc.exports.compile = yR;
  var iU = cR(),
    pR = dR(),
    oU = /^[0-9]+$/,
    Ec = pR.isValid,
    Rc = pR.parse,
    hR = {
      linklocal: ["169.254.0.0/16", "fe80::/10"],
      loopback: ["127.0.0.1/8", "::1/128"],
      uniquelocal: ["10.0.0.0/8", "172.16.0.0/12", "192.168.0.0/16", "fc00::/7"],
    };
  function mR(e, t) {
    var r = iU(e);
    if (!t) return r;
    typeof t != "function" && (t = yR(t));
    for (var n = 0; n < r.length - 1; n++) t(r[n], n) || (r.length = n + 1);
    return r;
  }
  function yR(e) {
    if (!e) throw new TypeError("argument is required");
    var t;
    if (typeof e == "string") t = [e];
    else if (Array.isArray(e)) t = e.slice();
    else throw new TypeError("unsupported trust argument");
    for (var r = 0; r < t.length; r++)
      (e = t[r]),
        Object.prototype.hasOwnProperty.call(hR, e) &&
          ((e = hR[e]), t.splice.apply(t, [r, 1].concat(e)), (r += e.length - 1));
    return uU(aU(t));
  }
  function aU(e) {
    for (var t = new Array(e.length), r = 0; r < e.length; r++) t[r] = lU(e[r]);
    return t;
  }
  function uU(e) {
    var t = e.length;
    return t === 0 ? dU : t === 1 ? pU(e[0]) : hU(e);
  }
  function lU(e) {
    var t = e.lastIndexOf("/"),
      r = t !== -1 ? e.substring(0, t) : e;
    if (!Ec(r)) throw new TypeError("invalid IP address: " + r);
    var n = Rc(r);
    t === -1 && n.kind() === "ipv6" && n.isIPv4MappedAddress() && (n = n.toIPv4Address());
    var s = n.kind() === "ipv6" ? 128 : 32,
      i = t !== -1 ? e.substring(t + 1, e.length) : null;
    if (
      (i === null
        ? (i = s)
        : oU.test(i)
          ? (i = parseInt(i, 10))
          : n.kind() === "ipv4" && Ec(i)
            ? (i = cU(i))
            : (i = null),
      i <= 0 || i > s)
    )
      throw new TypeError("invalid range on address: " + e);
    return [n, i];
  }
  function cU(e) {
    var t = Rc(e),
      r = t.kind();
    return r === "ipv4" ? t.prefixLengthFromSubnetMask() : null;
  }
  function fU(e, t) {
    if (!e) throw new TypeError("req argument is required");
    if (!t) throw new TypeError("trust argument is required");
    var r = mR(e, t),
      n = r[r.length - 1];
    return n;
  }
  function dU() {
    return !1;
  }
  function hU(e) {
    return function (r) {
      if (!Ec(r)) return !1;
      for (var n = Rc(r), s, i = n.kind(), o = 0; o < e.length; o++) {
        var a = e[o],
          u = a[0],
          l = u.kind(),
          c = a[1],
          f = n;
        if (i !== l) {
          if (l === "ipv4" && !n.isIPv4MappedAddress()) continue;
          s || (s = l === "ipv4" ? n.toIPv4Address() : n.toIPv4MappedAddress()), (f = s);
        }
        if (f.match(u, c)) return !0;
      }
      return !1;
    };
  }
  function pU(e) {
    var t = e[0],
      r = t.kind(),
      n = r === "ipv4",
      s = e[1];
    return function (o) {
      if (!Ec(o)) return !1;
      var a = Rc(o),
        u = a.kind();
      if (u !== r) {
        if (n && !a.isIPv4MappedAddress()) return !1;
        a = n ? a.toIPv4Address() : a.toIPv4MappedAddress();
      }
      return a.match(t, s);
    };
  }
});
var Oa = b((Pse, _R) => {
  var mU = "2.0.0",
    yU = Number.MAX_SAFE_INTEGER || 9007199254740991,
    gU = 16,
    _U = 250,
    SU = ["major", "premajor", "minor", "preminor", "patch", "prepatch", "prerelease"];
  _R.exports = {
    MAX_LENGTH: 256,
    MAX_SAFE_COMPONENT_LENGTH: gU,
    MAX_SAFE_BUILD_LENGTH: _U,
    MAX_SAFE_INTEGER: yU,
    RELEASE_TYPES: SU,
    SEMVER_SPEC_VERSION: mU,
    FLAG_INCLUDE_PRERELEASE: 1,
    FLAG_LOOSE: 2,
  };
});
var Na = b(($se, SR) => {
  var vU =
    typeof process == "object" &&
    process.env &&
    process.env.NODE_DEBUG &&
    /\bsemver\b/i.test(process.env.NODE_DEBUG)
      ? (...e) => console.error("SEMVER", ...e)
      : () => {};
  SR.exports = vU;
});
var ao = b((ss, vR) => {
  var { MAX_SAFE_COMPONENT_LENGTH: Bp, MAX_SAFE_BUILD_LENGTH: bU, MAX_LENGTH: wU } = Oa(),
    EU = Na();
  ss = vR.exports = {};
  var RU = (ss.re = []),
    TU = (ss.safeRe = []),
    re = (ss.src = []),
    ne = (ss.t = {}),
    PU = 0,
    Kp = "[a-zA-Z0-9-]",
    $U = [
      ["\\s", 1],
      ["\\d", wU],
      [Kp, bU],
    ],
    OU = (e) => {
      for (let [t, r] of $U)
        e = e.split(`${t}*`).join(`${t}{0,${r}}`).split(`${t}+`).join(`${t}{1,${r}}`);
      return e;
    },
    $e = (e, t, r) => {
      let n = OU(t),
        s = PU++;
      EU(e, s, t),
        (ne[e] = s),
        (re[s] = t),
        (RU[s] = new RegExp(t, r ? "g" : void 0)),
        (TU[s] = new RegExp(n, r ? "g" : void 0));
    };
  $e("NUMERICIDENTIFIER", "0|[1-9]\\d*");
  $e("NUMERICIDENTIFIERLOOSE", "\\d+");
  $e("NONNUMERICIDENTIFIER", `\\d*[a-zA-Z-]${Kp}*`);
  $e(
    "MAINVERSION",
    `(${re[ne.NUMERICIDENTIFIER]})\\.(${re[ne.NUMERICIDENTIFIER]})\\.(${re[ne.NUMERICIDENTIFIER]})`,
  );
  $e(
    "MAINVERSIONLOOSE",
    `(${re[ne.NUMERICIDENTIFIERLOOSE]})\\.(${re[ne.NUMERICIDENTIFIERLOOSE]})\\.(${re[ne.NUMERICIDENTIFIERLOOSE]})`,
  );
  $e("PRERELEASEIDENTIFIER", `(?:${re[ne.NUMERICIDENTIFIER]}|${re[ne.NONNUMERICIDENTIFIER]})`);
  $e(
    "PRERELEASEIDENTIFIERLOOSE",
    `(?:${re[ne.NUMERICIDENTIFIERLOOSE]}|${re[ne.NONNUMERICIDENTIFIER]})`,
  );
  $e("PRERELEASE", `(?:-(${re[ne.PRERELEASEIDENTIFIER]}(?:\\.${re[ne.PRERELEASEIDENTIFIER]})*))`);
  $e(
    "PRERELEASELOOSE",
    `(?:-?(${re[ne.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${re[ne.PRERELEASEIDENTIFIERLOOSE]})*))`,
  );
  $e("BUILDIDENTIFIER", `${Kp}+`);
  $e("BUILD", `(?:\\+(${re[ne.BUILDIDENTIFIER]}(?:\\.${re[ne.BUILDIDENTIFIER]})*))`);
  $e("FULLPLAIN", `v?${re[ne.MAINVERSION]}${re[ne.PRERELEASE]}?${re[ne.BUILD]}?`);
  $e("FULL", `^${re[ne.FULLPLAIN]}$`);
  $e("LOOSEPLAIN", `[v=\\s]*${re[ne.MAINVERSIONLOOSE]}${re[ne.PRERELEASELOOSE]}?${re[ne.BUILD]}?`);
  $e("LOOSE", `^${re[ne.LOOSEPLAIN]}$`);
  $e("GTLT", "((?:<|>)?=?)");
  $e("XRANGEIDENTIFIERLOOSE", `${re[ne.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`);
  $e("XRANGEIDENTIFIER", `${re[ne.NUMERICIDENTIFIER]}|x|X|\\*`);
  $e(
    "XRANGEPLAIN",
    `[v=\\s]*(${re[ne.XRANGEIDENTIFIER]})(?:\\.(${re[ne.XRANGEIDENTIFIER]})(?:\\.(${re[ne.XRANGEIDENTIFIER]})(?:${re[ne.PRERELEASE]})?${re[ne.BUILD]}?)?)?`,
  );
  $e(
    "XRANGEPLAINLOOSE",
    `[v=\\s]*(${re[ne.XRANGEIDENTIFIERLOOSE]})(?:\\.(${re[ne.XRANGEIDENTIFIERLOOSE]})(?:\\.(${re[ne.XRANGEIDENTIFIERLOOSE]})(?:${re[ne.PRERELEASELOOSE]})?${re[ne.BUILD]}?)?)?`,
  );
  $e("XRANGE", `^${re[ne.GTLT]}\\s*${re[ne.XRANGEPLAIN]}$`);
  $e("XRANGELOOSE", `^${re[ne.GTLT]}\\s*${re[ne.XRANGEPLAINLOOSE]}$`);
  $e("COERCEPLAIN", `(^|[^\\d])(\\d{1,${Bp}})(?:\\.(\\d{1,${Bp}}))?(?:\\.(\\d{1,${Bp}}))?`);
  $e("COERCE", `${re[ne.COERCEPLAIN]}(?:$|[^\\d])`);
  $e(
    "COERCEFULL",
    re[ne.COERCEPLAIN] + `(?:${re[ne.PRERELEASE]})?(?:${re[ne.BUILD]})?(?:$|[^\\d])`,
  );
  $e("COERCERTL", re[ne.COERCE], !0);
  $e("COERCERTLFULL", re[ne.COERCEFULL], !0);
  $e("LONETILDE", "(?:~>?)");
  $e("TILDETRIM", `(\\s*)${re[ne.LONETILDE]}\\s+`, !0);
  ss.tildeTrimReplace = "$1~";
  $e("TILDE", `^${re[ne.LONETILDE]}${re[ne.XRANGEPLAIN]}$`);
  $e("TILDELOOSE", `^${re[ne.LONETILDE]}${re[ne.XRANGEPLAINLOOSE]}$`);
  $e("LONECARET", "(?:\\^)");
  $e("CARETTRIM", `(\\s*)${re[ne.LONECARET]}\\s+`, !0);
  ss.caretTrimReplace = "$1^";
  $e("CARET", `^${re[ne.LONECARET]}${re[ne.XRANGEPLAIN]}$`);
  $e("CARETLOOSE", `^${re[ne.LONECARET]}${re[ne.XRANGEPLAINLOOSE]}$`);
  $e("COMPARATORLOOSE", `^${re[ne.GTLT]}\\s*(${re[ne.LOOSEPLAIN]})$|^$`);
  $e("COMPARATOR", `^${re[ne.GTLT]}\\s*(${re[ne.FULLPLAIN]})$|^$`);
  $e("COMPARATORTRIM", `(\\s*)${re[ne.GTLT]}\\s*(${re[ne.LOOSEPLAIN]}|${re[ne.XRANGEPLAIN]})`, !0);
  ss.comparatorTrimReplace = "$1$2$3";
  $e("HYPHENRANGE", `^\\s*(${re[ne.XRANGEPLAIN]})\\s+-\\s+(${re[ne.XRANGEPLAIN]})\\s*$`);
  $e(
    "HYPHENRANGELOOSE",
    `^\\s*(${re[ne.XRANGEPLAINLOOSE]})\\s+-\\s+(${re[ne.XRANGEPLAINLOOSE]})\\s*$`,
  );
  $e("STAR", "(<|>)?=?\\s*\\*");
  $e("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$");
  $e("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
});
var Pc = b((Ose, bR) => {
  var NU = Object.freeze({ loose: !0 }),
    AU = Object.freeze({}),
    IU = (e) => (e ? (typeof e != "object" ? NU : e) : AU);
  bR.exports = IU;
});
var Gp = b((Nse, RR) => {
  var wR = /^[0-9]+$/,
    ER = (e, t) => {
      let r = wR.test(e),
        n = wR.test(t);
      return (
        r && n && ((e = +e), (t = +t)), e === t ? 0 : r && !n ? -1 : n && !r ? 1 : e < t ? -1 : 1
      );
    },
    CU = (e, t) => ER(t, e);
  RR.exports = { compareIdentifiers: ER, rcompareIdentifiers: CU };
});
var nr = b((Ase, OR) => {
  var $c = Na(),
    { MAX_LENGTH: TR, MAX_SAFE_INTEGER: Oc } = Oa(),
    { safeRe: PR, t: $R } = ao(),
    kU = Pc(),
    { compareIdentifiers: uo } = Gp(),
    Jp = class e {
      constructor(t, r) {
        if (((r = kU(r)), t instanceof e)) {
          if (t.loose === !!r.loose && t.includePrerelease === !!r.includePrerelease) return t;
          t = t.version;
        } else if (typeof t != "string")
          throw new TypeError(`Invalid version. Must be a string. Got type "${typeof t}".`);
        if (t.length > TR) throw new TypeError(`version is longer than ${TR} characters`);
        $c("SemVer", t, r),
          (this.options = r),
          (this.loose = !!r.loose),
          (this.includePrerelease = !!r.includePrerelease);
        let n = t.trim().match(r.loose ? PR[$R.LOOSE] : PR[$R.FULL]);
        if (!n) throw new TypeError(`Invalid Version: ${t}`);
        if (
          ((this.raw = t),
          (this.major = +n[1]),
          (this.minor = +n[2]),
          (this.patch = +n[3]),
          this.major > Oc || this.major < 0)
        )
          throw new TypeError("Invalid major version");
        if (this.minor > Oc || this.minor < 0) throw new TypeError("Invalid minor version");
        if (this.patch > Oc || this.patch < 0) throw new TypeError("Invalid patch version");
        n[4]
          ? (this.prerelease = n[4].split(".").map((s) => {
              if (/^[0-9]+$/.test(s)) {
                let i = +s;
                if (i >= 0 && i < Oc) return i;
              }
              return s;
            }))
          : (this.prerelease = []),
          (this.build = n[5] ? n[5].split(".") : []),
          this.format();
      }
      format() {
        return (
          (this.version = `${this.major}.${this.minor}.${this.patch}`),
          this.prerelease.length && (this.version += `-${this.prerelease.join(".")}`),
          this.version
        );
      }
      toString() {
        return this.version;
      }
      compare(t) {
        if (($c("SemVer.compare", this.version, this.options, t), !(t instanceof e))) {
          if (typeof t == "string" && t === this.version) return 0;
          t = new e(t, this.options);
        }
        return t.version === this.version ? 0 : this.compareMain(t) || this.comparePre(t);
      }
      compareMain(t) {
        return (
          t instanceof e || (t = new e(t, this.options)),
          uo(this.major, t.major) || uo(this.minor, t.minor) || uo(this.patch, t.patch)
        );
      }
      comparePre(t) {
        if (
          (t instanceof e || (t = new e(t, this.options)),
          this.prerelease.length && !t.prerelease.length)
        )
          return -1;
        if (!this.prerelease.length && t.prerelease.length) return 1;
        if (!this.prerelease.length && !t.prerelease.length) return 0;
        let r = 0;
        do {
          let n = this.prerelease[r],
            s = t.prerelease[r];
          if (($c("prerelease compare", r, n, s), n === void 0 && s === void 0)) return 0;
          if (s === void 0) return 1;
          if (n === void 0) return -1;
          if (n === s) continue;
          return uo(n, s);
        } while (++r);
      }
      compareBuild(t) {
        t instanceof e || (t = new e(t, this.options));
        let r = 0;
        do {
          let n = this.build[r],
            s = t.build[r];
          if (($c("build compare", r, n, s), n === void 0 && s === void 0)) return 0;
          if (s === void 0) return 1;
          if (n === void 0) return -1;
          if (n === s) continue;
          return uo(n, s);
        } while (++r);
      }
      inc(t, r, n) {
        switch (t) {
          case "premajor":
            (this.prerelease.length = 0),
              (this.patch = 0),
              (this.minor = 0),
              this.major++,
              this.inc("pre", r, n);
            break;
          case "preminor":
            (this.prerelease.length = 0), (this.patch = 0), this.minor++, this.inc("pre", r, n);
            break;
          case "prepatch":
            (this.prerelease.length = 0), this.inc("patch", r, n), this.inc("pre", r, n);
            break;
          case "prerelease":
            this.prerelease.length === 0 && this.inc("patch", r, n), this.inc("pre", r, n);
            break;
          case "major":
            (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) && this.major++,
              (this.minor = 0),
              (this.patch = 0),
              (this.prerelease = []);
            break;
          case "minor":
            (this.patch !== 0 || this.prerelease.length === 0) && this.minor++,
              (this.patch = 0),
              (this.prerelease = []);
            break;
          case "patch":
            this.prerelease.length === 0 && this.patch++, (this.prerelease = []);
            break;
          case "pre": {
            let s = Number(n) ? 1 : 0;
            if (!r && n === !1) throw new Error("invalid increment argument: identifier is empty");
            if (this.prerelease.length === 0) this.prerelease = [s];
            else {
              let i = this.prerelease.length;
              for (; --i >= 0; )
                typeof this.prerelease[i] == "number" && (this.prerelease[i]++, (i = -2));
              if (i === -1) {
                if (r === this.prerelease.join(".") && n === !1)
                  throw new Error("invalid increment argument: identifier already exists");
                this.prerelease.push(s);
              }
            }
            if (r) {
              let i = [r, s];
              n === !1 && (i = [r]),
                uo(this.prerelease[0], r) === 0
                  ? isNaN(this.prerelease[1]) && (this.prerelease = i)
                  : (this.prerelease = i);
            }
            break;
          }
          default:
            throw new Error(`invalid increment argument: ${t}`);
        }
        return (
          (this.raw = this.format()),
          this.build.length && (this.raw += `+${this.build.join(".")}`),
          this
        );
      }
    };
  OR.exports = Jp;
});
var yi = b((Ise, AR) => {
  var NR = nr(),
    DU = (e, t, r = !1) => {
      if (e instanceof NR) return e;
      try {
        return new NR(e, t);
      } catch (n) {
        if (!r) return null;
        throw n;
      }
    };
  AR.exports = DU;
});
var CR = b((Cse, IR) => {
  var qU = yi(),
    jU = (e, t) => {
      let r = qU(e, t);
      return r ? r.version : null;
    };
  IR.exports = jU;
});
var DR = b((kse, kR) => {
  var LU = yi(),
    xU = (e, t) => {
      let r = LU(e.trim().replace(/^[=v]+/, ""), t);
      return r ? r.version : null;
    };
  kR.exports = xU;
});
var LR = b((Dse, jR) => {
  var qR = nr(),
    FU = (e, t, r, n, s) => {
      typeof r == "string" && ((s = n), (n = r), (r = void 0));
      try {
        return new qR(e instanceof qR ? e.version : e, r).inc(t, n, s).version;
      } catch {
        return null;
      }
    };
  jR.exports = FU;
});
var MR = b((qse, FR) => {
  var xR = yi(),
    MU = (e, t) => {
      let r = xR(e, null, !0),
        n = xR(t, null, !0),
        s = r.compare(n);
      if (s === 0) return null;
      let i = s > 0,
        o = i ? r : n,
        a = i ? n : r,
        u = !!o.prerelease.length;
      if (!!a.prerelease.length && !u)
        return !a.patch && !a.minor ? "major" : o.patch ? "patch" : o.minor ? "minor" : "major";
      let c = u ? "pre" : "";
      return r.major !== n.major
        ? c + "major"
        : r.minor !== n.minor
          ? c + "minor"
          : r.patch !== n.patch
            ? c + "patch"
            : "prerelease";
    };
  FR.exports = MU;
});
var VR = b((jse, zR) => {
  var zU = nr(),
    VU = (e, t) => new zU(e, t).major;
  zR.exports = VU;
});
var HR = b((Lse, UR) => {
  var UU = nr(),
    HU = (e, t) => new UU(e, t).minor;
  UR.exports = HU;
});
var KR = b((xse, BR) => {
  var BU = nr(),
    KU = (e, t) => new BU(e, t).patch;
  BR.exports = KU;
});
var JR = b((Fse, GR) => {
  var GU = yi(),
    JU = (e, t) => {
      let r = GU(e, t);
      return r && r.prerelease.length ? r.prerelease : null;
    };
  GR.exports = JU;
});
var Xr = b((Mse, WR) => {
  var QR = nr(),
    QU = (e, t, r) => new QR(e, r).compare(new QR(t, r));
  WR.exports = QU;
});
var XR = b((zse, YR) => {
  var WU = Xr(),
    YU = (e, t, r) => WU(t, e, r);
  YR.exports = YU;
});
var eT = b((Vse, ZR) => {
  var XU = Xr(),
    ZU = (e, t) => XU(e, t, !0);
  ZR.exports = ZU;
});
var Nc = b((Use, rT) => {
  var tT = nr(),
    eH = (e, t, r) => {
      let n = new tT(e, r),
        s = new tT(t, r);
      return n.compare(s) || n.compareBuild(s);
    };
  rT.exports = eH;
});
var sT = b((Hse, nT) => {
  var tH = Nc(),
    rH = (e, t) => e.sort((r, n) => tH(r, n, t));
  nT.exports = rH;
});
var oT = b((Bse, iT) => {
  var nH = Nc(),
    sH = (e, t) => e.sort((r, n) => nH(n, r, t));
  iT.exports = sH;
});
var Aa = b((Kse, aT) => {
  var iH = Xr(),
    oH = (e, t, r) => iH(e, t, r) > 0;
  aT.exports = oH;
});
var Ac = b((Gse, uT) => {
  var aH = Xr(),
    uH = (e, t, r) => aH(e, t, r) < 0;
  uT.exports = uH;
});
var Qp = b((Jse, lT) => {
  var lH = Xr(),
    cH = (e, t, r) => lH(e, t, r) === 0;
  lT.exports = cH;
});
var Wp = b((Qse, cT) => {
  var fH = Xr(),
    dH = (e, t, r) => fH(e, t, r) !== 0;
  cT.exports = dH;
});
var Ic = b((Wse, fT) => {
  var hH = Xr(),
    pH = (e, t, r) => hH(e, t, r) >= 0;
  fT.exports = pH;
});
var Cc = b((Yse, dT) => {
  var mH = Xr(),
    yH = (e, t, r) => mH(e, t, r) <= 0;
  dT.exports = yH;
});
var Yp = b((Xse, hT) => {
  var gH = Qp(),
    _H = Wp(),
    SH = Aa(),
    vH = Ic(),
    bH = Ac(),
    wH = Cc(),
    EH = (e, t, r, n) => {
      switch (t) {
        case "===":
          return (
            typeof e == "object" && (e = e.version),
            typeof r == "object" && (r = r.version),
            e === r
          );
        case "!==":
          return (
            typeof e == "object" && (e = e.version),
            typeof r == "object" && (r = r.version),
            e !== r
          );
        case "":
        case "=":
        case "==":
          return gH(e, r, n);
        case "!=":
          return _H(e, r, n);
        case ">":
          return SH(e, r, n);
        case ">=":
          return vH(e, r, n);
        case "<":
          return bH(e, r, n);
        case "<=":
          return wH(e, r, n);
        default:
          throw new TypeError(`Invalid operator: ${t}`);
      }
    };
  hT.exports = EH;
});
var mT = b((Zse, pT) => {
  var RH = nr(),
    TH = yi(),
    { safeRe: kc, t: Dc } = ao(),
    PH = (e, t) => {
      if (e instanceof RH) return e;
      if ((typeof e == "number" && (e = String(e)), typeof e != "string")) return null;
      t = t || {};
      let r = null;
      if (!t.rtl) r = e.match(t.includePrerelease ? kc[Dc.COERCEFULL] : kc[Dc.COERCE]);
      else {
        let u = t.includePrerelease ? kc[Dc.COERCERTLFULL] : kc[Dc.COERCERTL],
          l;
        for (; (l = u.exec(e)) && (!r || r.index + r[0].length !== e.length); )
          (!r || l.index + l[0].length !== r.index + r[0].length) && (r = l),
            (u.lastIndex = l.index + l[1].length + l[2].length);
        u.lastIndex = -1;
      }
      if (r === null) return null;
      let n = r[2],
        s = r[3] || "0",
        i = r[4] || "0",
        o = t.includePrerelease && r[5] ? `-${r[5]}` : "",
        a = t.includePrerelease && r[6] ? `+${r[6]}` : "";
      return TH(`${n}.${s}.${i}${o}${a}`, t);
    };
  pT.exports = PH;
});
var gT = b((eie, yT) => {
  var Xp = class {
    constructor() {
      (this.max = 1e3), (this.map = new Map());
    }
    get(t) {
      let r = this.map.get(t);
      if (r !== void 0) return this.map.delete(t), this.map.set(t, r), r;
    }
    delete(t) {
      return this.map.delete(t);
    }
    set(t, r) {
      if (!this.delete(t) && r !== void 0) {
        if (this.map.size >= this.max) {
          let s = this.map.keys().next().value;
          this.delete(s);
        }
        this.map.set(t, r);
      }
      return this;
    }
  };
  yT.exports = Xp;
});
var Zr = b((tie, bT) => {
  var Zp = class e {
    constructor(t, r) {
      if (((r = OH(r)), t instanceof e))
        return t.loose === !!r.loose && t.includePrerelease === !!r.includePrerelease
          ? t
          : new e(t.raw, r);
      if (t instanceof em) return (this.raw = t.value), (this.set = [[t]]), this.format(), this;
      if (
        ((this.options = r),
        (this.loose = !!r.loose),
        (this.includePrerelease = !!r.includePrerelease),
        (this.raw = t.trim().split(/\s+/).join(" ")),
        (this.set = this.raw
          .split("||")
          .map((n) => this.parseRange(n.trim()))
          .filter((n) => n.length)),
        !this.set.length)
      )
        throw new TypeError(`Invalid SemVer Range: ${this.raw}`);
      if (this.set.length > 1) {
        let n = this.set[0];
        if (((this.set = this.set.filter((s) => !ST(s[0]))), this.set.length === 0)) this.set = [n];
        else if (this.set.length > 1) {
          for (let s of this.set)
            if (s.length === 1 && qH(s[0])) {
              this.set = [s];
              break;
            }
        }
      }
      this.format();
    }
    format() {
      return (
        (this.range = this.set
          .map((t) => t.join(" ").trim())
          .join("||")
          .trim()),
        this.range
      );
    }
    toString() {
      return this.range;
    }
    parseRange(t) {
      let n = ((this.options.includePrerelease && kH) | (this.options.loose && DH)) + ":" + t,
        s = _T.get(n);
      if (s) return s;
      let i = this.options.loose,
        o = i ? Or[mr.HYPHENRANGELOOSE] : Or[mr.HYPHENRANGE];
      (t = t.replace(o, BH(this.options.includePrerelease))),
        yt("hyphen replace", t),
        (t = t.replace(Or[mr.COMPARATORTRIM], AH)),
        yt("comparator trim", t),
        (t = t.replace(Or[mr.TILDETRIM], IH)),
        yt("tilde trim", t),
        (t = t.replace(Or[mr.CARETTRIM], CH)),
        yt("caret trim", t);
      let a = t
        .split(" ")
        .map((f) => jH(f, this.options))
        .join(" ")
        .split(/\s+/)
        .map((f) => HH(f, this.options));
      i &&
        (a = a.filter(
          (f) => (yt("loose invalid filter", f, this.options), !!f.match(Or[mr.COMPARATORLOOSE])),
        )),
        yt("range list", a);
      let u = new Map(),
        l = a.map((f) => new em(f, this.options));
      for (let f of l) {
        if (ST(f)) return [f];
        u.set(f.value, f);
      }
      u.size > 1 && u.has("") && u.delete("");
      let c = [...u.values()];
      return _T.set(n, c), c;
    }
    intersects(t, r) {
      if (!(t instanceof e)) throw new TypeError("a Range is required");
      return this.set.some(
        (n) =>
          vT(n, r) &&
          t.set.some((s) => vT(s, r) && n.every((i) => s.every((o) => i.intersects(o, r)))),
      );
    }
    test(t) {
      if (!t) return !1;
      if (typeof t == "string")
        try {
          t = new NH(t, this.options);
        } catch {
          return !1;
        }
      for (let r = 0; r < this.set.length; r++) if (KH(this.set[r], t, this.options)) return !0;
      return !1;
    }
  };
  bT.exports = Zp;
  var $H = gT(),
    _T = new $H(),
    OH = Pc(),
    em = Ia(),
    yt = Na(),
    NH = nr(),
    {
      safeRe: Or,
      t: mr,
      comparatorTrimReplace: AH,
      tildeTrimReplace: IH,
      caretTrimReplace: CH,
    } = ao(),
    { FLAG_INCLUDE_PRERELEASE: kH, FLAG_LOOSE: DH } = Oa(),
    ST = (e) => e.value === "<0.0.0-0",
    qH = (e) => e.value === "",
    vT = (e, t) => {
      let r = !0,
        n = e.slice(),
        s = n.pop();
      for (; r && n.length; ) (r = n.every((i) => s.intersects(i, t))), (s = n.pop());
      return r;
    },
    jH = (e, t) => (
      yt("comp", e, t),
      (e = FH(e, t)),
      yt("caret", e),
      (e = LH(e, t)),
      yt("tildes", e),
      (e = zH(e, t)),
      yt("xrange", e),
      (e = UH(e, t)),
      yt("stars", e),
      e
    ),
    yr = (e) => !e || e.toLowerCase() === "x" || e === "*",
    LH = (e, t) =>
      e
        .trim()
        .split(/\s+/)
        .map((r) => xH(r, t))
        .join(" "),
    xH = (e, t) => {
      let r = t.loose ? Or[mr.TILDELOOSE] : Or[mr.TILDE];
      return e.replace(r, (n, s, i, o, a) => {
        yt("tilde", e, n, s, i, o, a);
        let u;
        return (
          yr(s)
            ? (u = "")
            : yr(i)
              ? (u = `>=${s}.0.0 <${+s + 1}.0.0-0`)
              : yr(o)
                ? (u = `>=${s}.${i}.0 <${s}.${+i + 1}.0-0`)
                : a
                  ? (yt("replaceTilde pr", a), (u = `>=${s}.${i}.${o}-${a} <${s}.${+i + 1}.0-0`))
                  : (u = `>=${s}.${i}.${o} <${s}.${+i + 1}.0-0`),
          yt("tilde return", u),
          u
        );
      });
    },
    FH = (e, t) =>
      e
        .trim()
        .split(/\s+/)
        .map((r) => MH(r, t))
        .join(" "),
    MH = (e, t) => {
      yt("caret", e, t);
      let r = t.loose ? Or[mr.CARETLOOSE] : Or[mr.CARET],
        n = t.includePrerelease ? "-0" : "";
      return e.replace(r, (s, i, o, a, u) => {
        yt("caret", e, s, i, o, a, u);
        let l;
        return (
          yr(i)
            ? (l = "")
            : yr(o)
              ? (l = `>=${i}.0.0${n} <${+i + 1}.0.0-0`)
              : yr(a)
                ? i === "0"
                  ? (l = `>=${i}.${o}.0${n} <${i}.${+o + 1}.0-0`)
                  : (l = `>=${i}.${o}.0${n} <${+i + 1}.0.0-0`)
                : u
                  ? (yt("replaceCaret pr", u),
                    i === "0"
                      ? o === "0"
                        ? (l = `>=${i}.${o}.${a}-${u} <${i}.${o}.${+a + 1}-0`)
                        : (l = `>=${i}.${o}.${a}-${u} <${i}.${+o + 1}.0-0`)
                      : (l = `>=${i}.${o}.${a}-${u} <${+i + 1}.0.0-0`))
                  : (yt("no pr"),
                    i === "0"
                      ? o === "0"
                        ? (l = `>=${i}.${o}.${a}${n} <${i}.${o}.${+a + 1}-0`)
                        : (l = `>=${i}.${o}.${a}${n} <${i}.${+o + 1}.0-0`)
                      : (l = `>=${i}.${o}.${a} <${+i + 1}.0.0-0`)),
          yt("caret return", l),
          l
        );
      });
    },
    zH = (e, t) => (
      yt("replaceXRanges", e, t),
      e
        .split(/\s+/)
        .map((r) => VH(r, t))
        .join(" ")
    ),
    VH = (e, t) => {
      e = e.trim();
      let r = t.loose ? Or[mr.XRANGELOOSE] : Or[mr.XRANGE];
      return e.replace(r, (n, s, i, o, a, u) => {
        yt("xRange", e, n, s, i, o, a, u);
        let l = yr(i),
          c = l || yr(o),
          f = c || yr(a),
          d = f;
        return (
          s === "=" && d && (s = ""),
          (u = t.includePrerelease ? "-0" : ""),
          l
            ? s === ">" || s === "<"
              ? (n = "<0.0.0-0")
              : (n = "*")
            : s && d
              ? (c && (o = 0),
                (a = 0),
                s === ">"
                  ? ((s = ">="), c ? ((i = +i + 1), (o = 0), (a = 0)) : ((o = +o + 1), (a = 0)))
                  : s === "<=" && ((s = "<"), c ? (i = +i + 1) : (o = +o + 1)),
                s === "<" && (u = "-0"),
                (n = `${s + i}.${o}.${a}${u}`))
              : c
                ? (n = `>=${i}.0.0${u} <${+i + 1}.0.0-0`)
                : f && (n = `>=${i}.${o}.0${u} <${i}.${+o + 1}.0-0`),
          yt("xRange return", n),
          n
        );
      });
    },
    UH = (e, t) => (yt("replaceStars", e, t), e.trim().replace(Or[mr.STAR], "")),
    HH = (e, t) => (
      yt("replaceGTE0", e, t), e.trim().replace(Or[t.includePrerelease ? mr.GTE0PRE : mr.GTE0], "")
    ),
    BH = (e) => (t, r, n, s, i, o, a, u, l, c, f, d) => (
      yr(n)
        ? (r = "")
        : yr(s)
          ? (r = `>=${n}.0.0${e ? "-0" : ""}`)
          : yr(i)
            ? (r = `>=${n}.${s}.0${e ? "-0" : ""}`)
            : o
              ? (r = `>=${r}`)
              : (r = `>=${r}${e ? "-0" : ""}`),
      yr(l)
        ? (u = "")
        : yr(c)
          ? (u = `<${+l + 1}.0.0-0`)
          : yr(f)
            ? (u = `<${l}.${+c + 1}.0-0`)
            : d
              ? (u = `<=${l}.${c}.${f}-${d}`)
              : e
                ? (u = `<${l}.${c}.${+f + 1}-0`)
                : (u = `<=${u}`),
      `${r} ${u}`.trim()
    ),
    KH = (e, t, r) => {
      for (let n = 0; n < e.length; n++) if (!e[n].test(t)) return !1;
      if (t.prerelease.length && !r.includePrerelease) {
        for (let n = 0; n < e.length; n++)
          if ((yt(e[n].semver), e[n].semver !== em.ANY && e[n].semver.prerelease.length > 0)) {
            let s = e[n].semver;
            if (s.major === t.major && s.minor === t.minor && s.patch === t.patch) return !0;
          }
        return !1;
      }
      return !0;
    };
});
var Ia = b((rie, $T) => {
  var Ca = Symbol("SemVer ANY"),
    nm = class e {
      static get ANY() {
        return Ca;
      }
      constructor(t, r) {
        if (((r = wT(r)), t instanceof e)) {
          if (t.loose === !!r.loose) return t;
          t = t.value;
        }
        (t = t.trim().split(/\s+/).join(" ")),
          rm("comparator", t, r),
          (this.options = r),
          (this.loose = !!r.loose),
          this.parse(t),
          this.semver === Ca
            ? (this.value = "")
            : (this.value = this.operator + this.semver.version),
          rm("comp", this);
      }
      parse(t) {
        let r = this.options.loose ? ET[RT.COMPARATORLOOSE] : ET[RT.COMPARATOR],
          n = t.match(r);
        if (!n) throw new TypeError(`Invalid comparator: ${t}`);
        (this.operator = n[1] !== void 0 ? n[1] : ""),
          this.operator === "=" && (this.operator = ""),
          n[2] ? (this.semver = new TT(n[2], this.options.loose)) : (this.semver = Ca);
      }
      toString() {
        return this.value;
      }
      test(t) {
        if ((rm("Comparator.test", t, this.options.loose), this.semver === Ca || t === Ca))
          return !0;
        if (typeof t == "string")
          try {
            t = new TT(t, this.options);
          } catch {
            return !1;
          }
        return tm(t, this.operator, this.semver, this.options);
      }
      intersects(t, r) {
        if (!(t instanceof e)) throw new TypeError("a Comparator is required");
        return this.operator === ""
          ? this.value === ""
            ? !0
            : new PT(t.value, r).test(this.value)
          : t.operator === ""
            ? t.value === ""
              ? !0
              : new PT(this.value, r).test(t.semver)
            : ((r = wT(r)),
              (r.includePrerelease && (this.value === "<0.0.0-0" || t.value === "<0.0.0-0")) ||
              (!r.includePrerelease &&
                (this.value.startsWith("<0.0.0") || t.value.startsWith("<0.0.0")))
                ? !1
                : !!(
                    (this.operator.startsWith(">") && t.operator.startsWith(">")) ||
                    (this.operator.startsWith("<") && t.operator.startsWith("<")) ||
                    (this.semver.version === t.semver.version &&
                      this.operator.includes("=") &&
                      t.operator.includes("=")) ||
                    (tm(this.semver, "<", t.semver, r) &&
                      this.operator.startsWith(">") &&
                      t.operator.startsWith("<")) ||
                    (tm(this.semver, ">", t.semver, r) &&
                      this.operator.startsWith("<") &&
                      t.operator.startsWith(">"))
                  ));
      }
    };
  $T.exports = nm;
  var wT = Pc(),
    { safeRe: ET, t: RT } = ao(),
    tm = Yp(),
    rm = Na(),
    TT = nr(),
    PT = Zr();
});
var ka = b((nie, OT) => {
  var GH = Zr(),
    JH = (e, t, r) => {
      try {
        t = new GH(t, r);
      } catch {
        return !1;
      }
      return t.test(e);
    };
  OT.exports = JH;
});
var AT = b((sie, NT) => {
  var QH = Zr(),
    WH = (e, t) =>
      new QH(e, t).set.map((r) =>
        r
          .map((n) => n.value)
          .join(" ")
          .trim()
          .split(" "),
      );
  NT.exports = WH;
});
var CT = b((iie, IT) => {
  var YH = nr(),
    XH = Zr(),
    ZH = (e, t, r) => {
      let n = null,
        s = null,
        i = null;
      try {
        i = new XH(t, r);
      } catch {
        return null;
      }
      return (
        e.forEach((o) => {
          i.test(o) && (!n || s.compare(o) === -1) && ((n = o), (s = new YH(n, r)));
        }),
        n
      );
    };
  IT.exports = ZH;
});
var DT = b((oie, kT) => {
  var eB = nr(),
    tB = Zr(),
    rB = (e, t, r) => {
      let n = null,
        s = null,
        i = null;
      try {
        i = new tB(t, r);
      } catch {
        return null;
      }
      return (
        e.forEach((o) => {
          i.test(o) && (!n || s.compare(o) === 1) && ((n = o), (s = new eB(n, r)));
        }),
        n
      );
    };
  kT.exports = rB;
});
var LT = b((aie, jT) => {
  var sm = nr(),
    nB = Zr(),
    qT = Aa(),
    sB = (e, t) => {
      e = new nB(e, t);
      let r = new sm("0.0.0");
      if (e.test(r) || ((r = new sm("0.0.0-0")), e.test(r))) return r;
      r = null;
      for (let n = 0; n < e.set.length; ++n) {
        let s = e.set[n],
          i = null;
        s.forEach((o) => {
          let a = new sm(o.semver.version);
          switch (o.operator) {
            case ">":
              a.prerelease.length === 0 ? a.patch++ : a.prerelease.push(0), (a.raw = a.format());
            case "":
            case ">=":
              (!i || qT(a, i)) && (i = a);
              break;
            case "<":
            case "<=":
              break;
            default:
              throw new Error(`Unexpected operation: ${o.operator}`);
          }
        }),
          i && (!r || qT(r, i)) && (r = i);
      }
      return r && e.test(r) ? r : null;
    };
  jT.exports = sB;
});
var FT = b((uie, xT) => {
  var iB = Zr(),
    oB = (e, t) => {
      try {
        return new iB(e, t).range || "*";
      } catch {
        return null;
      }
    };
  xT.exports = oB;
});
var qc = b((lie, UT) => {
  var aB = nr(),
    VT = Ia(),
    { ANY: uB } = VT,
    lB = Zr(),
    cB = ka(),
    MT = Aa(),
    zT = Ac(),
    fB = Cc(),
    dB = Ic(),
    hB = (e, t, r, n) => {
      (e = new aB(e, n)), (t = new lB(t, n));
      let s, i, o, a, u;
      switch (r) {
        case ">":
          (s = MT), (i = fB), (o = zT), (a = ">"), (u = ">=");
          break;
        case "<":
          (s = zT), (i = dB), (o = MT), (a = "<"), (u = "<=");
          break;
        default:
          throw new TypeError('Must provide a hilo val of "<" or ">"');
      }
      if (cB(e, t, n)) return !1;
      for (let l = 0; l < t.set.length; ++l) {
        let c = t.set[l],
          f = null,
          d = null;
        if (
          (c.forEach((h) => {
            h.semver === uB && (h = new VT(">=0.0.0")),
              (f = f || h),
              (d = d || h),
              s(h.semver, f.semver, n) ? (f = h) : o(h.semver, d.semver, n) && (d = h);
          }),
          f.operator === a ||
            f.operator === u ||
            ((!d.operator || d.operator === a) && i(e, d.semver)))
        )
          return !1;
        if (d.operator === u && o(e, d.semver)) return !1;
      }
      return !0;
    };
  UT.exports = hB;
});
var BT = b((cie, HT) => {
  var pB = qc(),
    mB = (e, t, r) => pB(e, t, ">", r);
  HT.exports = mB;
});
var GT = b((fie, KT) => {
  var yB = qc(),
    gB = (e, t, r) => yB(e, t, "<", r);
  KT.exports = gB;
});
var WT = b((die, QT) => {
  var JT = Zr(),
    _B = (e, t, r) => ((e = new JT(e, r)), (t = new JT(t, r)), e.intersects(t, r));
  QT.exports = _B;
});
var XT = b((hie, YT) => {
  var SB = ka(),
    vB = Xr();
  YT.exports = (e, t, r) => {
    let n = [],
      s = null,
      i = null,
      o = e.sort((c, f) => vB(c, f, r));
    for (let c of o)
      SB(c, t, r) ? ((i = c), s || (s = c)) : (i && n.push([s, i]), (i = null), (s = null));
    s && n.push([s, null]);
    let a = [];
    for (let [c, f] of n)
      c === f
        ? a.push(c)
        : !f && c === o[0]
          ? a.push("*")
          : f
            ? c === o[0]
              ? a.push(`<=${f}`)
              : a.push(`${c} - ${f}`)
            : a.push(`>=${c}`);
    let u = a.join(" || "),
      l = typeof t.raw == "string" ? t.raw : String(t);
    return u.length < l.length ? u : t;
  };
});
var sP = b((pie, nP) => {
  var ZT = Zr(),
    om = Ia(),
    { ANY: im } = om,
    Da = ka(),
    am = Xr(),
    bB = (e, t, r = {}) => {
      if (e === t) return !0;
      (e = new ZT(e, r)), (t = new ZT(t, r));
      let n = !1;
      e: for (let s of e.set) {
        for (let i of t.set) {
          let o = EB(s, i, r);
          if (((n = n || o !== null), o)) continue e;
        }
        if (n) return !1;
      }
      return !0;
    },
    wB = [new om(">=0.0.0-0")],
    eP = [new om(">=0.0.0")],
    EB = (e, t, r) => {
      if (e === t) return !0;
      if (e.length === 1 && e[0].semver === im) {
        if (t.length === 1 && t[0].semver === im) return !0;
        r.includePrerelease ? (e = wB) : (e = eP);
      }
      if (t.length === 1 && t[0].semver === im) {
        if (r.includePrerelease) return !0;
        t = eP;
      }
      let n = new Set(),
        s,
        i;
      for (let h of e)
        h.operator === ">" || h.operator === ">="
          ? (s = tP(s, h, r))
          : h.operator === "<" || h.operator === "<="
            ? (i = rP(i, h, r))
            : n.add(h.semver);
      if (n.size > 1) return null;
      let o;
      if (s && i) {
        if (((o = am(s.semver, i.semver, r)), o > 0)) return null;
        if (o === 0 && (s.operator !== ">=" || i.operator !== "<=")) return null;
      }
      for (let h of n) {
        if ((s && !Da(h, String(s), r)) || (i && !Da(h, String(i), r))) return null;
        for (let p of t) if (!Da(h, String(p), r)) return !1;
        return !0;
      }
      let a,
        u,
        l,
        c,
        f = i && !r.includePrerelease && i.semver.prerelease.length ? i.semver : !1,
        d = s && !r.includePrerelease && s.semver.prerelease.length ? s.semver : !1;
      f && f.prerelease.length === 1 && i.operator === "<" && f.prerelease[0] === 0 && (f = !1);
      for (let h of t) {
        if (
          ((c = c || h.operator === ">" || h.operator === ">="),
          (l = l || h.operator === "<" || h.operator === "<="),
          s)
        ) {
          if (
            (d &&
              h.semver.prerelease &&
              h.semver.prerelease.length &&
              h.semver.major === d.major &&
              h.semver.minor === d.minor &&
              h.semver.patch === d.patch &&
              (d = !1),
            h.operator === ">" || h.operator === ">=")
          ) {
            if (((a = tP(s, h, r)), a === h && a !== s)) return !1;
          } else if (s.operator === ">=" && !Da(s.semver, String(h), r)) return !1;
        }
        if (i) {
          if (
            (f &&
              h.semver.prerelease &&
              h.semver.prerelease.length &&
              h.semver.major === f.major &&
              h.semver.minor === f.minor &&
              h.semver.patch === f.patch &&
              (f = !1),
            h.operator === "<" || h.operator === "<=")
          ) {
            if (((u = rP(i, h, r)), u === h && u !== i)) return !1;
          } else if (i.operator === "<=" && !Da(i.semver, String(h), r)) return !1;
        }
        if (!h.operator && (i || s) && o !== 0) return !1;
      }
      return !((s && l && !i && o !== 0) || (i && c && !s && o !== 0) || d || f);
    },
    tP = (e, t, r) => {
      if (!e) return t;
      let n = am(e.semver, t.semver, r);
      return n > 0 ? e : n < 0 || (t.operator === ">" && e.operator === ">=") ? t : e;
    },
    rP = (e, t, r) => {
      if (!e) return t;
      let n = am(e.semver, t.semver, r);
      return n < 0 ? e : n > 0 || (t.operator === "<" && e.operator === "<=") ? t : e;
    };
  nP.exports = bB;
});
var lm = b((mie, aP) => {
  var um = ao(),
    iP = Oa(),
    RB = nr(),
    oP = Gp(),
    TB = yi(),
    PB = CR(),
    $B = DR(),
    OB = LR(),
    NB = MR(),
    AB = VR(),
    IB = HR(),
    CB = KR(),
    kB = JR(),
    DB = Xr(),
    qB = XR(),
    jB = eT(),
    LB = Nc(),
    xB = sT(),
    FB = oT(),
    MB = Aa(),
    zB = Ac(),
    VB = Qp(),
    UB = Wp(),
    HB = Ic(),
    BB = Cc(),
    KB = Yp(),
    GB = mT(),
    JB = Ia(),
    QB = Zr(),
    WB = ka(),
    YB = AT(),
    XB = CT(),
    ZB = DT(),
    e5 = LT(),
    t5 = FT(),
    r5 = qc(),
    n5 = BT(),
    s5 = GT(),
    i5 = WT(),
    o5 = XT(),
    a5 = sP();
  aP.exports = {
    parse: TB,
    valid: PB,
    clean: $B,
    inc: OB,
    diff: NB,
    major: AB,
    minor: IB,
    patch: CB,
    prerelease: kB,
    compare: DB,
    rcompare: qB,
    compareLoose: jB,
    compareBuild: LB,
    sort: xB,
    rsort: FB,
    gt: MB,
    lt: zB,
    eq: VB,
    neq: UB,
    gte: HB,
    lte: BB,
    cmp: KB,
    coerce: GB,
    Comparator: JB,
    Range: QB,
    satisfies: WB,
    toComparators: YB,
    maxSatisfying: XB,
    minSatisfying: ZB,
    minVersion: e5,
    validRange: t5,
    outside: r5,
    gtr: n5,
    ltr: s5,
    intersects: i5,
    simplifyRange: o5,
    subset: a5,
    SemVer: RB,
    re: um.re,
    src: um.src,
    tokens: um.t,
    SEMVER_SPEC_VERSION: iP.SEMVER_SPEC_VERSION,
    RELEASE_TYPES: iP.RELEASE_TYPES,
    compareIdentifiers: oP.compareIdentifiers,
    rcompareIdentifiers: oP.rcompareIdentifiers,
  };
});
var Lc = b((yie, hm) => {
  "use strict";
  var jc = gR(),
    u5 = lm(),
    {
      FSTDEP005: l5,
      FSTDEP012: c5,
      FSTDEP015: f5,
      FSTDEP016: d5,
      FSTDEP017: h5,
      FSTDEP018: p5,
    } = ts(),
    {
      kHasBeenDecorated: m5,
      kSchemaBody: y5,
      kSchemaHeaders: g5,
      kSchemaParams: _5,
      kSchemaQuerystring: uP,
      kSchemaController: cm,
      kOptions: S5,
      kRequestCacheValidateFns: Ds,
      kRouteContext: Ct,
      kPublicRouteContext: lP,
      kRequestOriginalUrl: fm,
    } = Vt(),
    { FST_ERR_REQ_INVALID_VALIDATION_INVOCATION: v5 } = tr(),
    cP = { body: y5, headers: g5, params: _5, querystring: uP, query: uP };
  function dm(e, t, r, n, s, i) {
    (this.id = e),
      (this[Ct] = i),
      (this.params = t),
      (this.raw = r),
      (this.query = n),
      (this.log = s),
      (this.body = void 0);
  }
  dm.props = [];
  function b5(e) {
    if (typeof e == "function") return e;
    if (e === !0)
      return function () {
        return !0;
      };
    if (typeof e == "number")
      return function (t, r) {
        return r < e;
      };
    if (typeof e == "string") {
      let t = e.split(",").map((r) => r.trim());
      return jc.compile(t);
    }
    return jc.compile(e);
  }
  function w5(e, t) {
    return t ? E5(e, t) : dP(e);
  }
  function dP(e) {
    let t = e.props.slice();
    function r(n, s, i, o, a, u) {
      (this.id = n),
        (this[Ct] = u),
        (this.params = s),
        (this.raw = i),
        (this.query = o),
        (this.log = a),
        (this.body = void 0);
      for (var l, c = 0; c < t.length; c++) (l = t[c]), (this[l.key] = l.value);
    }
    return (
      Object.setPrototypeOf(r.prototype, e.prototype),
      Object.setPrototypeOf(r, e),
      (r.props = t),
      (r.parent = e),
      r
    );
  }
  function fP(e) {
    let t = e.lastIndexOf(",");
    return t === -1 ? e.trim() : e.slice(t + 1).trim();
  }
  function E5(e, t) {
    let r = dP(e),
      n = b5(t);
    return (
      (r[m5] = !0),
      Object.defineProperties(r.prototype, {
        ip: {
          get() {
            return jc(this.raw, n);
          },
        },
        ips: {
          get() {
            return jc.all(this.raw, n);
          },
        },
        hostname: {
          get() {
            return this.ip !== void 0 && this.headers["x-forwarded-host"]
              ? fP(this.headers["x-forwarded-host"])
              : this.headers.host || this.headers[":authority"];
          },
        },
        protocol: {
          get() {
            if (this.headers["x-forwarded-proto"]) return fP(this.headers["x-forwarded-proto"]);
            if (this.socket) return this.socket.encrypted ? "https" : "http";
          },
        },
      }),
      r
    );
  }
  Object.defineProperties(dm.prototype, {
    server: {
      get() {
        return this[Ct].server;
      },
    },
    url: {
      get() {
        return this.raw.url;
      },
    },
    originalUrl: {
      get() {
        return this[fm] || (this[fm] = this.raw.originalUrl || this.raw.url), this[fm];
      },
    },
    method: {
      get() {
        return this.raw.method;
      },
    },
    context: {
      get() {
        return c5(), this[Ct];
      },
    },
    routerPath: {
      get() {
        return h5(), this[Ct].config?.url;
      },
    },
    routeOptions: {
      get() {
        let e = this[Ct],
          t = e._parserOptions.limit,
          r = e.server.initialConfig.bodyLimit,
          n = e.server.hasConstraintStrategy("version")
            ? this.raw.headers["accept-version"]
            : void 0,
          s = {
            method: e.config?.method,
            url: e.config?.url,
            bodyLimit: t || r,
            attachValidation: e.attachValidation,
            logLevel: e.logLevel,
            exposeHeadRoute: e.exposeHeadRoute,
            prefixTrailingSlash: e.prefixTrailingSlash,
            handler: e.handler,
            version: n,
          };
        return (
          Object.defineProperties(s, {
            config: { get: () => e.config },
            schema: { get: () => e.schema },
          }),
          Object.freeze(s)
        );
      },
    },
    routerMethod: {
      get() {
        return p5(), this[Ct].config?.method;
      },
    },
    routeConfig: {
      get() {
        return d5(), this[Ct][lP]?.config;
      },
    },
    routeSchema: {
      get() {
        return f5(), this[Ct][lP].schema;
      },
    },
    is404: {
      get() {
        return this[Ct].config?.url === void 0;
      },
    },
    connection: {
      get() {
        return u5.gte(process.versions.node, "13.0.0") && l5(), this.raw.connection;
      },
    },
    socket: {
      get() {
        return this.raw.socket;
      },
    },
    ip: {
      get() {
        if (this.socket) return this.socket.remoteAddress;
      },
    },
    hostname: {
      get() {
        return this.raw.headers.host || this.raw.headers[":authority"];
      },
    },
    protocol: {
      get() {
        if (this.socket) return this.socket.encrypted ? "https" : "http";
      },
    },
    headers: {
      get() {
        return this.additionalHeaders
          ? Object.assign({}, this.raw.headers, this.additionalHeaders)
          : this.raw.headers;
      },
      set(e) {
        this.additionalHeaders = e;
      },
    },
    getValidationFunction: {
      value: function (e) {
        if (typeof e == "string") {
          let t = cP[e];
          return this[Ct][t];
        } else if (typeof e == "object") return this[Ct][Ds]?.get(e);
      },
    },
    compileValidationSchema: {
      value: function (e, t = null) {
        let { method: r, url: n } = this;
        if (this[Ct][Ds]?.has(e)) return this[Ct][Ds].get(e);
        let i = (
          this[Ct].validatorCompiler ||
          this.server[cm].validatorCompiler ||
          this.server[cm].setupValidator(this.server[S5]) ||
          this.server[cm].validatorCompiler
        )({ schema: e, method: r, url: n, httpPart: t });
        return this[Ct][Ds] == null && (this[Ct][Ds] = new WeakMap()), this[Ct][Ds].set(e, i), i;
      },
    },
    validateInput: {
      value: function (e, t, r) {
        r = typeof t == "string" ? t : r;
        let n = r != null && typeof r == "string" && cP[r],
          s;
        if (
          (n && (s = this[Ct][n]),
          s == null && (t == null || typeof t != "object" || Array.isArray(t)))
        )
          throw new v5(r);
        return (
          s == null &&
            (this[Ct][Ds]?.has(t)
              ? (s = this[Ct][Ds].get(t))
              : (s = this.compileValidationSchema(t, r))),
          s(e)
        );
      },
    },
  });
  hm.exports = dm;
  hm.exports.buildRequest = w5;
});
var xc = b((gie, hP) => {
  "use strict";
  var {
    kFourOhFourContext: R5,
    kReplySerializerDefault: T5,
    kSchemaErrorFormatter: P5,
    kErrorHandler: $5,
    kChildLoggerFactory: O5,
    kOptions: N5,
    kReply: A5,
    kRequest: I5,
    kBodyLimit: C5,
    kLogLevel: k5,
    kContentTypeParser: D5,
    kRouteByFastify: q5,
    kRequestCacheValidateFns: j5,
    kReplyCacheSerializeFns: L5,
    kPublicRouteContext: x5,
  } = Vt();
  function F5({
    schema: e,
    handler: t,
    config: r,
    requestIdLogLabel: n,
    childLoggerFactory: s,
    errorHandler: i,
    bodyLimit: o,
    logLevel: a,
    logSerializers: u,
    attachValidation: l,
    validatorCompiler: c,
    serializerCompiler: f,
    replySerializer: d,
    schemaErrorFormatter: h,
    exposeHeadRoute: p,
    prefixTrailingSlash: y,
    server: _,
    isFastify: S,
  }) {
    (this.schema = e),
      (this.handler = t),
      (this.Reply = _[A5]),
      (this.Request = _[I5]),
      (this.contentTypeParser = _[D5]),
      (this.onRequest = null),
      (this.onSend = null),
      (this.onError = null),
      (this.onTimeout = null),
      (this.preHandler = null),
      (this.onResponse = null),
      (this.preSerialization = null),
      (this.onRequestAbort = null),
      (this.config = r),
      (this.errorHandler = i || _[$5]),
      (this.requestIdLogLabel = n || _[N5].requestIdLogLabel),
      (this.childLoggerFactory = s || _[O5]),
      (this._middie = null),
      (this._parserOptions = { limit: o || _[C5] }),
      (this.exposeHeadRoute = p),
      (this.prefixTrailingSlash = y),
      (this.logLevel = a || _[k5]),
      (this.logSerializers = u),
      (this[R5] = null),
      (this.attachValidation = l),
      (this[T5] = d),
      (this.schemaErrorFormatter = h || _[P5] || z5),
      (this[q5] = S),
      (this[j5] = null),
      (this[L5] = null),
      (this.validatorCompiler = c || null),
      (this.serializerCompiler = f || null),
      (this[x5] = M5(this)),
      (this.server = _);
  }
  function M5(e) {
    return Object.create(null, {
      schema: {
        enumerable: !0,
        get() {
          return e.schema;
        },
      },
      config: {
        enumerable: !0,
        get() {
          return e.config;
        },
      },
    });
  }
  function z5(e, t) {
    let r = "",
      n = ", ";
    for (var s = 0; s !== e.length; ++s) {
      let i = e[s];
      r += t + (i.instancePath || "") + " " + i.message + n;
    }
    return new Error(r.slice(0, -n.length));
  }
  hP.exports = F5;
});
var pm = b((_ie, pP) => {
  "use strict";
  pP.exports = {
    supportedMethods: [
      "DELETE",
      "GET",
      "HEAD",
      "PATCH",
      "POST",
      "PUT",
      "OPTIONS",
      "PROPFIND",
      "PROPPATCH",
      "MKCOL",
      "COPY",
      "MOVE",
      "LOCK",
      "UNLOCK",
      "TRACE",
      "SEARCH",
      "REPORT",
      "MKCALENDAR",
    ],
  };
});
var Sm = b((Sie, _P) => {
  "use strict";
  var { kReply: mm, kRequest: ym, kState: V5, kHasBeenDecorated: U5 } = Vt(),
    {
      FST_ERR_DEC_ALREADY_PRESENT: mP,
      FST_ERR_DEC_MISSING_DEPENDENCY: H5,
      FST_ERR_DEC_AFTER_START: B5,
      FST_ERR_DEC_DEPENDENCY_INVALID_TYPE: K5,
    } = tr(),
    { FSTDEP006: G5 } = ts();
  function J5(e, t, r, n) {
    if (Object.prototype.hasOwnProperty.call(e, t)) throw new mP(t);
    gm(e, t, n),
      r && (typeof r.getter == "function" || typeof r.setter == "function")
        ? Object.defineProperty(e, t, { get: r.getter, set: r.setter })
        : (e[t] = r);
  }
  function yP(e, t, r, n) {
    let s = e.prototype;
    if (Object.prototype.hasOwnProperty.call(s, t) || Mc(e, t)) throw new mP(t);
    (e[U5] = !0),
      gm(e, t, n),
      r && (typeof r.getter == "function" || typeof r.setter == "function")
        ? Object.defineProperty(s, t, { get: r.getter, set: r.setter })
        : typeof r == "function"
          ? (s[t] = r)
          : e.props.push({ key: t, value: r });
  }
  function gP(e, t) {
    typeof t == "object" &&
      t &&
      !(typeof t.getter == "function" || typeof t.setter == "function") &&
      G5(e);
  }
  function Q5(e, t, r) {
    return _m(this, e), J5(this, e, t, r), this;
  }
  function Fc(e, t) {
    return t ? t in e || (e.prototype && t in e.prototype) || Mc(e, t) : e in this;
  }
  function Mc(e, t) {
    return e.props ? e.props.find(({ key: r }) => r === t) : !1;
  }
  function W5(e) {
    return e && Mc(this[ym], e) ? !0 : Fc(this[ym].prototype, e);
  }
  function Y5(e) {
    return e && Mc(this[mm], e) ? !0 : Fc(this[mm].prototype, e);
  }
  function gm(e, t, r) {
    if (r != null) {
      if (!Array.isArray(r)) throw new K5(t);
      for (var n = 0; n !== r.length; ++n) if (!Fc(e, r[n])) throw new H5(r[n]);
    }
  }
  function X5(e, t, r) {
    return _m(this, e), gP(e, t), yP(this[mm], e, t, r), this;
  }
  function Z5(e, t, r) {
    return _m(this, e), gP(e, t), yP(this[ym], e, t, r), this;
  }
  function _m(e, t) {
    if (e[V5].started) throw new B5(t);
  }
  _P.exports = {
    add: Q5,
    exist: Fc,
    existRequest: W5,
    existReply: Y5,
    dependencies: gm,
    decorateReply: X5,
    decorateRequest: Z5,
  };
});
var vP = b((kn) => {
  "use strict";
  var vm = class {
      constructor(t = 1e3, r = 0) {
        if (isNaN(t) || t < 0) throw new Error("Invalid max value");
        if (isNaN(r) || r < 0) throw new Error("Invalid ttl value");
        (this.first = null),
          (this.items = new Map()),
          (this.last = null),
          (this.max = t),
          (this.ttl = r);
      }
      get size() {
        return this.items.size;
      }
      clear() {
        (this.items = new Map()), (this.first = null), (this.last = null);
      }
      delete(t) {
        if (this.items.has(t)) {
          let r = this.items.get(t);
          this.items.delete(t),
            r.prev !== null && (r.prev.next = r.next),
            r.next !== null && (r.next.prev = r.prev),
            this.first === r && (this.first = r.next),
            this.last === r && (this.last = r.prev);
        }
      }
      deleteMany(t) {
        for (var r = 0; r < t.length; r++) this.delete(t[r]);
      }
      evict() {
        if (this.size > 0) {
          let t = this.first;
          this.items.delete(t.key),
            this.size === 0
              ? ((this.first = null), (this.last = null))
              : ((this.first = t.next), (this.first.prev = null));
        }
      }
      expiresAt(t) {
        if (this.items.has(t)) return this.items.get(t).expiry;
      }
      get(t) {
        if (this.items.has(t)) {
          let r = this.items.get(t);
          if (this.ttl > 0 && r.expiry <= Date.now()) {
            this.delete(t);
            return;
          }
          return r.value;
        }
      }
      getMany(t) {
        let r = [];
        for (var n = 0; n < t.length; n++) r.push(this.get(t[n]));
        return r;
      }
      keys() {
        return this.items.keys();
      }
      set(t, r) {
        if (this.items.has(t)) {
          let s = this.items.get(t);
          (s.value = r), (s.expiry = this.ttl > 0 ? Date.now() + this.ttl : this.ttl);
          return;
        }
        this.max > 0 && this.size === this.max && this.evict();
        let n = {
          expiry: this.ttl > 0 ? Date.now() + this.ttl : this.ttl,
          key: t,
          prev: this.last,
          next: null,
          value: r,
        };
        this.items.set(t, n),
          this.size === 1 ? (this.first = n) : (this.last.next = n),
          (this.last = n);
      }
    },
    bm = class {
      constructor(t = 1e3, r = 0) {
        if (isNaN(t) || t < 0) throw new Error("Invalid max value");
        if (isNaN(r) || r < 0) throw new Error("Invalid ttl value");
        (this.first = null),
          (this.items = new Map()),
          (this.last = null),
          (this.max = t),
          (this.ttl = r);
      }
      get size() {
        return this.items.size;
      }
      bumpLru(t) {
        if (this.last === t) return;
        let r = this.last,
          n = t.next,
          s = t.prev;
        this.first === t && (this.first = n),
          (t.next = null),
          (t.prev = r),
          (r.next = t),
          s !== null && (s.next = n),
          n !== null && (n.prev = s),
          (this.last = t);
      }
      clear() {
        (this.items = new Map()), (this.first = null), (this.last = null);
      }
      delete(t) {
        if (this.items.has(t)) {
          let r = this.items.get(t);
          this.items.delete(t),
            r.prev !== null && (r.prev.next = r.next),
            r.next !== null && (r.next.prev = r.prev),
            this.first === r && (this.first = r.next),
            this.last === r && (this.last = r.prev);
        }
      }
      deleteMany(t) {
        for (var r = 0; r < t.length; r++) this.delete(t[r]);
      }
      evict() {
        if (this.size > 0) {
          let t = this.first;
          this.items.delete(t.key),
            this.size === 0
              ? ((this.first = null), (this.last = null))
              : ((this.first = t.next), (this.first.prev = null));
        }
      }
      expiresAt(t) {
        if (this.items.has(t)) return this.items.get(t).expiry;
      }
      get(t) {
        if (this.items.has(t)) {
          let r = this.items.get(t);
          if (this.ttl > 0 && r.expiry <= Date.now()) {
            this.delete(t);
            return;
          }
          return this.bumpLru(r), r.value;
        }
      }
      getMany(t) {
        let r = [];
        for (var n = 0; n < t.length; n++) r.push(this.get(t[n]));
        return r;
      }
      keys() {
        return this.items.keys();
      }
      set(t, r) {
        if (this.items.has(t)) {
          let s = this.items.get(t);
          (s.value = r),
            (s.expiry = this.ttl > 0 ? Date.now() + this.ttl : this.ttl),
            this.last !== s && this.bumpLru(s);
          return;
        }
        this.max > 0 && this.size === this.max && this.evict();
        let n = {
          expiry: this.ttl > 0 ? Date.now() + this.ttl : this.ttl,
          key: t,
          prev: this.last,
          next: null,
          value: r,
        };
        this.items.set(t, n),
          this.size === 1 ? (this.first = n) : (this.last.next = n),
          (this.last = n);
      }
    },
    qa = class {
      constructor(t = 1e3, r = 0) {
        if (isNaN(t) || t < 0) throw new Error("Invalid max value");
        if (isNaN(r) || r < 0) throw new Error("Invalid ttl value");
        (this.first = null),
          (this.items = Object.create(null)),
          (this.last = null),
          (this.size = 0),
          (this.max = t),
          (this.ttl = r);
      }
      bumpLru(t) {
        if (this.last === t) return;
        let r = this.last,
          n = t.next,
          s = t.prev;
        this.first === t && (this.first = n),
          (t.next = null),
          (t.prev = r),
          (r.next = t),
          s !== null && (s.next = n),
          n !== null && (n.prev = s),
          (this.last = t);
      }
      clear() {
        (this.items = Object.create(null)),
          (this.first = null),
          (this.last = null),
          (this.size = 0);
      }
      delete(t) {
        if (Object.prototype.hasOwnProperty.call(this.items, t)) {
          let r = this.items[t];
          delete this.items[t],
            this.size--,
            r.prev !== null && (r.prev.next = r.next),
            r.next !== null && (r.next.prev = r.prev),
            this.first === r && (this.first = r.next),
            this.last === r && (this.last = r.prev);
        }
      }
      deleteMany(t) {
        for (var r = 0; r < t.length; r++) this.delete(t[r]);
      }
      evict() {
        if (this.size > 0) {
          let t = this.first;
          delete this.items[t.key],
            --this.size === 0
              ? ((this.first = null), (this.last = null))
              : ((this.first = t.next), (this.first.prev = null));
        }
      }
      expiresAt(t) {
        if (Object.prototype.hasOwnProperty.call(this.items, t)) return this.items[t].expiry;
      }
      get(t) {
        if (Object.prototype.hasOwnProperty.call(this.items, t)) {
          let r = this.items[t];
          if (this.ttl > 0 && r.expiry <= Date.now()) {
            this.delete(t);
            return;
          }
          return this.bumpLru(r), r.value;
        }
      }
      getMany(t) {
        let r = [];
        for (var n = 0; n < t.length; n++) r.push(this.get(t[n]));
        return r;
      }
      keys() {
        return Object.keys(this.items);
      }
      set(t, r) {
        if (Object.prototype.hasOwnProperty.call(this.items, t)) {
          let s = this.items[t];
          (s.value = r),
            (s.expiry = this.ttl > 0 ? Date.now() + this.ttl : this.ttl),
            this.last !== s && this.bumpLru(s);
          return;
        }
        this.max > 0 && this.size === this.max && this.evict();
        let n = {
          expiry: this.ttl > 0 ? Date.now() + this.ttl : this.ttl,
          key: t,
          prev: this.last,
          next: null,
          value: r,
        };
        (this.items[t] = n),
          ++this.size === 1 ? (this.first = n) : (this.last.next = n),
          (this.last = n);
      }
    },
    zc = class {
      constructor() {
        this.records = {};
      }
      initForCache(t, r) {
        this.records[t] = {
          [r]: {
            cacheSize: 0,
            hits: 0,
            falsyHits: 0,
            emptyHits: 0,
            misses: 0,
            expirations: 0,
            evictions: 0,
            invalidateOne: 0,
            invalidateAll: 0,
            sets: 0,
          },
        };
      }
      resetForCache(t) {
        for (let r of Object.keys(this.records[t]))
          this.records[t][r] = {
            cacheSize: 0,
            hits: 0,
            falsyHits: 0,
            emptyHits: 0,
            misses: 0,
            expirations: 0,
            evictions: 0,
            invalidateOne: 0,
            invalidateAll: 0,
            sets: 0,
          };
      }
      getStatistics() {
        return this.records;
      }
    };
  function SP(e) {
    return `${e.getFullYear()}-${(e.getMonth() + 1).toString().padStart(2, "0")}-${e.getDate().toString().padStart(2, "0")}`;
  }
  var wm = class {
      constructor(t, r, n) {
        (this.cacheId = t),
          (this.statisticTtlInHours = r),
          (this.collectionStart = new Date()),
          (this.currentTimeStamp = SP(this.collectionStart)),
          (this.records = n || new zc()),
          this.records.initForCache(this.cacheId, this.currentTimeStamp);
      }
      get currentRecord() {
        return (
          this.records.records[this.cacheId][this.currentTimeStamp] ||
            (this.records.records[this.cacheId][this.currentTimeStamp] = {
              cacheSize: 0,
              hits: 0,
              falsyHits: 0,
              emptyHits: 0,
              misses: 0,
              expirations: 0,
              evictions: 0,
              sets: 0,
              invalidateOne: 0,
              invalidateAll: 0,
            }),
          this.records.records[this.cacheId][this.currentTimeStamp]
        );
      }
      hoursPassed() {
        return (Date.now() - this.collectionStart) / 1e3 / 60 / 60;
      }
      addHit() {
        this.archiveIfNeeded(), this.currentRecord.hits++;
      }
      addFalsyHit() {
        this.archiveIfNeeded(), this.currentRecord.falsyHits++;
      }
      addEmptyHit() {
        this.archiveIfNeeded(), this.currentRecord.emptyHits++;
      }
      addMiss() {
        this.archiveIfNeeded(), this.currentRecord.misses++;
      }
      addEviction() {
        this.archiveIfNeeded(), this.currentRecord.evictions++;
      }
      setCacheSize(t) {
        this.archiveIfNeeded(), (this.currentRecord.cacheSize = t);
      }
      addExpiration() {
        this.archiveIfNeeded(), this.currentRecord.expirations++;
      }
      addSet() {
        this.archiveIfNeeded(), this.currentRecord.sets++;
      }
      addInvalidateOne() {
        this.archiveIfNeeded(), this.currentRecord.invalidateOne++;
      }
      addInvalidateAll() {
        this.archiveIfNeeded(), this.currentRecord.invalidateAll++;
      }
      getStatistics() {
        return this.records.getStatistics();
      }
      archiveIfNeeded() {
        this.hoursPassed() >= this.statisticTtlInHours &&
          ((this.collectionStart = new Date()),
          (this.currentTimeStamp = SP(this.collectionStart)),
          this.records.initForCache(this.cacheId, this.currentTimeStamp));
      }
    },
    Vc = class extends qa {
      constructor(t, r, n, s, i) {
        if ((super(t || 1e3, r || 0), !n)) throw new Error("Cache id is mandatory");
        this.hitStatistics = new wm(n, i !== void 0 ? i : 24, s);
      }
      getStatistics() {
        return this.hitStatistics.getStatistics();
      }
      set(t, r) {
        super.set(t, r), this.hitStatistics.addSet(), this.hitStatistics.setCacheSize(this.size);
      }
      evict() {
        super.evict(), this.hitStatistics.addEviction(), this.hitStatistics.setCacheSize(this.size);
      }
      delete(t, r = !1) {
        super.delete(t),
          r || this.hitStatistics.addInvalidateOne(),
          this.hitStatistics.setCacheSize(this.size);
      }
      clear() {
        super.clear(),
          this.hitStatistics.addInvalidateAll(),
          this.hitStatistics.setCacheSize(this.size);
      }
      get(t) {
        if (Object.prototype.hasOwnProperty.call(this.items, t)) {
          let r = this.items[t];
          if (this.ttl > 0 && r.expiry <= Date.now()) {
            this.delete(t, !0), this.hitStatistics.addExpiration();
            return;
          }
          return (
            this.bumpLru(r),
            r.value || this.hitStatistics.addFalsyHit(),
            (r.value === void 0 || r.value === null || r.value === "") &&
              this.hitStatistics.addEmptyHit(),
            this.hitStatistics.addHit(),
            r.value
          );
        }
        this.hitStatistics.addMiss();
      }
    },
    Uc = class {
      constructor(t = 1e3, r = 0) {
        if (isNaN(t) || t < 0) throw new Error("Invalid max value");
        if (isNaN(r) || r < 0) throw new Error("Invalid ttl value");
        (this.first = null),
          (this.items = Object.create(null)),
          (this.last = null),
          (this.size = 0),
          (this.max = t),
          (this.ttl = r);
      }
      clear() {
        (this.items = Object.create(null)),
          (this.first = null),
          (this.last = null),
          (this.size = 0);
      }
      delete(t) {
        if (Object.prototype.hasOwnProperty.call(this.items, t)) {
          let r = this.items[t];
          delete this.items[t],
            this.size--,
            r.prev !== null && (r.prev.next = r.next),
            r.next !== null && (r.next.prev = r.prev),
            this.first === r && (this.first = r.next),
            this.last === r && (this.last = r.prev);
        }
      }
      deleteMany(t) {
        for (var r = 0; r < t.length; r++) this.delete(t[r]);
      }
      evict() {
        if (this.size > 0) {
          let t = this.first;
          delete this.items[t.key],
            --this.size === 0
              ? ((this.first = null), (this.last = null))
              : ((this.first = t.next), (this.first.prev = null));
        }
      }
      expiresAt(t) {
        if (Object.prototype.hasOwnProperty.call(this.items, t)) return this.items[t].expiry;
      }
      get(t) {
        if (Object.prototype.hasOwnProperty.call(this.items, t)) {
          let r = this.items[t];
          if (this.ttl > 0 && r.expiry <= Date.now()) {
            this.delete(t);
            return;
          }
          return r.value;
        }
      }
      getMany(t) {
        let r = [];
        for (var n = 0; n < t.length; n++) r.push(this.get(t[n]));
        return r;
      }
      keys() {
        return Object.keys(this.items);
      }
      set(t, r) {
        if (Object.prototype.hasOwnProperty.call(this.items, t)) {
          let s = this.items[t];
          (s.value = r), (s.expiry = this.ttl > 0 ? Date.now() + this.ttl : this.ttl);
          return;
        }
        this.max > 0 && this.size === this.max && this.evict();
        let n = {
          expiry: this.ttl > 0 ? Date.now() + this.ttl : this.ttl,
          key: t,
          prev: this.last,
          next: null,
          value: r,
        };
        (this.items[t] = n),
          ++this.size === 1 ? (this.first = n) : (this.last.next = n),
          (this.last = n);
      }
    };
  kn.Fifo = Uc;
  kn.FifoMap = vm;
  kn.FifoObject = Uc;
  kn.HitStatisticsRecord = zc;
  kn.Lru = qa;
  kn.LruHitStatistics = Vc;
  kn.LruMap = bm;
  kn.LruObject = qa;
  kn.LruObjectHitStatistics = Vc;
});
var RP = b((bie, ja) => {
  "use strict";
  var Kc = function () {};
  Kc.prototype = Object.create(null);
  var Hc =
      /; *([!#$%&'*+.^\w`|~-]+)=("(?:[\v\u0020\u0021\u0023-\u005b\u005d-\u007e\u0080-\u00ff]|\\[\v\u0020-\u00ff])*"|[!#$%&'*+.^\w`|~-]+) */gu,
    Bc = /\\([\v\u0020-\u00ff])/gu,
    bP = /^[!#$%&'*+.^\w|~-]+\/[!#$%&'*+.^\w|~-]+$/u,
    gi = { type: "", parameters: new Kc() };
  Object.freeze(gi.parameters);
  Object.freeze(gi);
  function wP(e) {
    if (typeof e != "string")
      throw new TypeError("argument header is required and must be a string");
    let t = e.indexOf(";"),
      r = t !== -1 ? e.slice(0, t).trim() : e.trim();
    if (bP.test(r) === !1) throw new TypeError("invalid media type");
    let n = { type: r.toLowerCase(), parameters: new Kc() };
    if (t === -1) return n;
    let s, i, o;
    for (Hc.lastIndex = t; (i = Hc.exec(e)); ) {
      if (i.index !== t) throw new TypeError("invalid parameter format");
      (t += i[0].length),
        (s = i[1].toLowerCase()),
        (o = i[2]),
        o[0] === '"' && ((o = o.slice(1, o.length - 1)), Bc.test(o) && (o = o.replace(Bc, "$1"))),
        (n.parameters[s] = o);
    }
    if (t !== e.length) throw new TypeError("invalid parameter format");
    return n;
  }
  function EP(e) {
    if (typeof e != "string") return gi;
    let t = e.indexOf(";"),
      r = t !== -1 ? e.slice(0, t).trim() : e.trim();
    if (bP.test(r) === !1) return gi;
    let n = { type: r.toLowerCase(), parameters: new Kc() };
    if (t === -1) return n;
    let s, i, o;
    for (Hc.lastIndex = t; (i = Hc.exec(e)); ) {
      if (i.index !== t) return gi;
      (t += i[0].length),
        (s = i[1].toLowerCase()),
        (o = i[2]),
        o[0] === '"' && ((o = o.slice(1, o.length - 1)), Bc.test(o) && (o = o.replace(Bc, "$1"))),
        (n.parameters[s] = o);
    }
    return t !== e.length ? gi : n;
  }
  ja.exports.default = { parse: wP, safeParse: EP };
  ja.exports.parse = wP;
  ja.exports.safeParse = EP;
  ja.exports.defaultContentType = gi;
});
var NP = b((wie, lo) => {
  "use strict";
  var e3 = typeof Buffer < "u",
    TP =
      /"(?:_|\\u005[Ff])(?:_|\\u005[Ff])(?:p|\\u0070)(?:r|\\u0072)(?:o|\\u006[Ff])(?:t|\\u0074)(?:o|\\u006[Ff])(?:_|\\u005[Ff])(?:_|\\u005[Ff])"\s*:/,
    PP =
      /"(?:c|\\u0063)(?:o|\\u006[Ff])(?:n|\\u006[Ee])(?:s|\\u0073)(?:t|\\u0074)(?:r|\\u0072)(?:u|\\u0075)(?:c|\\u0063)(?:t|\\u0074)(?:o|\\u006[Ff])(?:r|\\u0072)"\s*:/;
  function $P(e, t, r) {
    r == null && t !== null && typeof t == "object" && ((r = t), (t = void 0)),
      e3 && Buffer.isBuffer(e) && (e = e.toString()),
      e && e.charCodeAt(0) === 65279 && (e = e.slice(1));
    let n = JSON.parse(e, t);
    if (n === null || typeof n != "object") return n;
    let s = (r && r.protoAction) || "error",
      i = (r && r.constructorAction) || "error";
    if (s === "ignore" && i === "ignore") return n;
    if (s !== "ignore" && i !== "ignore") {
      if (TP.test(e) === !1 && PP.test(e) === !1) return n;
    } else if (s !== "ignore" && i === "ignore") {
      if (TP.test(e) === !1) return n;
    } else if (PP.test(e) === !1) return n;
    return OP(n, { protoAction: s, constructorAction: i, safe: r && r.safe });
  }
  function OP(e, { protoAction: t = "error", constructorAction: r = "error", safe: n } = {}) {
    let s = [e];
    for (; s.length; ) {
      let i = s;
      s = [];
      for (let o of i) {
        if (t !== "ignore" && Object.prototype.hasOwnProperty.call(o, "__proto__")) {
          if (n === !0) return null;
          if (t === "error") throw new SyntaxError("Object contains forbidden prototype property");
          delete o.__proto__;
        }
        if (
          r !== "ignore" &&
          Object.prototype.hasOwnProperty.call(o, "constructor") &&
          Object.prototype.hasOwnProperty.call(o.constructor, "prototype")
        ) {
          if (n === !0) return null;
          if (r === "error") throw new SyntaxError("Object contains forbidden prototype property");
          delete o.constructor;
        }
        for (let a in o) {
          let u = o[a];
          u && typeof u == "object" && s.push(u);
        }
      }
    }
    return e;
  }
  function Em(e, t, r) {
    let n = Error.stackTraceLimit;
    Error.stackTraceLimit = 0;
    try {
      return $P(e, t, r);
    } finally {
      Error.stackTraceLimit = n;
    }
  }
  function t3(e, t) {
    let r = Error.stackTraceLimit;
    Error.stackTraceLimit = 0;
    try {
      return $P(e, t, { safe: !0 });
    } catch {
      return null;
    } finally {
      Error.stackTraceLimit = r;
    }
  }
  lo.exports = Em;
  lo.exports.default = Em;
  lo.exports.parse = Em;
  lo.exports.safeParse = t3;
  lo.exports.scan = OP;
});
var Om = b((Eie, xa) => {
  "use strict";
  var { AsyncResource: r3 } = require("node:async_hooks"),
    { FifoMap: IP } = vP(),
    { safeParse: CP, defaultContentType: n3 } = RP(),
    s3 = NP(),
    {
      kDefaultJsonParse: La,
      kContentTypeParser: co,
      kBodyLimit: i3,
      kRequestPayloadStream: kP,
      kState: Tm,
      kTestInternals: o3,
      kReplyIsError: DP,
      kRouteContext: a3,
    } = Vt(),
    {
      FST_ERR_CTP_INVALID_TYPE: qP,
      FST_ERR_CTP_EMPTY_TYPE: u3,
      FST_ERR_CTP_ALREADY_PRESENT: l3,
      FST_ERR_CTP_INVALID_HANDLER: c3,
      FST_ERR_CTP_INVALID_PARSE_TYPE: f3,
      FST_ERR_CTP_BODY_TOO_LARGE: AP,
      FST_ERR_CTP_INVALID_MEDIA_TYPE: d3,
      FST_ERR_CTP_INVALID_CONTENT_LENGTH: h3,
      FST_ERR_CTP_EMPTY_JSON_BODY: p3,
      FST_ERR_CTP_INSTANCE_ALREADY_STARTED: Pm,
    } = tr();
  function is(e, t, r) {
    (this[La] = LP(t, r)),
      (this.customParsers = new Map()),
      this.customParsers.set("application/json", new Rm(!0, !1, e, this[La])),
      this.customParsers.set("text/plain", new Rm(!0, !1, e, $m)),
      (this.parserList = [new Gc("application/json"), new Gc("text/plain")]),
      (this.parserRegExpList = []),
      (this.cache = new IP(100));
  }
  is.prototype.add = function (e, t, r) {
    let n = typeof e == "string";
    if (!n && !(e instanceof RegExp)) throw new qP();
    if (n && e.length === 0) throw new u3();
    if (typeof r != "function") throw new c3();
    if (this.existingParser(e)) throw new l3(e);
    if (t.parseAs !== void 0 && t.parseAs !== "string" && t.parseAs !== "buffer")
      throw new f3(t.parseAs);
    let s = new Rm(t.parseAs === "string", t.parseAs === "buffer", t.bodyLimit, r);
    n && e === "*"
      ? this.customParsers.set("", s)
      : (n
          ? this.parserList.unshift(new Gc(e))
          : ((e.isEssence = e.source.indexOf(";") === -1), this.parserRegExpList.unshift(e)),
        this.customParsers.set(e.toString(), s));
  };
  is.prototype.hasParser = function (e) {
    return this.customParsers.has(typeof e == "string" ? e : e.toString());
  };
  is.prototype.existingParser = function (e) {
    return e === "application/json" && this.customParsers.has(e)
      ? this.customParsers.get(e).fn !== this[La]
      : e === "text/plain" && this.customParsers.has(e)
        ? this.customParsers.get(e).fn !== $m
        : this.hasParser(e);
  };
  is.prototype.getParser = function (e) {
    if (this.hasParser(e)) return this.customParsers.get(e);
    let t = this.cache.get(e);
    if (t !== void 0) return t;
    let r = CP(e);
    if (r === n3) return this.customParsers.get("");
    for (var n = 0; n !== this.parserList.length; ++n) {
      let i = this.parserList[n];
      if (v3(r, i)) {
        let o = this.customParsers.get(i.name);
        return this.cache.set(e, o), o;
      }
    }
    for (var s = 0; s !== this.parserRegExpList.length; ++s) {
      let i = this.parserRegExpList[s];
      if (b3(e, r.type, i)) {
        let o = this.customParsers.get(i.toString());
        return this.cache.set(e, o), o;
      }
    }
    return this.customParsers.get("");
  };
  is.prototype.removeAll = function () {
    (this.customParsers = new Map()),
      (this.parserRegExpList = []),
      (this.parserList = []),
      (this.cache = new IP(100));
  };
  is.prototype.remove = function (e) {
    if (!(typeof e == "string" || e instanceof RegExp)) throw new qP();
    let t = this.customParsers.delete(e.toString()),
      r = typeof e == "string" ? this.parserList : this.parserRegExpList,
      n = r.findIndex((s) => s.toString() === e.toString());
    return n > -1 && r.splice(n, 1), t || n > -1;
  };
  is.prototype.run = function (e, t, r, n) {
    let s = this.getParser(e);
    if (s === void 0) {
      r.is404 ? t(r, n) : n.send(new d3(e || void 0));
      return;
    }
    let i = new r3("content-type-parser:run", r);
    if (s.asString === !0 || s.asBuffer === !0) jP(r, n, n[a3]._parserOptions, s, o);
    else {
      let a = s.fn(r, r[kP], o);
      a && typeof a.then == "function" && a.then((u) => o(null, u), o);
    }
    function o(a, u) {
      i.runInAsyncScope(() => {
        i.emitDestroy(), a ? ((n[DP] = !0), n.send(a)) : ((r.body = u), t(r, n));
      });
    }
  };
  function jP(e, t, r, n, s) {
    let i = n.asString,
      o = r.limit === null ? n.bodyLimit : r.limit,
      a = e.headers["content-length"] === void 0 ? NaN : Number(e.headers["content-length"]);
    if (a > o) {
      t.header("connection", "close"), t.send(new AP());
      return;
    }
    let u = 0,
      l = i === !0 ? "" : [],
      c = e[kP] || e.raw;
    i === !0 && c.setEncoding("utf8"),
      c.on("data", f),
      c.on("end", d),
      c.on("error", d),
      c.resume();
    function f(h) {
      u += h.length;
      let { receivedEncodedLength: p = 0 } = c;
      if (u > o || p > o) {
        c.removeListener("data", f),
          c.removeListener("end", d),
          c.removeListener("error", d),
          t.send(new AP());
        return;
      }
      i === !0 ? (l += h) : l.push(h);
    }
    function d(h) {
      if (
        (c.removeListener("data", f),
        c.removeListener("end", d),
        c.removeListener("error", d),
        h !== void 0)
      ) {
        (typeof h.statusCode == "number" && h.statusCode >= 400) || (h.statusCode = 400),
          (t[DP] = !0),
          t.code(h.statusCode).send(h);
        return;
      }
      if (
        (i === !0 && (u = Buffer.byteLength(l)),
        !Number.isNaN(a) && (c.receivedEncodedLength || u) !== a)
      ) {
        t.header("connection", "close"), t.send(new h3());
        return;
      }
      i === !1 && (l = Buffer.concat(l));
      let p = n.fn(e, l, s);
      p && typeof p.then == "function" && p.then((y) => s(null, y), s);
    }
  }
  function LP(e, t) {
    return r;
    function r(n, s, i) {
      if (s === "" || s == null || (Buffer.isBuffer(s) && s.length === 0))
        return i(new p3(), void 0);
      let o;
      try {
        o = s3.parse(s, { protoAction: e, constructorAction: t });
      } catch (a) {
        return (a.statusCode = 400), i(a, void 0);
      }
      i(null, o);
    }
  }
  function $m(e, t, r) {
    r(null, t);
  }
  function Rm(e, t, r, n) {
    (this.asString = e), (this.asBuffer = t), (this.bodyLimit = r), (this.fn = n);
  }
  function m3(e) {
    let t = new is();
    return (
      (t[La] = e[La]),
      (t.customParsers = new Map(e.customParsers.entries())),
      (t.parserList = e.parserList.slice()),
      (t.parserRegExpList = e.parserRegExpList.slice()),
      t
    );
  }
  function y3(e, t, r) {
    if (this[Tm].started) throw new Pm("addContentTypeParser");
    return (
      typeof t == "function" && ((r = t), (t = {})),
      t || (t = {}),
      t.bodyLimit || (t.bodyLimit = this[i3]),
      Array.isArray(e) ? e.forEach((n) => this[co].add(n, t, r)) : this[co].add(e, t, r),
      this
    );
  }
  function g3(e) {
    return this[co].hasParser(e);
  }
  function _3(e) {
    if (this[Tm].started) throw new Pm("removeContentTypeParser");
    if (Array.isArray(e)) for (let t of e) this[co].remove(t);
    else this[co].remove(e);
  }
  function S3() {
    if (this[Tm].started) throw new Pm("removeAllContentTypeParsers");
    this[co].removeAll();
  }
  function v3(e, t) {
    if (t.isEssence) return e.type.indexOf(t) !== -1;
    if (e.type.indexOf(t.type) === -1) return !1;
    for (let r of t.parameterKeys)
      if (!(r in e.parameters) || e.parameters[r] !== t.parameters[r]) return !1;
    return !0;
  }
  function b3(e, t, r) {
    return r.isEssence ? r.test(t) : r.test(e);
  }
  function Gc(e) {
    this.name = e;
    let t = CP(e);
    if (((this.isEssence = e.indexOf(";") === -1), this.isEssence === !1 && t.type === "")) {
      let r = e.split(";", 1)[0];
      this.type = r === "" ? e : r;
    } else this.type = t.type;
    (this.parameters = t.parameters), (this.parameterKeys = Object.keys(t.parameters));
  }
  Gc.prototype.toString = function () {
    return this.name;
  };
  xa.exports = is;
  xa.exports.helpers = {
    buildContentTypeParser: m3,
    addContentTypeParser: y3,
    hasContentTypeParser: g3,
    removeContentTypeParser: _3,
    removeAllContentTypeParsers: S3,
  };
  xa.exports.defaultParsers = { getDefaultJsonParser: LP, defaultTextParser: $m };
  xa.exports[o3] = { rawBody: jP };
});
var qs = b((Rie, xP) => {
  "use strict";
  xP.exports = function e(t, r) {
    if (t === r) return !0;
    if (t && r && typeof t == "object" && typeof r == "object") {
      if (t.constructor !== r.constructor) return !1;
      var n, s, i;
      if (Array.isArray(t)) {
        if (((n = t.length), n != r.length)) return !1;
        for (s = n; s-- !== 0; ) if (!e(t[s], r[s])) return !1;
        return !0;
      }
      if (t.constructor === RegExp) return t.source === r.source && t.flags === r.flags;
      if (t.valueOf !== Object.prototype.valueOf) return t.valueOf() === r.valueOf();
      if (t.toString !== Object.prototype.toString) return t.toString() === r.toString();
      if (((i = Object.keys(t)), (n = i.length), n !== Object.keys(r).length)) return !1;
      for (s = n; s-- !== 0; ) if (!Object.prototype.hasOwnProperty.call(r, i[s])) return !1;
      for (s = n; s-- !== 0; ) {
        var o = i[s];
        if (!e(t[o], r[o])) return !1;
      }
      return !0;
    }
    return t !== t && r !== r;
  };
});
var VP = b((Tie, zP) => {
  "use strict";
  var FP = qs(),
    w3 = Symbol.for("json-schema-ref"),
    Nm = class {
      #e;
      #t;
      #n;
      #s;
      #i;
      constructor(t = {}) {
        (this.#e = {}),
          (this.#t = {}),
          (this.#n = t.insertRefSymbol ?? !1),
          (this.#s = t.allowEqualDuplicates ?? !0),
          (this.#i = t.cloneSchemaWithoutRefs ?? !1);
      }
      addSchema(t, r) {
        t.$id !== void 0 && t.$id.charAt(0) !== "#" ? (r = t.$id) : this.#l(t, r), this.#a(t, r);
      }
      getSchema(t, r = "#") {
        let n = this.#e[t];
        if (n === void 0)
          throw new Error(`Cannot resolve ref "${t}${r}". Schema with id "${t}" is not found.`);
        return n.anchors[r] !== void 0 ? n.anchors[r] : MP(n.schema, r);
      }
      hasSchema(t) {
        return this.#e[t] !== void 0;
      }
      getSchemaRefs(t) {
        let r = this.#e[t];
        if (r === void 0) throw new Error(`Schema with id "${t}" is not found.`);
        return r.refs;
      }
      getSchemaDependencies(t, r = {}) {
        let n = this.#e[t];
        for (let s of n.refs) {
          let i = s.schemaId;
          r[i] === void 0 && ((r[i] = this.getSchema(i)), this.getSchemaDependencies(i, r));
        }
        return r;
      }
      derefSchema(t) {
        if (this.#t[t] !== void 0) return;
        let r = this.#e[t];
        if (r === void 0) throw new Error(`Schema with id "${t}" is not found.`);
        !this.#i && r.refs.length === 0 && (this.#t[t] = { schema: r.schema, anchors: r.anchors });
        let n = [];
        this.#r(r.schema, t, n);
        let s = this.getSchemaDependencies(t);
        for (let i in s) {
          let o = s[i];
          this.#r(o, i, n);
        }
        for (let i of n) {
          let { refSchemaId: o, refJsonPointer: a } = this.#o(i.ref, i.sourceSchemaId),
            u = this.getDerefSchema(o, a);
          if (u === null)
            throw new Error(
              `Cannot resolve ref "${i.ref}". Ref "${a}" is not found in schema "${o}".`,
            );
          (i.targetSchema = u), (i.targetSchemaId = o);
        }
        for (let i of n) this.#u(i, n);
      }
      getDerefSchema(t, r = "#") {
        let n = this.#t[t];
        return (
          n === void 0 && (this.derefSchema(t), (n = this.#t[t])),
          n.anchors[r] !== void 0 ? n.anchors[r] : MP(n.schema, r)
        );
      }
      #o(t, r) {
        let n = t.indexOf("#");
        return n === -1
          ? { refSchemaId: t, refJsonPointer: "#" }
          : n === 0
            ? { refSchemaId: r, refJsonPointer: t }
            : { refSchemaId: t.slice(0, n), refJsonPointer: t.slice(n) };
      }
      #a(t, r) {
        let n = t.$id;
        n !== void 0 &&
          typeof n == "string" &&
          (n.charAt(0) === "#" ? this.#c(t, r, n) : (this.#l(t, n), (r = n)));
        let s = t.$ref;
        if (s !== void 0 && typeof s == "string") {
          let { refSchemaId: i, refJsonPointer: o } = this.#o(s, r);
          this.#e[r].refs.push({ schemaId: i, jsonPointer: o });
        }
        for (let i in t) typeof t[i] == "object" && t[i] !== null && this.#a(t[i], r);
      }
      #r(t, r, n = []) {
        let s = Array.isArray(t) ? [...t] : { ...t },
          i = s.$id;
        i !== void 0 &&
          typeof i == "string" &&
          (i.charAt(0) === "#" ? this.#d(s, r, i) : (this.#f(s, i), (r = i))),
          s.$ref !== void 0 && n.push({ ref: s.$ref, sourceSchemaId: r, sourceSchema: s });
        for (let o in s) {
          let a = s[o];
          typeof a == "object" && a !== null && (s[o] = this.#r(a, r, n));
        }
        return s;
      }
      #u(t, r) {
        let { sourceSchema: n, targetSchema: s } = t;
        if (n.$ref) {
          if ((this.#n && (n[w3] = n.$ref), delete n.$ref, s.$ref)) {
            let i = r.find((o) => o.sourceSchema === s);
            this.#u(i, r);
          }
          for (let i in s)
            if (i !== "$id") {
              if (n[i] !== void 0) {
                if (FP(n[i], s[i])) continue;
                throw new Error(
                  `Cannot resolve ref "${t.ref}". Property "${i}" is already exist in schema "${t.sourceSchemaId}".`,
                );
              }
              n[i] = s[i];
            }
          t.isResolved = !0;
        }
      }
      #l(t, r) {
        let n = this.#e[r];
        if (n !== void 0) {
          if (this.#s && FP(t, n.schema)) return;
          throw new Error(`There is already another schema with id "${r}".`);
        }
        this.#e[r] = { schema: t, anchors: {}, refs: [] };
      }
      #c(t, r, n) {
        let { anchors: s } = this.#e[r];
        if (s[n] !== void 0)
          throw new Error(`There is already another anchor "${n}" in a schema "${r}".`);
        s[n] = t;
      }
      #f(t, r) {
        this.#t[r] === void 0 && (this.#t[r] = { schema: t, anchors: {} });
      }
      #d(t, r, n) {
        let { anchors: s } = this.#t[r];
        s[n] = t;
      }
    };
  function MP(e, t) {
    let r = t.split("/"),
      n = e;
    for (let s of r)
      if (!(s === "" || s === "#")) {
        if (typeof n != "object" || n === null) return null;
        n = n[s];
      }
    return n ?? null;
  }
  zP.exports = { RefResolver: Nm };
});
var fo = b((He) => {
  "use strict";
  Object.defineProperty(He, "__esModule", { value: !0 });
  He.regexpCode =
    He.getEsmExportName =
    He.getProperty =
    He.safeStringify =
    He.stringify =
    He.strConcat =
    He.addCodeArg =
    He.str =
    He._ =
    He.nil =
    He._Code =
    He.Name =
    He.IDENTIFIER =
    He._CodeOrName =
      void 0;
  var Fa = class {};
  He._CodeOrName = Fa;
  He.IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;
  var _i = class extends Fa {
    constructor(t) {
      if ((super(), !He.IDENTIFIER.test(t)))
        throw new Error("CodeGen: name must be a valid identifier");
      this.str = t;
    }
    toString() {
      return this.str;
    }
    emptyStr() {
      return !1;
    }
    get names() {
      return { [this.str]: 1 };
    }
  };
  He.Name = _i;
  var en = class extends Fa {
    constructor(t) {
      super(), (this._items = typeof t == "string" ? [t] : t);
    }
    toString() {
      return this.str;
    }
    emptyStr() {
      if (this._items.length > 1) return !1;
      let t = this._items[0];
      return t === "" || t === '""';
    }
    get str() {
      var t;
      return (t = this._str) !== null && t !== void 0
        ? t
        : (this._str = this._items.reduce((r, n) => `${r}${n}`, ""));
    }
    get names() {
      var t;
      return (t = this._names) !== null && t !== void 0
        ? t
        : (this._names = this._items.reduce(
            (r, n) => (n instanceof _i && (r[n.str] = (r[n.str] || 0) + 1), r),
            {},
          ));
    }
  };
  He._Code = en;
  He.nil = new en("");
  function UP(e, ...t) {
    let r = [e[0]],
      n = 0;
    for (; n < t.length; ) Im(r, t[n]), r.push(e[++n]);
    return new en(r);
  }
  He._ = UP;
  var Am = new en("+");
  function HP(e, ...t) {
    let r = [Ma(e[0])],
      n = 0;
    for (; n < t.length; ) r.push(Am), Im(r, t[n]), r.push(Am, Ma(e[++n]));
    return E3(r), new en(r);
  }
  He.str = HP;
  function Im(e, t) {
    t instanceof en ? e.push(...t._items) : t instanceof _i ? e.push(t) : e.push(P3(t));
  }
  He.addCodeArg = Im;
  function E3(e) {
    let t = 1;
    for (; t < e.length - 1; ) {
      if (e[t] === Am) {
        let r = R3(e[t - 1], e[t + 1]);
        if (r !== void 0) {
          e.splice(t - 1, 3, r);
          continue;
        }
        e[t++] = "+";
      }
      t++;
    }
  }
  function R3(e, t) {
    if (t === '""') return e;
    if (e === '""') return t;
    if (typeof e == "string")
      return t instanceof _i || e[e.length - 1] !== '"'
        ? void 0
        : typeof t != "string"
          ? `${e.slice(0, -1)}${t}"`
          : t[0] === '"'
            ? e.slice(0, -1) + t.slice(1)
            : void 0;
    if (typeof t == "string" && t[0] === '"' && !(e instanceof _i)) return `"${e}${t.slice(1)}`;
  }
  function T3(e, t) {
    return t.emptyStr() ? e : e.emptyStr() ? t : HP`${e}${t}`;
  }
  He.strConcat = T3;
  function P3(e) {
    return typeof e == "number" || typeof e == "boolean" || e === null
      ? e
      : Ma(Array.isArray(e) ? e.join(",") : e);
  }
  function $3(e) {
    return new en(Ma(e));
  }
  He.stringify = $3;
  function Ma(e) {
    return JSON.stringify(e)
      .replace(/\u2028/g, "\\u2028")
      .replace(/\u2029/g, "\\u2029");
  }
  He.safeStringify = Ma;
  function O3(e) {
    return typeof e == "string" && He.IDENTIFIER.test(e) ? new en(`.${e}`) : UP`[${e}]`;
  }
  He.getProperty = O3;
  function N3(e) {
    if (typeof e == "string" && He.IDENTIFIER.test(e)) return new en(`${e}`);
    throw new Error(`CodeGen: invalid export name: ${e}, use explicit $id name mapping`);
  }
  He.getEsmExportName = N3;
  function A3(e) {
    return new en(e.toString());
  }
  He.regexpCode = A3;
});
var Yc = b((Ar) => {
  "use strict";
  Object.defineProperty(Ar, "__esModule", { value: !0 });
  Ar.ValueScope = Ar.ValueScopeName = Ar.Scope = Ar.varKinds = Ar.UsedValueState = void 0;
  var Nr = fo(),
    Cm = class extends Error {
      constructor(t) {
        super(`CodeGen: "code" for ${t} not defined`), (this.value = t.value);
      }
    },
    Jc;
  (function (e) {
    (e[(e.Started = 0)] = "Started"), (e[(e.Completed = 1)] = "Completed");
  })(Jc || (Ar.UsedValueState = Jc = {}));
  Ar.varKinds = { const: new Nr.Name("const"), let: new Nr.Name("let"), var: new Nr.Name("var") };
  var Qc = class {
    constructor({ prefixes: t, parent: r } = {}) {
      (this._names = {}), (this._prefixes = t), (this._parent = r);
    }
    toName(t) {
      return t instanceof Nr.Name ? t : this.name(t);
    }
    name(t) {
      return new Nr.Name(this._newName(t));
    }
    _newName(t) {
      let r = this._names[t] || this._nameGroup(t);
      return `${t}${r.index++}`;
    }
    _nameGroup(t) {
      var r, n;
      if (
        (!(
          (n = (r = this._parent) === null || r === void 0 ? void 0 : r._prefixes) === null ||
          n === void 0
        ) &&
          n.has(t)) ||
        (this._prefixes && !this._prefixes.has(t))
      )
        throw new Error(`CodeGen: prefix "${t}" is not allowed in this scope`);
      return (this._names[t] = { prefix: t, index: 0 });
    }
  };
  Ar.Scope = Qc;
  var Wc = class extends Nr.Name {
    constructor(t, r) {
      super(r), (this.prefix = t);
    }
    setValue(t, { property: r, itemIndex: n }) {
      (this.value = t), (this.scopePath = (0, Nr._)`.${new Nr.Name(r)}[${n}]`);
    }
  };
  Ar.ValueScopeName = Wc;
  var I3 = (0, Nr._)`\n`,
    km = class extends Qc {
      constructor(t) {
        super(t),
          (this._values = {}),
          (this._scope = t.scope),
          (this.opts = { ...t, _n: t.lines ? I3 : Nr.nil });
      }
      get() {
        return this._scope;
      }
      name(t) {
        return new Wc(t, this._newName(t));
      }
      value(t, r) {
        var n;
        if (r.ref === void 0) throw new Error("CodeGen: ref must be passed in value");
        let s = this.toName(t),
          { prefix: i } = s,
          o = (n = r.key) !== null && n !== void 0 ? n : r.ref,
          a = this._values[i];
        if (a) {
          let c = a.get(o);
          if (c) return c;
        } else a = this._values[i] = new Map();
        a.set(o, s);
        let u = this._scope[i] || (this._scope[i] = []),
          l = u.length;
        return (u[l] = r.ref), s.setValue(r, { property: i, itemIndex: l }), s;
      }
      getValue(t, r) {
        let n = this._values[t];
        if (n) return n.get(r);
      }
      scopeRefs(t, r = this._values) {
        return this._reduceValues(r, (n) => {
          if (n.scopePath === void 0) throw new Error(`CodeGen: name "${n}" has no value`);
          return (0, Nr._)`${t}${n.scopePath}`;
        });
      }
      scopeCode(t = this._values, r, n) {
        return this._reduceValues(
          t,
          (s) => {
            if (s.value === void 0) throw new Error(`CodeGen: name "${s}" has no value`);
            return s.value.code;
          },
          r,
          n,
        );
      }
      _reduceValues(t, r, n = {}, s) {
        let i = Nr.nil;
        for (let o in t) {
          let a = t[o];
          if (!a) continue;
          let u = (n[o] = n[o] || new Map());
          a.forEach((l) => {
            if (u.has(l)) return;
            u.set(l, Jc.Started);
            let c = r(l);
            if (c) {
              let f = this.opts.es5 ? Ar.varKinds.var : Ar.varKinds.const;
              i = (0, Nr._)`${i}${f} ${l} = ${c};${this.opts._n}`;
            } else if ((c = s?.(l))) i = (0, Nr._)`${i}${c}${this.opts._n}`;
            else throw new Cm(l);
            u.set(l, Jc.Completed);
          });
        }
        return i;
      }
    };
  Ar.ValueScope = km;
});
var he = b((Ce) => {
  "use strict";
  Object.defineProperty(Ce, "__esModule", { value: !0 });
  Ce.or =
    Ce.and =
    Ce.not =
    Ce.CodeGen =
    Ce.operators =
    Ce.varKinds =
    Ce.ValueScopeName =
    Ce.ValueScope =
    Ce.Scope =
    Ce.Name =
    Ce.regexpCode =
    Ce.stringify =
    Ce.getProperty =
    Ce.nil =
    Ce.strConcat =
    Ce.str =
    Ce._ =
      void 0;
  var Fe = fo(),
    yn = Yc(),
    js = fo();
  Object.defineProperty(Ce, "_", {
    enumerable: !0,
    get: function () {
      return js._;
    },
  });
  Object.defineProperty(Ce, "str", {
    enumerable: !0,
    get: function () {
      return js.str;
    },
  });
  Object.defineProperty(Ce, "strConcat", {
    enumerable: !0,
    get: function () {
      return js.strConcat;
    },
  });
  Object.defineProperty(Ce, "nil", {
    enumerable: !0,
    get: function () {
      return js.nil;
    },
  });
  Object.defineProperty(Ce, "getProperty", {
    enumerable: !0,
    get: function () {
      return js.getProperty;
    },
  });
  Object.defineProperty(Ce, "stringify", {
    enumerable: !0,
    get: function () {
      return js.stringify;
    },
  });
  Object.defineProperty(Ce, "regexpCode", {
    enumerable: !0,
    get: function () {
      return js.regexpCode;
    },
  });
  Object.defineProperty(Ce, "Name", {
    enumerable: !0,
    get: function () {
      return js.Name;
    },
  });
  var tf = Yc();
  Object.defineProperty(Ce, "Scope", {
    enumerable: !0,
    get: function () {
      return tf.Scope;
    },
  });
  Object.defineProperty(Ce, "ValueScope", {
    enumerable: !0,
    get: function () {
      return tf.ValueScope;
    },
  });
  Object.defineProperty(Ce, "ValueScopeName", {
    enumerable: !0,
    get: function () {
      return tf.ValueScopeName;
    },
  });
  Object.defineProperty(Ce, "varKinds", {
    enumerable: !0,
    get: function () {
      return tf.varKinds;
    },
  });
  Ce.operators = {
    GT: new Fe._Code(">"),
    GTE: new Fe._Code(">="),
    LT: new Fe._Code("<"),
    LTE: new Fe._Code("<="),
    EQ: new Fe._Code("==="),
    NEQ: new Fe._Code("!=="),
    NOT: new Fe._Code("!"),
    OR: new Fe._Code("||"),
    AND: new Fe._Code("&&"),
    ADD: new Fe._Code("+"),
  };
  var os = class {
      optimizeNodes() {
        return this;
      }
      optimizeNames(t, r) {
        return this;
      }
    },
    Dm = class extends os {
      constructor(t, r, n) {
        super(), (this.varKind = t), (this.name = r), (this.rhs = n);
      }
      render({ es5: t, _n: r }) {
        let n = t ? yn.varKinds.var : this.varKind,
          s = this.rhs === void 0 ? "" : ` = ${this.rhs}`;
        return `${n} ${this.name}${s};` + r;
      }
      optimizeNames(t, r) {
        if (t[this.name.str]) return this.rhs && (this.rhs = po(this.rhs, t, r)), this;
      }
      get names() {
        return this.rhs instanceof Fe._CodeOrName ? this.rhs.names : {};
      }
    },
    Xc = class extends os {
      constructor(t, r, n) {
        super(), (this.lhs = t), (this.rhs = r), (this.sideEffects = n);
      }
      render({ _n: t }) {
        return `${this.lhs} = ${this.rhs};` + t;
      }
      optimizeNames(t, r) {
        if (!(this.lhs instanceof Fe.Name && !t[this.lhs.str] && !this.sideEffects))
          return (this.rhs = po(this.rhs, t, r)), this;
      }
      get names() {
        let t = this.lhs instanceof Fe.Name ? {} : { ...this.lhs.names };
        return ef(t, this.rhs);
      }
    },
    qm = class extends Xc {
      constructor(t, r, n, s) {
        super(t, n, s), (this.op = r);
      }
      render({ _n: t }) {
        return `${this.lhs} ${this.op}= ${this.rhs};` + t;
      }
    },
    jm = class extends os {
      constructor(t) {
        super(), (this.label = t), (this.names = {});
      }
      render({ _n: t }) {
        return `${this.label}:` + t;
      }
    },
    Lm = class extends os {
      constructor(t) {
        super(), (this.label = t), (this.names = {});
      }
      render({ _n: t }) {
        return `break${this.label ? ` ${this.label}` : ""};` + t;
      }
    },
    xm = class extends os {
      constructor(t) {
        super(), (this.error = t);
      }
      render({ _n: t }) {
        return `throw ${this.error};` + t;
      }
      get names() {
        return this.error.names;
      }
    },
    Fm = class extends os {
      constructor(t) {
        super(), (this.code = t);
      }
      render({ _n: t }) {
        return `${this.code};` + t;
      }
      optimizeNodes() {
        return `${this.code}` ? this : void 0;
      }
      optimizeNames(t, r) {
        return (this.code = po(this.code, t, r)), this;
      }
      get names() {
        return this.code instanceof Fe._CodeOrName ? this.code.names : {};
      }
    },
    za = class extends os {
      constructor(t = []) {
        super(), (this.nodes = t);
      }
      render(t) {
        return this.nodes.reduce((r, n) => r + n.render(t), "");
      }
      optimizeNodes() {
        let { nodes: t } = this,
          r = t.length;
        for (; r--; ) {
          let n = t[r].optimizeNodes();
          Array.isArray(n) ? t.splice(r, 1, ...n) : n ? (t[r] = n) : t.splice(r, 1);
        }
        return t.length > 0 ? this : void 0;
      }
      optimizeNames(t, r) {
        let { nodes: n } = this,
          s = n.length;
        for (; s--; ) {
          let i = n[s];
          i.optimizeNames(t, r) || (C3(t, i.names), n.splice(s, 1));
        }
        return n.length > 0 ? this : void 0;
      }
      get names() {
        return this.nodes.reduce((t, r) => bi(t, r.names), {});
      }
    },
    as = class extends za {
      render(t) {
        return "{" + t._n + super.render(t) + "}" + t._n;
      }
    },
    Mm = class extends za {},
    ho = class extends as {};
  ho.kind = "else";
  var Si = class e extends as {
    constructor(t, r) {
      super(r), (this.condition = t);
    }
    render(t) {
      let r = `if(${this.condition})` + super.render(t);
      return this.else && (r += "else " + this.else.render(t)), r;
    }
    optimizeNodes() {
      super.optimizeNodes();
      let t = this.condition;
      if (t === !0) return this.nodes;
      let r = this.else;
      if (r) {
        let n = r.optimizeNodes();
        r = this.else = Array.isArray(n) ? new ho(n) : n;
      }
      if (r)
        return t === !1
          ? r instanceof e
            ? r
            : r.nodes
          : this.nodes.length
            ? this
            : new e(BP(t), r instanceof e ? [r] : r.nodes);
      if (!(t === !1 || !this.nodes.length)) return this;
    }
    optimizeNames(t, r) {
      var n;
      if (
        ((this.else = (n = this.else) === null || n === void 0 ? void 0 : n.optimizeNames(t, r)),
        !!(super.optimizeNames(t, r) || this.else))
      )
        return (this.condition = po(this.condition, t, r)), this;
    }
    get names() {
      let t = super.names;
      return ef(t, this.condition), this.else && bi(t, this.else.names), t;
    }
  };
  Si.kind = "if";
  var vi = class extends as {};
  vi.kind = "for";
  var zm = class extends vi {
      constructor(t) {
        super(), (this.iteration = t);
      }
      render(t) {
        return `for(${this.iteration})` + super.render(t);
      }
      optimizeNames(t, r) {
        if (super.optimizeNames(t, r)) return (this.iteration = po(this.iteration, t, r)), this;
      }
      get names() {
        return bi(super.names, this.iteration.names);
      }
    },
    Vm = class extends vi {
      constructor(t, r, n, s) {
        super(), (this.varKind = t), (this.name = r), (this.from = n), (this.to = s);
      }
      render(t) {
        let r = t.es5 ? yn.varKinds.var : this.varKind,
          { name: n, from: s, to: i } = this;
        return `for(${r} ${n}=${s}; ${n}<${i}; ${n}++)` + super.render(t);
      }
      get names() {
        let t = ef(super.names, this.from);
        return ef(t, this.to);
      }
    },
    Zc = class extends vi {
      constructor(t, r, n, s) {
        super(), (this.loop = t), (this.varKind = r), (this.name = n), (this.iterable = s);
      }
      render(t) {
        return `for(${this.varKind} ${this.name} ${this.loop} ${this.iterable})` + super.render(t);
      }
      optimizeNames(t, r) {
        if (super.optimizeNames(t, r)) return (this.iterable = po(this.iterable, t, r)), this;
      }
      get names() {
        return bi(super.names, this.iterable.names);
      }
    },
    Va = class extends as {
      constructor(t, r, n) {
        super(), (this.name = t), (this.args = r), (this.async = n);
      }
      render(t) {
        return `${this.async ? "async " : ""}function ${this.name}(${this.args})` + super.render(t);
      }
    };
  Va.kind = "func";
  var Ua = class extends za {
    render(t) {
      return "return " + super.render(t);
    }
  };
  Ua.kind = "return";
  var Um = class extends as {
      render(t) {
        let r = "try" + super.render(t);
        return (
          this.catch && (r += this.catch.render(t)),
          this.finally && (r += this.finally.render(t)),
          r
        );
      }
      optimizeNodes() {
        var t, r;
        return (
          super.optimizeNodes(),
          (t = this.catch) === null || t === void 0 || t.optimizeNodes(),
          (r = this.finally) === null || r === void 0 || r.optimizeNodes(),
          this
        );
      }
      optimizeNames(t, r) {
        var n, s;
        return (
          super.optimizeNames(t, r),
          (n = this.catch) === null || n === void 0 || n.optimizeNames(t, r),
          (s = this.finally) === null || s === void 0 || s.optimizeNames(t, r),
          this
        );
      }
      get names() {
        let t = super.names;
        return this.catch && bi(t, this.catch.names), this.finally && bi(t, this.finally.names), t;
      }
    },
    Ha = class extends as {
      constructor(t) {
        super(), (this.error = t);
      }
      render(t) {
        return `catch(${this.error})` + super.render(t);
      }
    };
  Ha.kind = "catch";
  var Ba = class extends as {
    render(t) {
      return "finally" + super.render(t);
    }
  };
  Ba.kind = "finally";
  var Hm = class {
    constructor(t, r = {}) {
      (this._values = {}),
        (this._blockStarts = []),
        (this._constants = {}),
        (this.opts = {
          ...r,
          _n: r.lines
            ? `
`
            : "",
        }),
        (this._extScope = t),
        (this._scope = new yn.Scope({ parent: t })),
        (this._nodes = [new Mm()]);
    }
    toString() {
      return this._root.render(this.opts);
    }
    name(t) {
      return this._scope.name(t);
    }
    scopeName(t) {
      return this._extScope.name(t);
    }
    scopeValue(t, r) {
      let n = this._extScope.value(t, r);
      return (this._values[n.prefix] || (this._values[n.prefix] = new Set())).add(n), n;
    }
    getScopeValue(t, r) {
      return this._extScope.getValue(t, r);
    }
    scopeRefs(t) {
      return this._extScope.scopeRefs(t, this._values);
    }
    scopeCode() {
      return this._extScope.scopeCode(this._values);
    }
    _def(t, r, n, s) {
      let i = this._scope.toName(r);
      return n !== void 0 && s && (this._constants[i.str] = n), this._leafNode(new Dm(t, i, n)), i;
    }
    const(t, r, n) {
      return this._def(yn.varKinds.const, t, r, n);
    }
    let(t, r, n) {
      return this._def(yn.varKinds.let, t, r, n);
    }
    var(t, r, n) {
      return this._def(yn.varKinds.var, t, r, n);
    }
    assign(t, r, n) {
      return this._leafNode(new Xc(t, r, n));
    }
    add(t, r) {
      return this._leafNode(new qm(t, Ce.operators.ADD, r));
    }
    code(t) {
      return typeof t == "function" ? t() : t !== Fe.nil && this._leafNode(new Fm(t)), this;
    }
    object(...t) {
      let r = ["{"];
      for (let [n, s] of t)
        r.length > 1 && r.push(","),
          r.push(n),
          (n !== s || this.opts.es5) && (r.push(":"), (0, Fe.addCodeArg)(r, s));
      return r.push("}"), new Fe._Code(r);
    }
    if(t, r, n) {
      if ((this._blockNode(new Si(t)), r && n)) this.code(r).else().code(n).endIf();
      else if (r) this.code(r).endIf();
      else if (n) throw new Error('CodeGen: "else" body without "then" body');
      return this;
    }
    elseIf(t) {
      return this._elseNode(new Si(t));
    }
    else() {
      return this._elseNode(new ho());
    }
    endIf() {
      return this._endBlockNode(Si, ho);
    }
    _for(t, r) {
      return this._blockNode(t), r && this.code(r).endFor(), this;
    }
    for(t, r) {
      return this._for(new zm(t), r);
    }
    forRange(t, r, n, s, i = this.opts.es5 ? yn.varKinds.var : yn.varKinds.let) {
      let o = this._scope.toName(t);
      return this._for(new Vm(i, o, r, n), () => s(o));
    }
    forOf(t, r, n, s = yn.varKinds.const) {
      let i = this._scope.toName(t);
      if (this.opts.es5) {
        let o = r instanceof Fe.Name ? r : this.var("_arr", r);
        return this.forRange("_i", 0, (0, Fe._)`${o}.length`, (a) => {
          this.var(i, (0, Fe._)`${o}[${a}]`), n(i);
        });
      }
      return this._for(new Zc("of", s, i, r), () => n(i));
    }
    forIn(t, r, n, s = this.opts.es5 ? yn.varKinds.var : yn.varKinds.const) {
      if (this.opts.ownProperties) return this.forOf(t, (0, Fe._)`Object.keys(${r})`, n);
      let i = this._scope.toName(t);
      return this._for(new Zc("in", s, i, r), () => n(i));
    }
    endFor() {
      return this._endBlockNode(vi);
    }
    label(t) {
      return this._leafNode(new jm(t));
    }
    break(t) {
      return this._leafNode(new Lm(t));
    }
    return(t) {
      let r = new Ua();
      if ((this._blockNode(r), this.code(t), r.nodes.length !== 1))
        throw new Error('CodeGen: "return" should have one node');
      return this._endBlockNode(Ua);
    }
    try(t, r, n) {
      if (!r && !n) throw new Error('CodeGen: "try" without "catch" and "finally"');
      let s = new Um();
      if ((this._blockNode(s), this.code(t), r)) {
        let i = this.name("e");
        (this._currNode = s.catch = new Ha(i)), r(i);
      }
      return (
        n && ((this._currNode = s.finally = new Ba()), this.code(n)), this._endBlockNode(Ha, Ba)
      );
    }
    throw(t) {
      return this._leafNode(new xm(t));
    }
    block(t, r) {
      return this._blockStarts.push(this._nodes.length), t && this.code(t).endBlock(r), this;
    }
    endBlock(t) {
      let r = this._blockStarts.pop();
      if (r === void 0) throw new Error("CodeGen: not in self-balancing block");
      let n = this._nodes.length - r;
      if (n < 0 || (t !== void 0 && n !== t))
        throw new Error(`CodeGen: wrong number of nodes: ${n} vs ${t} expected`);
      return (this._nodes.length = r), this;
    }
    func(t, r = Fe.nil, n, s) {
      return this._blockNode(new Va(t, r, n)), s && this.code(s).endFunc(), this;
    }
    endFunc() {
      return this._endBlockNode(Va);
    }
    optimize(t = 1) {
      for (; t-- > 0; )
        this._root.optimizeNodes(), this._root.optimizeNames(this._root.names, this._constants);
    }
    _leafNode(t) {
      return this._currNode.nodes.push(t), this;
    }
    _blockNode(t) {
      this._currNode.nodes.push(t), this._nodes.push(t);
    }
    _endBlockNode(t, r) {
      let n = this._currNode;
      if (n instanceof t || (r && n instanceof r)) return this._nodes.pop(), this;
      throw new Error(`CodeGen: not in block "${r ? `${t.kind}/${r.kind}` : t.kind}"`);
    }
    _elseNode(t) {
      let r = this._currNode;
      if (!(r instanceof Si)) throw new Error('CodeGen: "else" without "if"');
      return (this._currNode = r.else = t), this;
    }
    get _root() {
      return this._nodes[0];
    }
    get _currNode() {
      let t = this._nodes;
      return t[t.length - 1];
    }
    set _currNode(t) {
      let r = this._nodes;
      r[r.length - 1] = t;
    }
  };
  Ce.CodeGen = Hm;
  function bi(e, t) {
    for (let r in t) e[r] = (e[r] || 0) + (t[r] || 0);
    return e;
  }
  function ef(e, t) {
    return t instanceof Fe._CodeOrName ? bi(e, t.names) : e;
  }
  function po(e, t, r) {
    if (e instanceof Fe.Name) return n(e);
    if (!s(e)) return e;
    return new Fe._Code(
      e._items.reduce(
        (i, o) => (
          o instanceof Fe.Name && (o = n(o)),
          o instanceof Fe._Code ? i.push(...o._items) : i.push(o),
          i
        ),
        [],
      ),
    );
    function n(i) {
      let o = r[i.str];
      return o === void 0 || t[i.str] !== 1 ? i : (delete t[i.str], o);
    }
    function s(i) {
      return (
        i instanceof Fe._Code &&
        i._items.some((o) => o instanceof Fe.Name && t[o.str] === 1 && r[o.str] !== void 0)
      );
    }
  }
  function C3(e, t) {
    for (let r in t) e[r] = (e[r] || 0) - (t[r] || 0);
  }
  function BP(e) {
    return typeof e == "boolean" || typeof e == "number" || e === null ? !e : (0, Fe._)`!${Bm(e)}`;
  }
  Ce.not = BP;
  var k3 = KP(Ce.operators.AND);
  function D3(...e) {
    return e.reduce(k3);
  }
  Ce.and = D3;
  var q3 = KP(Ce.operators.OR);
  function j3(...e) {
    return e.reduce(q3);
  }
  Ce.or = j3;
  function KP(e) {
    return (t, r) => (t === Fe.nil ? r : r === Fe.nil ? t : (0, Fe._)`${Bm(t)} ${e} ${Bm(r)}`);
  }
  function Bm(e) {
    return e instanceof Fe.Name ? e : (0, Fe._)`(${e})`;
  }
});
var Ie = b((De) => {
  "use strict";
  Object.defineProperty(De, "__esModule", { value: !0 });
  De.checkStrictMode =
    De.getErrorPath =
    De.Type =
    De.useFunc =
    De.setEvaluated =
    De.evaluatedPropsToName =
    De.mergeEvaluated =
    De.eachItem =
    De.unescapeJsonPointer =
    De.escapeJsonPointer =
    De.escapeFragment =
    De.unescapeFragment =
    De.schemaRefOrVal =
    De.schemaHasRulesButRef =
    De.schemaHasRules =
    De.checkUnknownRules =
    De.alwaysValidSchema =
    De.toHash =
      void 0;
  var it = he(),
    L3 = fo();
  function x3(e) {
    let t = {};
    for (let r of e) t[r] = !0;
    return t;
  }
  De.toHash = x3;
  function F3(e, t) {
    return typeof t == "boolean"
      ? t
      : Object.keys(t).length === 0
        ? !0
        : (QP(e, t), !WP(t, e.self.RULES.all));
  }
  De.alwaysValidSchema = F3;
  function QP(e, t = e.schema) {
    let { opts: r, self: n } = e;
    if (!r.strictSchema || typeof t == "boolean") return;
    let s = n.RULES.keywords;
    for (let i in t) s[i] || ZP(e, `unknown keyword: "${i}"`);
  }
  De.checkUnknownRules = QP;
  function WP(e, t) {
    if (typeof e == "boolean") return !e;
    for (let r in e) if (t[r]) return !0;
    return !1;
  }
  De.schemaHasRules = WP;
  function M3(e, t) {
    if (typeof e == "boolean") return !e;
    for (let r in e) if (r !== "$ref" && t.all[r]) return !0;
    return !1;
  }
  De.schemaHasRulesButRef = M3;
  function z3({ topSchemaRef: e, schemaPath: t }, r, n, s) {
    if (!s) {
      if (typeof r == "number" || typeof r == "boolean") return r;
      if (typeof r == "string") return (0, it._)`${r}`;
    }
    return (0, it._)`${e}${t}${(0, it.getProperty)(n)}`;
  }
  De.schemaRefOrVal = z3;
  function V3(e) {
    return YP(decodeURIComponent(e));
  }
  De.unescapeFragment = V3;
  function U3(e) {
    return encodeURIComponent(Gm(e));
  }
  De.escapeFragment = U3;
  function Gm(e) {
    return typeof e == "number" ? `${e}` : e.replace(/~/g, "~0").replace(/\//g, "~1");
  }
  De.escapeJsonPointer = Gm;
  function YP(e) {
    return e.replace(/~1/g, "/").replace(/~0/g, "~");
  }
  De.unescapeJsonPointer = YP;
  function H3(e, t) {
    if (Array.isArray(e)) for (let r of e) t(r);
    else t(e);
  }
  De.eachItem = H3;
  function GP({ mergeNames: e, mergeToName: t, mergeValues: r, resultToName: n }) {
    return (s, i, o, a) => {
      let u =
        o === void 0
          ? i
          : o instanceof it.Name
            ? (i instanceof it.Name ? e(s, i, o) : t(s, i, o), o)
            : i instanceof it.Name
              ? (t(s, o, i), i)
              : r(i, o);
      return a === it.Name && !(u instanceof it.Name) ? n(s, u) : u;
    };
  }
  De.mergeEvaluated = {
    props: GP({
      mergeNames: (e, t, r) =>
        e.if((0, it._)`${r} !== true && ${t} !== undefined`, () => {
          e.if(
            (0, it._)`${t} === true`,
            () => e.assign(r, !0),
            () => e.assign(r, (0, it._)`${r} || {}`).code((0, it._)`Object.assign(${r}, ${t})`),
          );
        }),
      mergeToName: (e, t, r) =>
        e.if((0, it._)`${r} !== true`, () => {
          t === !0 ? e.assign(r, !0) : (e.assign(r, (0, it._)`${r} || {}`), Jm(e, r, t));
        }),
      mergeValues: (e, t) => (e === !0 ? !0 : { ...e, ...t }),
      resultToName: XP,
    }),
    items: GP({
      mergeNames: (e, t, r) =>
        e.if((0, it._)`${r} !== true && ${t} !== undefined`, () =>
          e.assign(r, (0, it._)`${t} === true ? true : ${r} > ${t} ? ${r} : ${t}`),
        ),
      mergeToName: (e, t, r) =>
        e.if((0, it._)`${r} !== true`, () =>
          e.assign(r, t === !0 ? !0 : (0, it._)`${r} > ${t} ? ${r} : ${t}`),
        ),
      mergeValues: (e, t) => (e === !0 ? !0 : Math.max(e, t)),
      resultToName: (e, t) => e.var("items", t),
    }),
  };
  function XP(e, t) {
    if (t === !0) return e.var("props", !0);
    let r = e.var("props", (0, it._)`{}`);
    return t !== void 0 && Jm(e, r, t), r;
  }
  De.evaluatedPropsToName = XP;
  function Jm(e, t, r) {
    Object.keys(r).forEach((n) => e.assign((0, it._)`${t}${(0, it.getProperty)(n)}`, !0));
  }
  De.setEvaluated = Jm;
  var JP = {};
  function B3(e, t) {
    return e.scopeValue("func", {
      ref: t,
      code: JP[t.code] || (JP[t.code] = new L3._Code(t.code)),
    });
  }
  De.useFunc = B3;
  var Km;
  (function (e) {
    (e[(e.Num = 0)] = "Num"), (e[(e.Str = 1)] = "Str");
  })(Km || (De.Type = Km = {}));
  function K3(e, t, r) {
    if (e instanceof it.Name) {
      let n = t === Km.Num;
      return r
        ? n
          ? (0, it._)`"[" + ${e} + "]"`
          : (0, it._)`"['" + ${e} + "']"`
        : n
          ? (0, it._)`"/" + ${e}`
          : (0, it._)`"/" + ${e}.replace(/~/g, "~0").replace(/\\//g, "~1")`;
    }
    return r ? (0, it.getProperty)(e).toString() : "/" + Gm(e);
  }
  De.getErrorPath = K3;
  function ZP(e, t, r = e.opts.strictSchema) {
    if (r) {
      if (((t = `strict mode: ${t}`), r === !0)) throw new Error(t);
      e.self.logger.warn(t);
    }
  }
  De.checkStrictMode = ZP;
});
var tn = b((Qm) => {
  "use strict";
  Object.defineProperty(Qm, "__esModule", { value: !0 });
  var sr = he(),
    G3 = {
      data: new sr.Name("data"),
      valCxt: new sr.Name("valCxt"),
      instancePath: new sr.Name("instancePath"),
      parentData: new sr.Name("parentData"),
      parentDataProperty: new sr.Name("parentDataProperty"),
      rootData: new sr.Name("rootData"),
      dynamicAnchors: new sr.Name("dynamicAnchors"),
      vErrors: new sr.Name("vErrors"),
      errors: new sr.Name("errors"),
      this: new sr.Name("this"),
      self: new sr.Name("self"),
      scope: new sr.Name("scope"),
      json: new sr.Name("json"),
      jsonPos: new sr.Name("jsonPos"),
      jsonLen: new sr.Name("jsonLen"),
      jsonPart: new sr.Name("jsonPart"),
    };
  Qm.default = G3;
});
var Ka = b((ir) => {
  "use strict";
  Object.defineProperty(ir, "__esModule", { value: !0 });
  ir.extendErrors =
    ir.resetErrorsCount =
    ir.reportExtraError =
    ir.reportError =
    ir.keyword$DataError =
    ir.keywordError =
      void 0;
  var Ue = he(),
    rf = Ie(),
    gr = tn();
  ir.keywordError = {
    message: ({ keyword: e }) => (0, Ue.str)`must pass "${e}" keyword validation`,
  };
  ir.keyword$DataError = {
    message: ({ keyword: e, schemaType: t }) =>
      t
        ? (0, Ue.str)`"${e}" keyword must be ${t} ($data)`
        : (0, Ue.str)`"${e}" keyword is invalid ($data)`,
  };
  function J3(e, t = ir.keywordError, r, n) {
    let { it: s } = e,
      { gen: i, compositeRule: o, allErrors: a } = s,
      u = r$(e, t, r);
    n ?? (o || a) ? e$(i, u) : t$(s, (0, Ue._)`[${u}]`);
  }
  ir.reportError = J3;
  function Q3(e, t = ir.keywordError, r) {
    let { it: n } = e,
      { gen: s, compositeRule: i, allErrors: o } = n,
      a = r$(e, t, r);
    e$(s, a), i || o || t$(n, gr.default.vErrors);
  }
  ir.reportExtraError = Q3;
  function W3(e, t) {
    e.assign(gr.default.errors, t),
      e.if((0, Ue._)`${gr.default.vErrors} !== null`, () =>
        e.if(
          t,
          () => e.assign((0, Ue._)`${gr.default.vErrors}.length`, t),
          () => e.assign(gr.default.vErrors, null),
        ),
      );
  }
  ir.resetErrorsCount = W3;
  function Y3({ gen: e, keyword: t, schemaValue: r, data: n, errsCount: s, it: i }) {
    if (s === void 0) throw new Error("ajv implementation error");
    let o = e.name("err");
    e.forRange("i", s, gr.default.errors, (a) => {
      e.const(o, (0, Ue._)`${gr.default.vErrors}[${a}]`),
        e.if((0, Ue._)`${o}.instancePath === undefined`, () =>
          e.assign(
            (0, Ue._)`${o}.instancePath`,
            (0, Ue.strConcat)(gr.default.instancePath, i.errorPath),
          ),
        ),
        e.assign((0, Ue._)`${o}.schemaPath`, (0, Ue.str)`${i.errSchemaPath}/${t}`),
        i.opts.verbose && (e.assign((0, Ue._)`${o}.schema`, r), e.assign((0, Ue._)`${o}.data`, n));
    });
  }
  ir.extendErrors = Y3;
  function e$(e, t) {
    let r = e.const("err", t);
    e.if(
      (0, Ue._)`${gr.default.vErrors} === null`,
      () => e.assign(gr.default.vErrors, (0, Ue._)`[${r}]`),
      (0, Ue._)`${gr.default.vErrors}.push(${r})`,
    ),
      e.code((0, Ue._)`${gr.default.errors}++`);
  }
  function t$(e, t) {
    let { gen: r, validateName: n, schemaEnv: s } = e;
    s.$async
      ? r.throw((0, Ue._)`new ${e.ValidationError}(${t})`)
      : (r.assign((0, Ue._)`${n}.errors`, t), r.return(!1));
  }
  var wi = {
    keyword: new Ue.Name("keyword"),
    schemaPath: new Ue.Name("schemaPath"),
    params: new Ue.Name("params"),
    propertyName: new Ue.Name("propertyName"),
    message: new Ue.Name("message"),
    schema: new Ue.Name("schema"),
    parentSchema: new Ue.Name("parentSchema"),
  };
  function r$(e, t, r) {
    let { createErrors: n } = e.it;
    return n === !1 ? (0, Ue._)`{}` : X3(e, t, r);
  }
  function X3(e, t, r = {}) {
    let { gen: n, it: s } = e,
      i = [Z3(s, r), e9(e, r)];
    return t9(e, t, i), n.object(...i);
  }
  function Z3({ errorPath: e }, { instancePath: t }) {
    let r = t ? (0, Ue.str)`${e}${(0, rf.getErrorPath)(t, rf.Type.Str)}` : e;
    return [gr.default.instancePath, (0, Ue.strConcat)(gr.default.instancePath, r)];
  }
  function e9({ keyword: e, it: { errSchemaPath: t } }, { schemaPath: r, parentSchema: n }) {
    let s = n ? t : (0, Ue.str)`${t}/${e}`;
    return r && (s = (0, Ue.str)`${s}${(0, rf.getErrorPath)(r, rf.Type.Str)}`), [wi.schemaPath, s];
  }
  function t9(e, { params: t, message: r }, n) {
    let { keyword: s, data: i, schemaValue: o, it: a } = e,
      { opts: u, propertyName: l, topSchemaRef: c, schemaPath: f } = a;
    n.push([wi.keyword, s], [wi.params, typeof t == "function" ? t(e) : t || (0, Ue._)`{}`]),
      u.messages && n.push([wi.message, typeof r == "function" ? r(e) : r]),
      u.verbose &&
        n.push([wi.schema, o], [wi.parentSchema, (0, Ue._)`${c}${f}`], [gr.default.data, i]),
      l && n.push([wi.propertyName, l]);
  }
});
var s$ = b((mo) => {
  "use strict";
  Object.defineProperty(mo, "__esModule", { value: !0 });
  mo.boolOrEmptySchema = mo.topBoolOrEmptySchema = void 0;
  var r9 = Ka(),
    n9 = he(),
    s9 = tn(),
    i9 = { message: "boolean schema is false" };
  function o9(e) {
    let { gen: t, schema: r, validateName: n } = e;
    r === !1
      ? n$(e, !1)
      : typeof r == "object" && r.$async === !0
        ? t.return(s9.default.data)
        : (t.assign((0, n9._)`${n}.errors`, null), t.return(!0));
  }
  mo.topBoolOrEmptySchema = o9;
  function a9(e, t) {
    let { gen: r, schema: n } = e;
    n === !1 ? (r.var(t, !1), n$(e)) : r.var(t, !0);
  }
  mo.boolOrEmptySchema = a9;
  function n$(e, t) {
    let { gen: r, data: n } = e,
      s = {
        gen: r,
        keyword: "false schema",
        data: n,
        schema: !1,
        schemaCode: !1,
        schemaValue: !1,
        params: {},
        it: e,
      };
    (0, r9.reportError)(s, i9, void 0, t);
  }
});
var Wm = b((yo) => {
  "use strict";
  Object.defineProperty(yo, "__esModule", { value: !0 });
  yo.getRules = yo.isJSONType = void 0;
  var u9 = ["string", "number", "integer", "boolean", "null", "object", "array"],
    l9 = new Set(u9);
  function c9(e) {
    return typeof e == "string" && l9.has(e);
  }
  yo.isJSONType = c9;
  function f9() {
    let e = {
      number: { type: "number", rules: [] },
      string: { type: "string", rules: [] },
      array: { type: "array", rules: [] },
      object: { type: "object", rules: [] },
    };
    return {
      types: { ...e, integer: !0, boolean: !0, null: !0 },
      rules: [{ rules: [] }, e.number, e.string, e.array, e.object],
      post: { rules: [] },
      all: {},
      keywords: {},
    };
  }
  yo.getRules = f9;
});
var Ym = b((Ls) => {
  "use strict";
  Object.defineProperty(Ls, "__esModule", { value: !0 });
  Ls.shouldUseRule = Ls.shouldUseGroup = Ls.schemaHasRulesForType = void 0;
  function d9({ schema: e, self: t }, r) {
    let n = t.RULES.types[r];
    return n && n !== !0 && i$(e, n);
  }
  Ls.schemaHasRulesForType = d9;
  function i$(e, t) {
    return t.rules.some((r) => o$(e, r));
  }
  Ls.shouldUseGroup = i$;
  function o$(e, t) {
    var r;
    return (
      e[t.keyword] !== void 0 ||
      ((r = t.definition.implements) === null || r === void 0
        ? void 0
        : r.some((n) => e[n] !== void 0))
    );
  }
  Ls.shouldUseRule = o$;
});
var Ga = b((or) => {
  "use strict";
  Object.defineProperty(or, "__esModule", { value: !0 });
  or.reportTypeError =
    or.checkDataTypes =
    or.checkDataType =
    or.coerceAndCheckDataType =
    or.getJSONTypes =
    or.getSchemaTypes =
    or.DataType =
      void 0;
  var h9 = Wm(),
    p9 = Ym(),
    m9 = Ka(),
    Ne = he(),
    a$ = Ie(),
    go;
  (function (e) {
    (e[(e.Correct = 0)] = "Correct"), (e[(e.Wrong = 1)] = "Wrong");
  })(go || (or.DataType = go = {}));
  function y9(e) {
    let t = u$(e.type);
    if (t.includes("null")) {
      if (e.nullable === !1) throw new Error("type: null contradicts nullable: false");
    } else {
      if (!t.length && e.nullable !== void 0)
        throw new Error('"nullable" cannot be used without "type"');
      e.nullable === !0 && t.push("null");
    }
    return t;
  }
  or.getSchemaTypes = y9;
  function u$(e) {
    let t = Array.isArray(e) ? e : e ? [e] : [];
    if (t.every(h9.isJSONType)) return t;
    throw new Error("type must be JSONType or JSONType[]: " + t.join(","));
  }
  or.getJSONTypes = u$;
  function g9(e, t) {
    let { gen: r, data: n, opts: s } = e,
      i = _9(t, s.coerceTypes),
      o =
        t.length > 0 &&
        !(i.length === 0 && t.length === 1 && (0, p9.schemaHasRulesForType)(e, t[0]));
    if (o) {
      let a = Zm(t, n, s.strictNumbers, go.Wrong);
      r.if(a, () => {
        i.length ? S9(e, t, i) : ey(e);
      });
    }
    return o;
  }
  or.coerceAndCheckDataType = g9;
  var l$ = new Set(["string", "number", "integer", "boolean", "null"]);
  function _9(e, t) {
    return t ? e.filter((r) => l$.has(r) || (t === "array" && r === "array")) : [];
  }
  function S9(e, t, r) {
    let { gen: n, data: s, opts: i } = e,
      o = n.let("dataType", (0, Ne._)`typeof ${s}`),
      a = n.let("coerced", (0, Ne._)`undefined`);
    i.coerceTypes === "array" &&
      n.if((0, Ne._)`${o} == 'object' && Array.isArray(${s}) && ${s}.length == 1`, () =>
        n
          .assign(s, (0, Ne._)`${s}[0]`)
          .assign(o, (0, Ne._)`typeof ${s}`)
          .if(Zm(t, s, i.strictNumbers), () => n.assign(a, s)),
      ),
      n.if((0, Ne._)`${a} !== undefined`);
    for (let l of r) (l$.has(l) || (l === "array" && i.coerceTypes === "array")) && u(l);
    n.else(),
      ey(e),
      n.endIf(),
      n.if((0, Ne._)`${a} !== undefined`, () => {
        n.assign(s, a), v9(e, a);
      });
    function u(l) {
      switch (l) {
        case "string":
          n.elseIf((0, Ne._)`${o} == "number" || ${o} == "boolean"`)
            .assign(a, (0, Ne._)`"" + ${s}`)
            .elseIf((0, Ne._)`${s} === null`)
            .assign(a, (0, Ne._)`""`);
          return;
        case "number":
          n.elseIf(
            (0, Ne._)`${o} == "boolean" || ${s} === null
              || (${o} == "string" && ${s} && ${s} == +${s})`,
          ).assign(a, (0, Ne._)`+${s}`);
          return;
        case "integer":
          n.elseIf(
            (0, Ne._)`${o} === "boolean" || ${s} === null
              || (${o} === "string" && ${s} && ${s} == +${s} && !(${s} % 1))`,
          ).assign(a, (0, Ne._)`+${s}`);
          return;
        case "boolean":
          n.elseIf((0, Ne._)`${s} === "false" || ${s} === 0 || ${s} === null`)
            .assign(a, !1)
            .elseIf((0, Ne._)`${s} === "true" || ${s} === 1`)
            .assign(a, !0);
          return;
        case "null":
          n.elseIf((0, Ne._)`${s} === "" || ${s} === 0 || ${s} === false`), n.assign(a, null);
          return;
        case "array":
          n.elseIf(
            (0, Ne._)`${o} === "string" || ${o} === "number"
              || ${o} === "boolean" || ${s} === null`,
          ).assign(a, (0, Ne._)`[${s}]`);
      }
    }
  }
  function v9({ gen: e, parentData: t, parentDataProperty: r }, n) {
    e.if((0, Ne._)`${t} !== undefined`, () => e.assign((0, Ne._)`${t}[${r}]`, n));
  }
  function Xm(e, t, r, n = go.Correct) {
    let s = n === go.Correct ? Ne.operators.EQ : Ne.operators.NEQ,
      i;
    switch (e) {
      case "null":
        return (0, Ne._)`${t} ${s} null`;
      case "array":
        i = (0, Ne._)`Array.isArray(${t})`;
        break;
      case "object":
        i = (0, Ne._)`${t} && typeof ${t} == "object" && !Array.isArray(${t})`;
        break;
      case "integer":
        i = o((0, Ne._)`!(${t} % 1) && !isNaN(${t})`);
        break;
      case "number":
        i = o();
        break;
      default:
        return (0, Ne._)`typeof ${t} ${s} ${e}`;
    }
    return n === go.Correct ? i : (0, Ne.not)(i);
    function o(a = Ne.nil) {
      return (0, Ne.and)(
        (0, Ne._)`typeof ${t} == "number"`,
        a,
        r ? (0, Ne._)`isFinite(${t})` : Ne.nil,
      );
    }
  }
  or.checkDataType = Xm;
  function Zm(e, t, r, n) {
    if (e.length === 1) return Xm(e[0], t, r, n);
    let s,
      i = (0, a$.toHash)(e);
    if (i.array && i.object) {
      let o = (0, Ne._)`typeof ${t} != "object"`;
      (s = i.null ? o : (0, Ne._)`!${t} || ${o}`), delete i.null, delete i.array, delete i.object;
    } else s = Ne.nil;
    i.number && delete i.integer;
    for (let o in i) s = (0, Ne.and)(s, Xm(o, t, r, n));
    return s;
  }
  or.checkDataTypes = Zm;
  var b9 = {
    message: ({ schema: e }) => `must be ${e}`,
    params: ({ schema: e, schemaValue: t }) =>
      typeof e == "string" ? (0, Ne._)`{type: ${e}}` : (0, Ne._)`{type: ${t}}`,
  };
  function ey(e) {
    let t = w9(e);
    (0, m9.reportError)(t, b9);
  }
  or.reportTypeError = ey;
  function w9(e) {
    let { gen: t, data: r, schema: n } = e,
      s = (0, a$.schemaRefOrVal)(e, n, "type");
    return {
      gen: t,
      keyword: "type",
      data: r,
      schema: n.type,
      schemaCode: s,
      schemaValue: s,
      parentSchema: n,
      params: {},
      it: e,
    };
  }
});
var f$ = b((nf) => {
  "use strict";
  Object.defineProperty(nf, "__esModule", { value: !0 });
  nf.assignDefaults = void 0;
  var _o = he(),
    E9 = Ie();
  function R9(e, t) {
    let { properties: r, items: n } = e.schema;
    if (t === "object" && r) for (let s in r) c$(e, s, r[s].default);
    else t === "array" && Array.isArray(n) && n.forEach((s, i) => c$(e, i, s.default));
  }
  nf.assignDefaults = R9;
  function c$(e, t, r) {
    let { gen: n, compositeRule: s, data: i, opts: o } = e;
    if (r === void 0) return;
    let a = (0, _o._)`${i}${(0, _o.getProperty)(t)}`;
    if (s) {
      (0, E9.checkStrictMode)(e, `default is ignored for: ${a}`);
      return;
    }
    let u = (0, _o._)`${a} === undefined`;
    o.useDefaults === "empty" && (u = (0, _o._)`${u} || ${a} === null || ${a} === ""`),
      n.if(u, (0, _o._)`${a} = ${(0, _o.stringify)(r)}`);
  }
});
var Jt = b((tt) => {
  "use strict";
  Object.defineProperty(tt, "__esModule", { value: !0 });
  tt.validateUnion =
    tt.validateArray =
    tt.usePattern =
    tt.callValidateCode =
    tt.schemaProperties =
    tt.allSchemaProperties =
    tt.noPropertyInData =
    tt.propertyInData =
    tt.isOwnProperty =
    tt.hasPropFunc =
    tt.reportMissingProp =
    tt.checkMissingProp =
    tt.checkReportMissingProp =
      void 0;
  var gt = he(),
    ty = Ie(),
    xs = tn(),
    T9 = Ie();
  function P9(e, t) {
    let { gen: r, data: n, it: s } = e;
    r.if(ny(r, n, t, s.opts.ownProperties), () => {
      e.setParams({ missingProperty: (0, gt._)`${t}` }, !0), e.error();
    });
  }
  tt.checkReportMissingProp = P9;
  function $9({ gen: e, data: t, it: { opts: r } }, n, s) {
    return (0, gt.or)(
      ...n.map((i) => (0, gt.and)(ny(e, t, i, r.ownProperties), (0, gt._)`${s} = ${i}`)),
    );
  }
  tt.checkMissingProp = $9;
  function O9(e, t) {
    e.setParams({ missingProperty: t }, !0), e.error();
  }
  tt.reportMissingProp = O9;
  function d$(e) {
    return e.scopeValue("func", {
      ref: Object.prototype.hasOwnProperty,
      code: (0, gt._)`Object.prototype.hasOwnProperty`,
    });
  }
  tt.hasPropFunc = d$;
  function ry(e, t, r) {
    return (0, gt._)`${d$(e)}.call(${t}, ${r})`;
  }
  tt.isOwnProperty = ry;
  function N9(e, t, r, n) {
    let s = (0, gt._)`${t}${(0, gt.getProperty)(r)} !== undefined`;
    return n ? (0, gt._)`${s} && ${ry(e, t, r)}` : s;
  }
  tt.propertyInData = N9;
  function ny(e, t, r, n) {
    let s = (0, gt._)`${t}${(0, gt.getProperty)(r)} === undefined`;
    return n ? (0, gt.or)(s, (0, gt.not)(ry(e, t, r))) : s;
  }
  tt.noPropertyInData = ny;
  function h$(e) {
    return e ? Object.keys(e).filter((t) => t !== "__proto__") : [];
  }
  tt.allSchemaProperties = h$;
  function A9(e, t) {
    return h$(t).filter((r) => !(0, ty.alwaysValidSchema)(e, t[r]));
  }
  tt.schemaProperties = A9;
  function I9(
    { schemaCode: e, data: t, it: { gen: r, topSchemaRef: n, schemaPath: s, errorPath: i }, it: o },
    a,
    u,
    l,
  ) {
    let c = l ? (0, gt._)`${e}, ${t}, ${n}${s}` : t,
      f = [
        [xs.default.instancePath, (0, gt.strConcat)(xs.default.instancePath, i)],
        [xs.default.parentData, o.parentData],
        [xs.default.parentDataProperty, o.parentDataProperty],
        [xs.default.rootData, xs.default.rootData],
      ];
    o.opts.dynamicRef && f.push([xs.default.dynamicAnchors, xs.default.dynamicAnchors]);
    let d = (0, gt._)`${c}, ${r.object(...f)}`;
    return u !== gt.nil ? (0, gt._)`${a}.call(${u}, ${d})` : (0, gt._)`${a}(${d})`;
  }
  tt.callValidateCode = I9;
  var C9 = (0, gt._)`new RegExp`;
  function k9({ gen: e, it: { opts: t } }, r) {
    let n = t.unicodeRegExp ? "u" : "",
      { regExp: s } = t.code,
      i = s(r, n);
    return e.scopeValue("pattern", {
      key: i.toString(),
      ref: i,
      code: (0, gt._)`${s.code === "new RegExp" ? C9 : (0, T9.useFunc)(e, s)}(${r}, ${n})`,
    });
  }
  tt.usePattern = k9;
  function D9(e) {
    let { gen: t, data: r, keyword: n, it: s } = e,
      i = t.name("valid");
    if (s.allErrors) {
      let a = t.let("valid", !0);
      return o(() => t.assign(a, !1)), a;
    }
    return t.var(i, !0), o(() => t.break()), i;
    function o(a) {
      let u = t.const("len", (0, gt._)`${r}.length`);
      t.forRange("i", 0, u, (l) => {
        e.subschema({ keyword: n, dataProp: l, dataPropType: ty.Type.Num }, i),
          t.if((0, gt.not)(i), a);
      });
    }
  }
  tt.validateArray = D9;
  function q9(e) {
    let { gen: t, schema: r, keyword: n, it: s } = e;
    if (!Array.isArray(r)) throw new Error("ajv implementation error");
    if (r.some((u) => (0, ty.alwaysValidSchema)(s, u)) && !s.opts.unevaluated) return;
    let o = t.let("valid", !1),
      a = t.name("_valid");
    t.block(() =>
      r.forEach((u, l) => {
        let c = e.subschema({ keyword: n, schemaProp: l, compositeRule: !0 }, a);
        t.assign(o, (0, gt._)`${o} || ${a}`), e.mergeValidEvaluated(c, a) || t.if((0, gt.not)(o));
      }),
    ),
      e.result(
        o,
        () => e.reset(),
        () => e.error(!0),
      );
  }
  tt.validateUnion = q9;
});
var y$ = b((Dn) => {
  "use strict";
  Object.defineProperty(Dn, "__esModule", { value: !0 });
  Dn.validateKeywordUsage = Dn.validSchemaType = Dn.funcKeywordCode = Dn.macroKeywordCode = void 0;
  var _r = he(),
    Ei = tn(),
    j9 = Jt(),
    L9 = Ka();
  function x9(e, t) {
    let { gen: r, keyword: n, schema: s, parentSchema: i, it: o } = e,
      a = t.macro.call(o.self, s, i, o),
      u = m$(r, n, a);
    o.opts.validateSchema !== !1 && o.self.validateSchema(a, !0);
    let l = r.name("valid");
    e.subschema(
      {
        schema: a,
        schemaPath: _r.nil,
        errSchemaPath: `${o.errSchemaPath}/${n}`,
        topSchemaRef: u,
        compositeRule: !0,
      },
      l,
    ),
      e.pass(l, () => e.error(!0));
  }
  Dn.macroKeywordCode = x9;
  function F9(e, t) {
    var r;
    let { gen: n, keyword: s, schema: i, parentSchema: o, $data: a, it: u } = e;
    z9(u, t);
    let l = !a && t.compile ? t.compile.call(u.self, i, o, u) : t.validate,
      c = m$(n, s, l),
      f = n.let("valid");
    e.block$data(f, d), e.ok((r = t.valid) !== null && r !== void 0 ? r : f);
    function d() {
      if (t.errors === !1) y(), t.modifying && p$(e), _(() => e.error());
      else {
        let S = t.async ? h() : p();
        t.modifying && p$(e), _(() => M9(e, S));
      }
    }
    function h() {
      let S = n.let("ruleErrs", null);
      return (
        n.try(
          () => y((0, _r._)`await `),
          (E) =>
            n.assign(f, !1).if(
              (0, _r._)`${E} instanceof ${u.ValidationError}`,
              () => n.assign(S, (0, _r._)`${E}.errors`),
              () => n.throw(E),
            ),
        ),
        S
      );
    }
    function p() {
      let S = (0, _r._)`${c}.errors`;
      return n.assign(S, null), y(_r.nil), S;
    }
    function y(S = t.async ? (0, _r._)`await ` : _r.nil) {
      let E = u.opts.passContext ? Ei.default.this : Ei.default.self,
        g = !(("compile" in t && !a) || t.schema === !1);
      n.assign(f, (0, _r._)`${S}${(0, j9.callValidateCode)(e, c, E, g)}`, t.modifying);
    }
    function _(S) {
      var E;
      n.if((0, _r.not)((E = t.valid) !== null && E !== void 0 ? E : f), S);
    }
  }
  Dn.funcKeywordCode = F9;
  function p$(e) {
    let { gen: t, data: r, it: n } = e;
    t.if(n.parentData, () => t.assign(r, (0, _r._)`${n.parentData}[${n.parentDataProperty}]`));
  }
  function M9(e, t) {
    let { gen: r } = e;
    r.if(
      (0, _r._)`Array.isArray(${t})`,
      () => {
        r
          .assign(
            Ei.default.vErrors,
            (0, _r._)`${Ei.default.vErrors} === null ? ${t} : ${Ei.default.vErrors}.concat(${t})`,
          )
          .assign(Ei.default.errors, (0, _r._)`${Ei.default.vErrors}.length`),
          (0, L9.extendErrors)(e);
      },
      () => e.error(),
    );
  }
  function z9({ schemaEnv: e }, t) {
    if (t.async && !e.$async) throw new Error("async keyword in sync schema");
  }
  function m$(e, t, r) {
    if (r === void 0) throw new Error(`keyword "${t}" failed to compile`);
    return e.scopeValue(
      "keyword",
      typeof r == "function" ? { ref: r } : { ref: r, code: (0, _r.stringify)(r) },
    );
  }
  function V9(e, t, r = !1) {
    return (
      !t.length ||
      t.some((n) =>
        n === "array"
          ? Array.isArray(e)
          : n === "object"
            ? e && typeof e == "object" && !Array.isArray(e)
            : typeof e == n || (r && typeof e > "u"),
      )
    );
  }
  Dn.validSchemaType = V9;
  function U9({ schema: e, opts: t, self: r, errSchemaPath: n }, s, i) {
    if (Array.isArray(s.keyword) ? !s.keyword.includes(i) : s.keyword !== i)
      throw new Error("ajv implementation error");
    let o = s.dependencies;
    if (o?.some((a) => !Object.prototype.hasOwnProperty.call(e, a)))
      throw new Error(`parent schema must have dependencies of ${i}: ${o.join(",")}`);
    if (s.validateSchema && !s.validateSchema(e[i])) {
      let u =
        `keyword "${i}" value is invalid at path "${n}": ` + r.errorsText(s.validateSchema.errors);
      if (t.validateSchema === "log") r.logger.error(u);
      else throw new Error(u);
    }
  }
  Dn.validateKeywordUsage = U9;
});
var _$ = b((Fs) => {
  "use strict";
  Object.defineProperty(Fs, "__esModule", { value: !0 });
  Fs.extendSubschemaMode = Fs.extendSubschemaData = Fs.getSubschema = void 0;
  var qn = he(),
    g$ = Ie();
  function H9(
    e,
    { keyword: t, schemaProp: r, schema: n, schemaPath: s, errSchemaPath: i, topSchemaRef: o },
  ) {
    if (t !== void 0 && n !== void 0)
      throw new Error('both "keyword" and "schema" passed, only one allowed');
    if (t !== void 0) {
      let a = e.schema[t];
      return r === void 0
        ? {
            schema: a,
            schemaPath: (0, qn._)`${e.schemaPath}${(0, qn.getProperty)(t)}`,
            errSchemaPath: `${e.errSchemaPath}/${t}`,
          }
        : {
            schema: a[r],
            schemaPath: (0,
            qn._)`${e.schemaPath}${(0, qn.getProperty)(t)}${(0, qn.getProperty)(r)}`,
            errSchemaPath: `${e.errSchemaPath}/${t}/${(0, g$.escapeFragment)(r)}`,
          };
    }
    if (n !== void 0) {
      if (s === void 0 || i === void 0 || o === void 0)
        throw new Error(
          '"schemaPath", "errSchemaPath" and "topSchemaRef" are required with "schema"',
        );
      return { schema: n, schemaPath: s, topSchemaRef: o, errSchemaPath: i };
    }
    throw new Error('either "keyword" or "schema" must be passed');
  }
  Fs.getSubschema = H9;
  function B9(e, t, { dataProp: r, dataPropType: n, data: s, dataTypes: i, propertyName: o }) {
    if (s !== void 0 && r !== void 0)
      throw new Error('both "data" and "dataProp" passed, only one allowed');
    let { gen: a } = t;
    if (r !== void 0) {
      let { errorPath: l, dataPathArr: c, opts: f } = t,
        d = a.let("data", (0, qn._)`${t.data}${(0, qn.getProperty)(r)}`, !0);
      u(d),
        (e.errorPath = (0, qn.str)`${l}${(0, g$.getErrorPath)(r, n, f.jsPropertySyntax)}`),
        (e.parentDataProperty = (0, qn._)`${r}`),
        (e.dataPathArr = [...c, e.parentDataProperty]);
    }
    if (s !== void 0) {
      let l = s instanceof qn.Name ? s : a.let("data", s, !0);
      u(l), o !== void 0 && (e.propertyName = o);
    }
    i && (e.dataTypes = i);
    function u(l) {
      (e.data = l),
        (e.dataLevel = t.dataLevel + 1),
        (e.dataTypes = []),
        (t.definedProperties = new Set()),
        (e.parentData = t.data),
        (e.dataNames = [...t.dataNames, l]);
    }
  }
  Fs.extendSubschemaData = B9;
  function K9(
    e,
    { jtdDiscriminator: t, jtdMetadata: r, compositeRule: n, createErrors: s, allErrors: i },
  ) {
    n !== void 0 && (e.compositeRule = n),
      s !== void 0 && (e.createErrors = s),
      i !== void 0 && (e.allErrors = i),
      (e.jtdDiscriminator = t),
      (e.jtdMetadata = r);
  }
  Fs.extendSubschemaMode = K9;
});
var v$ = b((Mie, S$) => {
  "use strict";
  var Ms = (S$.exports = function (e, t, r) {
    typeof t == "function" && ((r = t), (t = {})), (r = t.cb || r);
    var n = typeof r == "function" ? r : r.pre || function () {},
      s = r.post || function () {};
    sf(t, n, s, e, "", e);
  });
  Ms.keywords = {
    additionalItems: !0,
    items: !0,
    contains: !0,
    additionalProperties: !0,
    propertyNames: !0,
    not: !0,
    if: !0,
    then: !0,
    else: !0,
  };
  Ms.arrayKeywords = { items: !0, allOf: !0, anyOf: !0, oneOf: !0 };
  Ms.propsKeywords = {
    $defs: !0,
    definitions: !0,
    properties: !0,
    patternProperties: !0,
    dependencies: !0,
  };
  Ms.skipKeywords = {
    default: !0,
    enum: !0,
    const: !0,
    required: !0,
    maximum: !0,
    minimum: !0,
    exclusiveMaximum: !0,
    exclusiveMinimum: !0,
    multipleOf: !0,
    maxLength: !0,
    minLength: !0,
    pattern: !0,
    format: !0,
    maxItems: !0,
    minItems: !0,
    uniqueItems: !0,
    maxProperties: !0,
    minProperties: !0,
  };
  function sf(e, t, r, n, s, i, o, a, u, l) {
    if (n && typeof n == "object" && !Array.isArray(n)) {
      t(n, s, i, o, a, u, l);
      for (var c in n) {
        var f = n[c];
        if (Array.isArray(f)) {
          if (c in Ms.arrayKeywords)
            for (var d = 0; d < f.length; d++)
              sf(e, t, r, f[d], s + "/" + c + "/" + d, i, s, c, n, d);
        } else if (c in Ms.propsKeywords) {
          if (f && typeof f == "object")
            for (var h in f) sf(e, t, r, f[h], s + "/" + c + "/" + G9(h), i, s, c, n, h);
        } else
          (c in Ms.keywords || (e.allKeys && !(c in Ms.skipKeywords))) &&
            sf(e, t, r, f, s + "/" + c, i, s, c, n);
      }
      r(n, s, i, o, a, u, l);
    }
  }
  function G9(e) {
    return e.replace(/~/g, "~0").replace(/\//g, "~1");
  }
});
var Ja = b((Ir) => {
  "use strict";
  Object.defineProperty(Ir, "__esModule", { value: !0 });
  Ir.getSchemaRefs =
    Ir.resolveUrl =
    Ir.normalizeId =
    Ir._getFullPath =
    Ir.getFullPath =
    Ir.inlineRef =
      void 0;
  var J9 = Ie(),
    Q9 = qs(),
    W9 = v$(),
    Y9 = new Set([
      "type",
      "format",
      "pattern",
      "maxLength",
      "minLength",
      "maxProperties",
      "minProperties",
      "maxItems",
      "minItems",
      "maximum",
      "minimum",
      "uniqueItems",
      "multipleOf",
      "required",
      "enum",
      "const",
    ]);
  function X9(e, t = !0) {
    return typeof e == "boolean" ? !0 : t === !0 ? !sy(e) : t ? b$(e) <= t : !1;
  }
  Ir.inlineRef = X9;
  var Z9 = new Set(["$ref", "$recursiveRef", "$recursiveAnchor", "$dynamicRef", "$dynamicAnchor"]);
  function sy(e) {
    for (let t in e) {
      if (Z9.has(t)) return !0;
      let r = e[t];
      if ((Array.isArray(r) && r.some(sy)) || (typeof r == "object" && sy(r))) return !0;
    }
    return !1;
  }
  function b$(e) {
    let t = 0;
    for (let r in e) {
      if (r === "$ref") return 1 / 0;
      if (
        (t++,
        !Y9.has(r) &&
          (typeof e[r] == "object" && (0, J9.eachItem)(e[r], (n) => (t += b$(n))), t === 1 / 0))
      )
        return 1 / 0;
    }
    return t;
  }
  function w$(e, t = "", r) {
    r !== !1 && (t = So(t));
    let n = e.parse(t);
    return E$(e, n);
  }
  Ir.getFullPath = w$;
  function E$(e, t) {
    return e.serialize(t).split("#")[0] + "#";
  }
  Ir._getFullPath = E$;
  var e6 = /#\/?$/;
  function So(e) {
    return e ? e.replace(e6, "") : "";
  }
  Ir.normalizeId = So;
  function t6(e, t, r) {
    return (r = So(r)), e.resolve(t, r);
  }
  Ir.resolveUrl = t6;
  var r6 = /^[a-z_][-a-z0-9._]*$/i;
  function n6(e, t) {
    if (typeof e == "boolean") return {};
    let { schemaId: r, uriResolver: n } = this.opts,
      s = So(e[r] || t),
      i = { "": s },
      o = w$(n, s, !1),
      a = {},
      u = new Set();
    return (
      W9(e, { allKeys: !0 }, (f, d, h, p) => {
        if (p === void 0) return;
        let y = o + d,
          _ = i[p];
        typeof f[r] == "string" && (_ = S.call(this, f[r])),
          E.call(this, f.$anchor),
          E.call(this, f.$dynamicAnchor),
          (i[d] = _);
        function S(g) {
          let m = this.opts.uriResolver.resolve;
          if (((g = So(_ ? m(_, g) : g)), u.has(g))) throw c(g);
          u.add(g);
          let T = this.refs[g];
          return (
            typeof T == "string" && (T = this.refs[T]),
            typeof T == "object"
              ? l(f, T.schema, g)
              : g !== So(y) && (g[0] === "#" ? (l(f, a[g], g), (a[g] = f)) : (this.refs[g] = y)),
            g
          );
        }
        function E(g) {
          if (typeof g == "string") {
            if (!r6.test(g)) throw new Error(`invalid anchor "${g}"`);
            S.call(this, `#${g}`);
          }
        }
      }),
      a
    );
    function l(f, d, h) {
      if (d !== void 0 && !Q9(f, d)) throw c(h);
    }
    function c(f) {
      return new Error(`reference "${f}" resolves to more than one schema`);
    }
  }
  Ir.getSchemaRefs = n6;
});
var vo = b((zs) => {
  "use strict";
  Object.defineProperty(zs, "__esModule", { value: !0 });
  zs.getData = zs.KeywordCxt = zs.validateFunctionCode = void 0;
  var O$ = s$(),
    R$ = Ga(),
    oy = Ym(),
    of = Ga(),
    s6 = f$(),
    Wa = y$(),
    iy = _$(),
    ae = he(),
    we = tn(),
    i6 = Ja(),
    us = Ie(),
    Qa = Ka();
  function o6(e) {
    if (I$(e) && (C$(e), A$(e))) {
      l6(e);
      return;
    }
    N$(e, () => (0, O$.topBoolOrEmptySchema)(e));
  }
  zs.validateFunctionCode = o6;
  function N$({ gen: e, validateName: t, schema: r, schemaEnv: n, opts: s }, i) {
    s.code.es5
      ? e.func(t, (0, ae._)`${we.default.data}, ${we.default.valCxt}`, n.$async, () => {
          e.code((0, ae._)`"use strict"; ${T$(r, s)}`), u6(e, s), e.code(i);
        })
      : e.func(t, (0, ae._)`${we.default.data}, ${a6(s)}`, n.$async, () =>
          e.code(T$(r, s)).code(i),
        );
  }
  function a6(e) {
    return (0,
    ae._)`{${we.default.instancePath}="", ${we.default.parentData}, ${we.default.parentDataProperty}, ${we.default.rootData}=${we.default.data}${e.dynamicRef ? (0, ae._)`, ${we.default.dynamicAnchors}={}` : ae.nil}}={}`;
  }
  function u6(e, t) {
    e.if(
      we.default.valCxt,
      () => {
        e.var(we.default.instancePath, (0, ae._)`${we.default.valCxt}.${we.default.instancePath}`),
          e.var(we.default.parentData, (0, ae._)`${we.default.valCxt}.${we.default.parentData}`),
          e.var(
            we.default.parentDataProperty,
            (0, ae._)`${we.default.valCxt}.${we.default.parentDataProperty}`,
          ),
          e.var(we.default.rootData, (0, ae._)`${we.default.valCxt}.${we.default.rootData}`),
          t.dynamicRef &&
            e.var(
              we.default.dynamicAnchors,
              (0, ae._)`${we.default.valCxt}.${we.default.dynamicAnchors}`,
            );
      },
      () => {
        e.var(we.default.instancePath, (0, ae._)`""`),
          e.var(we.default.parentData, (0, ae._)`undefined`),
          e.var(we.default.parentDataProperty, (0, ae._)`undefined`),
          e.var(we.default.rootData, we.default.data),
          t.dynamicRef && e.var(we.default.dynamicAnchors, (0, ae._)`{}`);
      },
    );
  }
  function l6(e) {
    let { schema: t, opts: r, gen: n } = e;
    N$(e, () => {
      r.$comment && t.$comment && D$(e),
        p6(e),
        n.let(we.default.vErrors, null),
        n.let(we.default.errors, 0),
        r.unevaluated && c6(e),
        k$(e),
        g6(e);
    });
  }
  function c6(e) {
    let { gen: t, validateName: r } = e;
    (e.evaluated = t.const("evaluated", (0, ae._)`${r}.evaluated`)),
      t.if((0, ae._)`${e.evaluated}.dynamicProps`, () =>
        t.assign((0, ae._)`${e.evaluated}.props`, (0, ae._)`undefined`),
      ),
      t.if((0, ae._)`${e.evaluated}.dynamicItems`, () =>
        t.assign((0, ae._)`${e.evaluated}.items`, (0, ae._)`undefined`),
      );
  }
  function T$(e, t) {
    let r = typeof e == "object" && e[t.schemaId];
    return r && (t.code.source || t.code.process) ? (0, ae._)`/*# sourceURL=${r} */` : ae.nil;
  }
  function f6(e, t) {
    if (I$(e) && (C$(e), A$(e))) {
      d6(e, t);
      return;
    }
    (0, O$.boolOrEmptySchema)(e, t);
  }
  function A$({ schema: e, self: t }) {
    if (typeof e == "boolean") return !e;
    for (let r in e) if (t.RULES.all[r]) return !0;
    return !1;
  }
  function I$(e) {
    return typeof e.schema != "boolean";
  }
  function d6(e, t) {
    let { schema: r, gen: n, opts: s } = e;
    s.$comment && r.$comment && D$(e), m6(e), y6(e);
    let i = n.const("_errs", we.default.errors);
    k$(e, i), n.var(t, (0, ae._)`${i} === ${we.default.errors}`);
  }
  function C$(e) {
    (0, us.checkUnknownRules)(e), h6(e);
  }
  function k$(e, t) {
    if (e.opts.jtd) return P$(e, [], !1, t);
    let r = (0, R$.getSchemaTypes)(e.schema),
      n = (0, R$.coerceAndCheckDataType)(e, r);
    P$(e, r, !n, t);
  }
  function h6(e) {
    let { schema: t, errSchemaPath: r, opts: n, self: s } = e;
    t.$ref &&
      n.ignoreKeywordsWithRef &&
      (0, us.schemaHasRulesButRef)(t, s.RULES) &&
      s.logger.warn(`$ref: keywords ignored in schema at path "${r}"`);
  }
  function p6(e) {
    let { schema: t, opts: r } = e;
    t.default !== void 0 &&
      r.useDefaults &&
      r.strictSchema &&
      (0, us.checkStrictMode)(e, "default is ignored in the schema root");
  }
  function m6(e) {
    let t = e.schema[e.opts.schemaId];
    t && (e.baseId = (0, i6.resolveUrl)(e.opts.uriResolver, e.baseId, t));
  }
  function y6(e) {
    if (e.schema.$async && !e.schemaEnv.$async) throw new Error("async schema in sync schema");
  }
  function D$({ gen: e, schemaEnv: t, schema: r, errSchemaPath: n, opts: s }) {
    let i = r.$comment;
    if (s.$comment === !0) e.code((0, ae._)`${we.default.self}.logger.log(${i})`);
    else if (typeof s.$comment == "function") {
      let o = (0, ae.str)`${n}/$comment`,
        a = e.scopeValue("root", { ref: t.root });
      e.code((0, ae._)`${we.default.self}.opts.$comment(${i}, ${o}, ${a}.schema)`);
    }
  }
  function g6(e) {
    let { gen: t, schemaEnv: r, validateName: n, ValidationError: s, opts: i } = e;
    r.$async
      ? t.if(
          (0, ae._)`${we.default.errors} === 0`,
          () => t.return(we.default.data),
          () => t.throw((0, ae._)`new ${s}(${we.default.vErrors})`),
        )
      : (t.assign((0, ae._)`${n}.errors`, we.default.vErrors),
        i.unevaluated && _6(e),
        t.return((0, ae._)`${we.default.errors} === 0`));
  }
  function _6({ gen: e, evaluated: t, props: r, items: n }) {
    r instanceof ae.Name && e.assign((0, ae._)`${t}.props`, r),
      n instanceof ae.Name && e.assign((0, ae._)`${t}.items`, n);
  }
  function P$(e, t, r, n) {
    let { gen: s, schema: i, data: o, allErrors: a, opts: u, self: l } = e,
      { RULES: c } = l;
    if (i.$ref && (u.ignoreKeywordsWithRef || !(0, us.schemaHasRulesButRef)(i, c))) {
      s.block(() => j$(e, "$ref", c.all.$ref.definition));
      return;
    }
    u.jtd || S6(e, t),
      s.block(() => {
        for (let d of c.rules) f(d);
        f(c.post);
      });
    function f(d) {
      (0, oy.shouldUseGroup)(i, d) &&
        (d.type
          ? (s.if((0, of.checkDataType)(d.type, o, u.strictNumbers)),
            $$(e, d),
            t.length === 1 && t[0] === d.type && r && (s.else(), (0, of.reportTypeError)(e)),
            s.endIf())
          : $$(e, d),
        a || s.if((0, ae._)`${we.default.errors} === ${n || 0}`));
    }
  }
  function $$(e, t) {
    let {
      gen: r,
      schema: n,
      opts: { useDefaults: s },
    } = e;
    s && (0, s6.assignDefaults)(e, t.type),
      r.block(() => {
        for (let i of t.rules)
          (0, oy.shouldUseRule)(n, i) && j$(e, i.keyword, i.definition, t.type);
      });
  }
  function S6(e, t) {
    e.schemaEnv.meta ||
      !e.opts.strictTypes ||
      (v6(e, t), e.opts.allowUnionTypes || b6(e, t), w6(e, e.dataTypes));
  }
  function v6(e, t) {
    if (t.length) {
      if (!e.dataTypes.length) {
        e.dataTypes = t;
        return;
      }
      t.forEach((r) => {
        q$(e.dataTypes, r) ||
          ay(e, `type "${r}" not allowed by context "${e.dataTypes.join(",")}"`);
      }),
        R6(e, t);
    }
  }
  function b6(e, t) {
    t.length > 1 &&
      !(t.length === 2 && t.includes("null")) &&
      ay(e, "use allowUnionTypes to allow union type keyword");
  }
  function w6(e, t) {
    let r = e.self.RULES.all;
    for (let n in r) {
      let s = r[n];
      if (typeof s == "object" && (0, oy.shouldUseRule)(e.schema, s)) {
        let { type: i } = s.definition;
        i.length &&
          !i.some((o) => E6(t, o)) &&
          ay(e, `missing type "${i.join(",")}" for keyword "${n}"`);
      }
    }
  }
  function E6(e, t) {
    return e.includes(t) || (t === "number" && e.includes("integer"));
  }
  function q$(e, t) {
    return e.includes(t) || (t === "integer" && e.includes("number"));
  }
  function R6(e, t) {
    let r = [];
    for (let n of e.dataTypes)
      q$(t, n) ? r.push(n) : t.includes("integer") && n === "number" && r.push("integer");
    e.dataTypes = r;
  }
  function ay(e, t) {
    let r = e.schemaEnv.baseId + e.errSchemaPath;
    (t += ` at "${r}" (strictTypes)`), (0, us.checkStrictMode)(e, t, e.opts.strictTypes);
  }
  var af = class {
    constructor(t, r, n) {
      if (
        ((0, Wa.validateKeywordUsage)(t, r, n),
        (this.gen = t.gen),
        (this.allErrors = t.allErrors),
        (this.keyword = n),
        (this.data = t.data),
        (this.schema = t.schema[n]),
        (this.$data = r.$data && t.opts.$data && this.schema && this.schema.$data),
        (this.schemaValue = (0, us.schemaRefOrVal)(t, this.schema, n, this.$data)),
        (this.schemaType = r.schemaType),
        (this.parentSchema = t.schema),
        (this.params = {}),
        (this.it = t),
        (this.def = r),
        this.$data)
      )
        this.schemaCode = t.gen.const("vSchema", L$(this.$data, t));
      else if (
        ((this.schemaCode = this.schemaValue),
        !(0, Wa.validSchemaType)(this.schema, r.schemaType, r.allowUndefined))
      )
        throw new Error(`${n} value must be ${JSON.stringify(r.schemaType)}`);
      ("code" in r ? r.trackErrors : r.errors !== !1) &&
        (this.errsCount = t.gen.const("_errs", we.default.errors));
    }
    result(t, r, n) {
      this.failResult((0, ae.not)(t), r, n);
    }
    failResult(t, r, n) {
      this.gen.if(t),
        n ? n() : this.error(),
        r
          ? (this.gen.else(), r(), this.allErrors && this.gen.endIf())
          : this.allErrors
            ? this.gen.endIf()
            : this.gen.else();
    }
    pass(t, r) {
      this.failResult((0, ae.not)(t), void 0, r);
    }
    fail(t) {
      if (t === void 0) {
        this.error(), this.allErrors || this.gen.if(!1);
        return;
      }
      this.gen.if(t), this.error(), this.allErrors ? this.gen.endIf() : this.gen.else();
    }
    fail$data(t) {
      if (!this.$data) return this.fail(t);
      let { schemaCode: r } = this;
      this.fail((0, ae._)`${r} !== undefined && (${(0, ae.or)(this.invalid$data(), t)})`);
    }
    error(t, r, n) {
      if (r) {
        this.setParams(r), this._error(t, n), this.setParams({});
        return;
      }
      this._error(t, n);
    }
    _error(t, r) {
      (t ? Qa.reportExtraError : Qa.reportError)(this, this.def.error, r);
    }
    $dataError() {
      (0, Qa.reportError)(this, this.def.$dataError || Qa.keyword$DataError);
    }
    reset() {
      if (this.errsCount === void 0) throw new Error('add "trackErrors" to keyword definition');
      (0, Qa.resetErrorsCount)(this.gen, this.errsCount);
    }
    ok(t) {
      this.allErrors || this.gen.if(t);
    }
    setParams(t, r) {
      r ? Object.assign(this.params, t) : (this.params = t);
    }
    block$data(t, r, n = ae.nil) {
      this.gen.block(() => {
        this.check$data(t, n), r();
      });
    }
    check$data(t = ae.nil, r = ae.nil) {
      if (!this.$data) return;
      let { gen: n, schemaCode: s, schemaType: i, def: o } = this;
      n.if((0, ae.or)((0, ae._)`${s} === undefined`, r)),
        t !== ae.nil && n.assign(t, !0),
        (i.length || o.validateSchema) &&
          (n.elseIf(this.invalid$data()), this.$dataError(), t !== ae.nil && n.assign(t, !1)),
        n.else();
    }
    invalid$data() {
      let { gen: t, schemaCode: r, schemaType: n, def: s, it: i } = this;
      return (0, ae.or)(o(), a());
      function o() {
        if (n.length) {
          if (!(r instanceof ae.Name)) throw new Error("ajv implementation error");
          let u = Array.isArray(n) ? n : [n];
          return (0,
          ae._)`${(0, of.checkDataTypes)(u, r, i.opts.strictNumbers, of.DataType.Wrong)}`;
        }
        return ae.nil;
      }
      function a() {
        if (s.validateSchema) {
          let u = t.scopeValue("validate$data", { ref: s.validateSchema });
          return (0, ae._)`!${u}(${r})`;
        }
        return ae.nil;
      }
    }
    subschema(t, r) {
      let n = (0, iy.getSubschema)(this.it, t);
      (0, iy.extendSubschemaData)(n, this.it, t), (0, iy.extendSubschemaMode)(n, t);
      let s = { ...this.it, ...n, items: void 0, props: void 0 };
      return f6(s, r), s;
    }
    mergeEvaluated(t, r) {
      let { it: n, gen: s } = this;
      n.opts.unevaluated &&
        (n.props !== !0 &&
          t.props !== void 0 &&
          (n.props = us.mergeEvaluated.props(s, t.props, n.props, r)),
        n.items !== !0 &&
          t.items !== void 0 &&
          (n.items = us.mergeEvaluated.items(s, t.items, n.items, r)));
    }
    mergeValidEvaluated(t, r) {
      let { it: n, gen: s } = this;
      if (n.opts.unevaluated && (n.props !== !0 || n.items !== !0))
        return s.if(r, () => this.mergeEvaluated(t, ae.Name)), !0;
    }
  };
  zs.KeywordCxt = af;
  function j$(e, t, r, n) {
    let s = new af(e, r, t);
    "code" in r
      ? r.code(s, n)
      : s.$data && r.validate
        ? (0, Wa.funcKeywordCode)(s, r)
        : "macro" in r
          ? (0, Wa.macroKeywordCode)(s, r)
          : (r.compile || r.validate) && (0, Wa.funcKeywordCode)(s, r);
  }
  var T6 = /^\/(?:[^~]|~0|~1)*$/,
    P6 = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;
  function L$(e, { dataLevel: t, dataNames: r, dataPathArr: n }) {
    let s, i;
    if (e === "") return we.default.rootData;
    if (e[0] === "/") {
      if (!T6.test(e)) throw new Error(`Invalid JSON-pointer: ${e}`);
      (s = e), (i = we.default.rootData);
    } else {
      let l = P6.exec(e);
      if (!l) throw new Error(`Invalid JSON-pointer: ${e}`);
      let c = +l[1];
      if (((s = l[2]), s === "#")) {
        if (c >= t) throw new Error(u("property/index", c));
        return n[t - c];
      }
      if (c > t) throw new Error(u("data", c));
      if (((i = r[t - c]), !s)) return i;
    }
    let o = i,
      a = s.split("/");
    for (let l of a)
      l &&
        ((i = (0, ae._)`${i}${(0, ae.getProperty)((0, us.unescapeJsonPointer)(l))}`),
        (o = (0, ae._)`${o} && ${i}`));
    return o;
    function u(l, c) {
      return `Cannot access ${l} ${c} levels up, current level is ${t}`;
    }
  }
  zs.getData = L$;
});
var Ya = b((ly) => {
  "use strict";
  Object.defineProperty(ly, "__esModule", { value: !0 });
  var uy = class extends Error {
    constructor(t) {
      super("validation failed"), (this.errors = t), (this.ajv = this.validation = !0);
    }
  };
  ly.default = uy;
});
var ls = b((dy) => {
  "use strict";
  Object.defineProperty(dy, "__esModule", { value: !0 });
  var cy = Ja(),
    fy = class extends Error {
      constructor(t, r, n, s) {
        super(s || `can't resolve reference ${n} from id ${r}`),
          (this.missingRef = (0, cy.resolveUrl)(t, r, n)),
          (this.missingSchema = (0, cy.normalizeId)((0, cy.getFullPath)(t, this.missingRef)));
      }
    };
  dy.default = fy;
});
var Ti = b((rn) => {
  "use strict";
  Object.defineProperty(rn, "__esModule", { value: !0 });
  rn.resolveSchema =
    rn.getCompilingSchema =
    rn.resolveRef =
    rn.compileSchema =
    rn.SchemaEnv =
      void 0;
  var gn = he(),
    $6 = Ya(),
    Ri = tn(),
    _n = Ja(),
    x$ = Ie(),
    O6 = vo(),
    bo = class {
      constructor(t) {
        var r;
        (this.refs = {}), (this.dynamicAnchors = {});
        let n;
        typeof t.schema == "object" && (n = t.schema),
          (this.schema = t.schema),
          (this.schemaId = t.schemaId),
          (this.root = t.root || this),
          (this.baseId =
            (r = t.baseId) !== null && r !== void 0
              ? r
              : (0, _n.normalizeId)(n?.[t.schemaId || "$id"])),
          (this.schemaPath = t.schemaPath),
          (this.localRefs = t.localRefs),
          (this.meta = t.meta),
          (this.$async = n?.$async),
          (this.refs = {});
      }
    };
  rn.SchemaEnv = bo;
  function py(e) {
    let t = F$.call(this, e);
    if (t) return t;
    let r = (0, _n.getFullPath)(this.opts.uriResolver, e.root.baseId),
      { es5: n, lines: s } = this.opts.code,
      { ownProperties: i } = this.opts,
      o = new gn.CodeGen(this.scope, { es5: n, lines: s, ownProperties: i }),
      a;
    e.$async &&
      (a = o.scopeValue("Error", {
        ref: $6.default,
        code: (0, gn._)`require("ajv/dist/runtime/validation_error").default`,
      }));
    let u = o.scopeName("validate");
    e.validateName = u;
    let l = {
        gen: o,
        allErrors: this.opts.allErrors,
        data: Ri.default.data,
        parentData: Ri.default.parentData,
        parentDataProperty: Ri.default.parentDataProperty,
        dataNames: [Ri.default.data],
        dataPathArr: [gn.nil],
        dataLevel: 0,
        dataTypes: [],
        definedProperties: new Set(),
        topSchemaRef: o.scopeValue(
          "schema",
          this.opts.code.source === !0
            ? { ref: e.schema, code: (0, gn.stringify)(e.schema) }
            : { ref: e.schema },
        ),
        validateName: u,
        ValidationError: a,
        schema: e.schema,
        schemaEnv: e,
        rootId: r,
        baseId: e.baseId || r,
        schemaPath: gn.nil,
        errSchemaPath: e.schemaPath || (this.opts.jtd ? "" : "#"),
        errorPath: (0, gn._)`""`,
        opts: this.opts,
        self: this,
      },
      c;
    try {
      this._compilations.add(e),
        (0, O6.validateFunctionCode)(l),
        o.optimize(this.opts.code.optimize);
      let f = o.toString();
      (c = `${o.scopeRefs(Ri.default.scope)}return ${f}`),
        this.opts.code.process && (c = this.opts.code.process(c, e));
      let h = new Function(`${Ri.default.self}`, `${Ri.default.scope}`, c)(this, this.scope.get());
      if (
        (this.scope.value(u, { ref: h }),
        (h.errors = null),
        (h.schema = e.schema),
        (h.schemaEnv = e),
        e.$async && (h.$async = !0),
        this.opts.code.source === !0 &&
          (h.source = { validateName: u, validateCode: f, scopeValues: o._values }),
        this.opts.unevaluated)
      ) {
        let { props: p, items: y } = l;
        (h.evaluated = {
          props: p instanceof gn.Name ? void 0 : p,
          items: y instanceof gn.Name ? void 0 : y,
          dynamicProps: p instanceof gn.Name,
          dynamicItems: y instanceof gn.Name,
        }),
          h.source && (h.source.evaluated = (0, gn.stringify)(h.evaluated));
      }
      return (e.validate = h), e;
    } catch (f) {
      throw (
        (delete e.validate,
        delete e.validateName,
        c && this.logger.error("Error compiling schema, function code:", c),
        f)
      );
    } finally {
      this._compilations.delete(e);
    }
  }
  rn.compileSchema = py;
  function N6(e, t, r) {
    var n;
    r = (0, _n.resolveUrl)(this.opts.uriResolver, t, r);
    let s = e.refs[r];
    if (s) return s;
    let i = C6.call(this, e, r);
    if (i === void 0) {
      let o = (n = e.localRefs) === null || n === void 0 ? void 0 : n[r],
        { schemaId: a } = this.opts;
      o && (i = new bo({ schema: o, schemaId: a, root: e, baseId: t }));
    }
    if (i !== void 0) return (e.refs[r] = A6.call(this, i));
  }
  rn.resolveRef = N6;
  function A6(e) {
    return (0, _n.inlineRef)(e.schema, this.opts.inlineRefs)
      ? e.schema
      : e.validate
        ? e
        : py.call(this, e);
  }
  function F$(e) {
    for (let t of this._compilations) if (I6(t, e)) return t;
  }
  rn.getCompilingSchema = F$;
  function I6(e, t) {
    return e.schema === t.schema && e.root === t.root && e.baseId === t.baseId;
  }
  function C6(e, t) {
    let r;
    for (; typeof (r = this.refs[t]) == "string"; ) t = r;
    return r || this.schemas[t] || uf.call(this, e, t);
  }
  function uf(e, t) {
    let r = this.opts.uriResolver.parse(t),
      n = (0, _n._getFullPath)(this.opts.uriResolver, r),
      s = (0, _n.getFullPath)(this.opts.uriResolver, e.baseId, void 0);
    if (Object.keys(e.schema).length > 0 && n === s) return hy.call(this, r, e);
    let i = (0, _n.normalizeId)(n),
      o = this.refs[i] || this.schemas[i];
    if (typeof o == "string") {
      let a = uf.call(this, e, o);
      return typeof a?.schema != "object" ? void 0 : hy.call(this, r, a);
    }
    if (typeof o?.schema == "object") {
      if ((o.validate || py.call(this, o), i === (0, _n.normalizeId)(t))) {
        let { schema: a } = o,
          { schemaId: u } = this.opts,
          l = a[u];
        return (
          l && (s = (0, _n.resolveUrl)(this.opts.uriResolver, s, l)),
          new bo({ schema: a, schemaId: u, root: e, baseId: s })
        );
      }
      return hy.call(this, r, o);
    }
  }
  rn.resolveSchema = uf;
  var k6 = new Set(["properties", "patternProperties", "enum", "dependencies", "definitions"]);
  function hy(e, { baseId: t, schema: r, root: n }) {
    var s;
    if (((s = e.fragment) === null || s === void 0 ? void 0 : s[0]) !== "/") return;
    for (let a of e.fragment.slice(1).split("/")) {
      if (typeof r == "boolean") return;
      let u = r[(0, x$.unescapeFragment)(a)];
      if (u === void 0) return;
      r = u;
      let l = typeof r == "object" && r[this.opts.schemaId];
      !k6.has(a) && l && (t = (0, _n.resolveUrl)(this.opts.uriResolver, t, l));
    }
    let i;
    if (typeof r != "boolean" && r.$ref && !(0, x$.schemaHasRulesButRef)(r, this.RULES)) {
      let a = (0, _n.resolveUrl)(this.opts.uriResolver, t, r.$ref);
      i = uf.call(this, n, a);
    }
    let { schemaId: o } = this.opts;
    if (
      ((i = i || new bo({ schema: r, schemaId: o, root: n, baseId: t })),
      i.schema !== i.root.schema)
    )
      return i;
  }
});
var M$ = b((Kie, D6) => {
  D6.exports = {
    $id: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#",
    description: "Meta-schema for $data reference (JSON AnySchema extension proposal)",
    type: "object",
    required: ["$data"],
    properties: {
      $data: {
        type: "string",
        anyOf: [{ format: "relative-json-pointer" }, { format: "json-pointer" }],
      },
    },
    additionalProperties: !1,
  };
});
var V$ = b((lf, z$) => {
  (function (e, t) {
    typeof lf == "object" && typeof z$ < "u"
      ? t(lf)
      : typeof define == "function" && define.amd
        ? define(["exports"], t)
        : t((e.URI = e.URI || {}));
  })(lf, function (e) {
    "use strict";
    function t() {
      for (var O = arguments.length, R = Array(O), A = 0; A < O; A++) R[A] = arguments[A];
      if (R.length > 1) {
        R[0] = R[0].slice(0, -1);
        for (var j = R.length - 1, L = 1; L < j; ++L) R[L] = R[L].slice(1, -1);
        return (R[j] = R[j].slice(1)), R.join("");
      } else return R[0];
    }
    function r(O) {
      return "(?:" + O + ")";
    }
    function n(O) {
      return O === void 0
        ? "undefined"
        : O === null
          ? "null"
          : Object.prototype.toString.call(O).split(" ").pop().split("]").shift().toLowerCase();
    }
    function s(O) {
      return O.toUpperCase();
    }
    function i(O) {
      return O != null
        ? O instanceof Array
          ? O
          : typeof O.length != "number" || O.split || O.setInterval || O.call
            ? [O]
            : Array.prototype.slice.call(O)
        : [];
    }
    function o(O, R) {
      var A = O;
      if (R) for (var j in R) A[j] = R[j];
      return A;
    }
    function a(O) {
      var R = "[A-Za-z]",
        A = "[\\x0D]",
        j = "[0-9]",
        L = "[\\x22]",
        X = t(j, "[A-Fa-f]"),
        Pe = "[\\x0A]",
        xe = "[\\x20]",
        Ke = r(
          r("%[EFef]" + X + "%" + X + X + "%" + X + X) +
            "|" +
            r("%[89A-Fa-f]" + X + "%" + X + X) +
            "|" +
            r("%" + X + X),
        ),
        Pt = "[\\:\\/\\?\\#\\[\\]\\@]",
        je = "[\\!\\$\\&\\'\\(\\)\\*\\+\\,\\;\\=]",
        pt = t(Pt, je),
        $t = O
          ? "[\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]"
          : "[]",
        lt = O ? "[\\uE000-\\uF8FF]" : "[]",
        ze = t(R, j, "[\\-\\.\\_\\~]", $t),
        mt = r(R + t(R, j, "[\\+\\-\\.]") + "*"),
        Qe = r(r(Ke + "|" + t(ze, je, "[\\:]")) + "*"),
        Wn = r(
          r("25[0-5]") +
            "|" +
            r("2[0-4]" + j) +
            "|" +
            r("1" + j + j) +
            "|" +
            r("[1-9]" + j) +
            "|" +
            j,
        ),
        hr = r(
          r("25[0-5]") +
            "|" +
            r("2[0-4]" + j) +
            "|" +
            r("1" + j + j) +
            "|" +
            r("0?[1-9]" + j) +
            "|0?0?" +
            j,
        ),
        Rr = r(hr + "\\." + hr + "\\." + hr + "\\." + hr),
        Ye = r(X + "{1,4}"),
        pr = r(r(Ye + "\\:" + Ye) + "|" + Rr),
        Tr = r(r(Ye + "\\:") + "{6}" + pr),
        Kr = r("\\:\\:" + r(Ye + "\\:") + "{5}" + pr),
        Yn = r(r(Ye) + "?\\:\\:" + r(Ye + "\\:") + "{4}" + pr),
        hn = r(r(r(Ye + "\\:") + "{0,1}" + Ye) + "?\\:\\:" + r(Ye + "\\:") + "{3}" + pr),
        ui = r(r(r(Ye + "\\:") + "{0,2}" + Ye) + "?\\:\\:" + r(Ye + "\\:") + "{2}" + pr),
        Ki = r(r(r(Ye + "\\:") + "{0,3}" + Ye) + "?\\:\\:" + Ye + "\\:" + pr),
        Gi = r(r(r(Ye + "\\:") + "{0,4}" + Ye) + "?\\:\\:" + pr),
        Xn = r(r(r(Ye + "\\:") + "{0,5}" + Ye) + "?\\:\\:" + Ye),
        Ts = r(r(r(Ye + "\\:") + "{0,6}" + Ye) + "?\\:\\:"),
        Gr = r([Tr, Kr, Yn, hn, ui, Ki, Gi, Xn, Ts].join("|")),
        Ps = r(r(ze + "|" + Ke) + "+"),
        da = r(Gr + "\\%25" + Ps),
        P = r(Gr + r("\\%25|\\%(?!" + X + "{2})") + Ps),
        q = r("[vV]" + X + "+\\." + t(ze, je, "[\\:]") + "+"),
        fe = r("\\[" + r(P + "|" + Gr + "|" + q) + "\\]"),
        Ve = r(r(Ke + "|" + t(ze, je)) + "*"),
        et = r(fe + "|" + Rr + "(?!" + Ve + ")|" + Ve),
        Ot = r(j + "*"),
        zt = r(r(Qe + "@") + "?" + et + r("\\:" + Ot) + "?"),
        Pr = r(Ke + "|" + t(ze, je, "[\\:\\@]")),
        gj = r(Pr + "*"),
        xS = r(Pr + "+"),
        _j = r(r(Ke + "|" + t(ze, je, "[\\@]")) + "+"),
        Zn = r(r("\\/" + gj) + "*"),
        Ji = r("\\/" + r(xS + Zn) + "?"),
        sh = r(_j + Zn),
        wl = r(xS + Zn),
        Qi = "(?!" + Pr + ")",
        Wre = r(Zn + "|" + Ji + "|" + sh + "|" + wl + "|" + Qi),
        Wi = r(r(Pr + "|" + t("[\\/\\?]", lt)) + "*"),
        ha = r(r(Pr + "|[\\/\\?]") + "*"),
        FS = r(r("\\/\\/" + zt + Zn) + "|" + Ji + "|" + wl + "|" + Qi),
        Sj = r(mt + "\\:" + FS + r("\\?" + Wi) + "?" + r("\\#" + ha) + "?"),
        vj = r(r("\\/\\/" + zt + Zn) + "|" + Ji + "|" + sh + "|" + Qi),
        bj = r(vj + r("\\?" + Wi) + "?" + r("\\#" + ha) + "?"),
        Yre = r(Sj + "|" + bj),
        Xre = r(mt + "\\:" + FS + r("\\?" + Wi) + "?"),
        Zre =
          "^(" +
          mt +
          ")\\:" +
          r(
            r("\\/\\/(" + r("(" + Qe + ")@") + "?(" + et + ")" + r("\\:(" + Ot + ")") + "?)") +
              "?(" +
              Zn +
              "|" +
              Ji +
              "|" +
              wl +
              "|" +
              Qi +
              ")",
          ) +
          r("\\?(" + Wi + ")") +
          "?" +
          r("\\#(" + ha + ")") +
          "?$",
        ene =
          "^(){0}" +
          r(
            r("\\/\\/(" + r("(" + Qe + ")@") + "?(" + et + ")" + r("\\:(" + Ot + ")") + "?)") +
              "?(" +
              Zn +
              "|" +
              Ji +
              "|" +
              sh +
              "|" +
              Qi +
              ")",
          ) +
          r("\\?(" + Wi + ")") +
          "?" +
          r("\\#(" + ha + ")") +
          "?$",
        tne =
          "^(" +
          mt +
          ")\\:" +
          r(
            r("\\/\\/(" + r("(" + Qe + ")@") + "?(" + et + ")" + r("\\:(" + Ot + ")") + "?)") +
              "?(" +
              Zn +
              "|" +
              Ji +
              "|" +
              wl +
              "|" +
              Qi +
              ")",
          ) +
          r("\\?(" + Wi + ")") +
          "?$",
        rne = "^" + r("\\#(" + ha + ")") + "?$",
        nne = "^" + r("(" + Qe + ")@") + "?(" + et + ")" + r("\\:(" + Ot + ")") + "?$";
      return {
        NOT_SCHEME: new RegExp(t("[^]", R, j, "[\\+\\-\\.]"), "g"),
        NOT_USERINFO: new RegExp(t("[^\\%\\:]", ze, je), "g"),
        NOT_HOST: new RegExp(t("[^\\%\\[\\]\\:]", ze, je), "g"),
        NOT_PATH: new RegExp(t("[^\\%\\/\\:\\@]", ze, je), "g"),
        NOT_PATH_NOSCHEME: new RegExp(t("[^\\%\\/\\@]", ze, je), "g"),
        NOT_QUERY: new RegExp(t("[^\\%]", ze, je, "[\\:\\@\\/\\?]", lt), "g"),
        NOT_FRAGMENT: new RegExp(t("[^\\%]", ze, je, "[\\:\\@\\/\\?]"), "g"),
        ESCAPE: new RegExp(t("[^]", ze, je), "g"),
        UNRESERVED: new RegExp(ze, "g"),
        OTHER_CHARS: new RegExp(t("[^\\%]", ze, pt), "g"),
        PCT_ENCODED: new RegExp(Ke, "g"),
        IPV4ADDRESS: new RegExp("^(" + Rr + ")$"),
        IPV6ADDRESS: new RegExp(
          "^\\[?(" + Gr + ")" + r(r("\\%25|\\%(?!" + X + "{2})") + "(" + Ps + ")") + "?\\]?$",
        ),
      };
    }
    var u = a(!1),
      l = a(!0),
      c = (function () {
        function O(R, A) {
          var j = [],
            L = !0,
            X = !1,
            Pe = void 0;
          try {
            for (
              var xe = R[Symbol.iterator](), Ke;
              !(L = (Ke = xe.next()).done) && (j.push(Ke.value), !(A && j.length === A));
              L = !0
            );
          } catch (Pt) {
            (X = !0), (Pe = Pt);
          } finally {
            try {
              !L && xe.return && xe.return();
            } finally {
              if (X) throw Pe;
            }
          }
          return j;
        }
        return function (R, A) {
          if (Array.isArray(R)) return R;
          if (Symbol.iterator in Object(R)) return O(R, A);
          throw new TypeError("Invalid attempt to destructure non-iterable instance");
        };
      })(),
      f = function (O) {
        if (Array.isArray(O)) {
          for (var R = 0, A = Array(O.length); R < O.length; R++) A[R] = O[R];
          return A;
        } else return Array.from(O);
      },
      d = 2147483647,
      h = 36,
      p = 1,
      y = 26,
      _ = 38,
      S = 700,
      E = 72,
      g = 128,
      m = "-",
      T = /^xn--/,
      N = /[^\0-\x7E]/,
      w = /[\x2E\u3002\uFF0E\uFF61]/g,
      $ = {
        overflow: "Overflow: input needs wider integers to process",
        "not-basic": "Illegal input >= 0x80 (not a basic code point)",
        "invalid-input": "Invalid input",
      },
      D = h - p,
      v = Math.floor,
      M = String.fromCharCode;
    function k(O) {
      throw new RangeError($[O]);
    }
    function x(O, R) {
      for (var A = [], j = O.length; j--; ) A[j] = R(O[j]);
      return A;
    }
    function ie(O, R) {
      var A = O.split("@"),
        j = "";
      A.length > 1 && ((j = A[0] + "@"), (O = A[1])), (O = O.replace(w, "."));
      var L = O.split("."),
        X = x(L, R).join(".");
      return j + X;
    }
    function Z(O) {
      for (var R = [], A = 0, j = O.length; A < j; ) {
        var L = O.charCodeAt(A++);
        if (L >= 55296 && L <= 56319 && A < j) {
          var X = O.charCodeAt(A++);
          (X & 64512) == 56320 ? R.push(((L & 1023) << 10) + (X & 1023) + 65536) : (R.push(L), A--);
        } else R.push(L);
      }
      return R;
    }
    var G = function (R) {
        return String.fromCodePoint.apply(String, f(R));
      },
      Y = function (R) {
        return R - 48 < 10 ? R - 22 : R - 65 < 26 ? R - 65 : R - 97 < 26 ? R - 97 : h;
      },
      U = function (R, A) {
        return R + 22 + 75 * (R < 26) - ((A != 0) << 5);
      },
      z = function (R, A, j) {
        var L = 0;
        for (R = j ? v(R / S) : R >> 1, R += v(R / A); R > (D * y) >> 1; L += h) R = v(R / D);
        return v(L + ((D + 1) * R) / (R + _));
      },
      oe = function (R) {
        var A = [],
          j = R.length,
          L = 0,
          X = g,
          Pe = E,
          xe = R.lastIndexOf(m);
        xe < 0 && (xe = 0);
        for (var Ke = 0; Ke < xe; ++Ke)
          R.charCodeAt(Ke) >= 128 && k("not-basic"), A.push(R.charCodeAt(Ke));
        for (var Pt = xe > 0 ? xe + 1 : 0; Pt < j; ) {
          for (var je = L, pt = 1, $t = h; ; $t += h) {
            Pt >= j && k("invalid-input");
            var lt = Y(R.charCodeAt(Pt++));
            (lt >= h || lt > v((d - L) / pt)) && k("overflow"), (L += lt * pt);
            var ze = $t <= Pe ? p : $t >= Pe + y ? y : $t - Pe;
            if (lt < ze) break;
            var mt = h - ze;
            pt > v(d / mt) && k("overflow"), (pt *= mt);
          }
          var Qe = A.length + 1;
          (Pe = z(L - je, Qe, je == 0)),
            v(L / Qe) > d - X && k("overflow"),
            (X += v(L / Qe)),
            (L %= Qe),
            A.splice(L++, 0, X);
        }
        return String.fromCodePoint.apply(String, A);
      },
      Te = function (R) {
        var A = [];
        R = Z(R);
        var j = R.length,
          L = g,
          X = 0,
          Pe = E,
          xe = !0,
          Ke = !1,
          Pt = void 0;
        try {
          for (var je = R[Symbol.iterator](), pt; !(xe = (pt = je.next()).done); xe = !0) {
            var $t = pt.value;
            $t < 128 && A.push(M($t));
          }
        } catch (P) {
          (Ke = !0), (Pt = P);
        } finally {
          try {
            !xe && je.return && je.return();
          } finally {
            if (Ke) throw Pt;
          }
        }
        var lt = A.length,
          ze = lt;
        for (lt && A.push(m); ze < j; ) {
          var mt = d,
            Qe = !0,
            Wn = !1,
            hr = void 0;
          try {
            for (var Rr = R[Symbol.iterator](), Ye; !(Qe = (Ye = Rr.next()).done); Qe = !0) {
              var pr = Ye.value;
              pr >= L && pr < mt && (mt = pr);
            }
          } catch (P) {
            (Wn = !0), (hr = P);
          } finally {
            try {
              !Qe && Rr.return && Rr.return();
            } finally {
              if (Wn) throw hr;
            }
          }
          var Tr = ze + 1;
          mt - L > v((d - X) / Tr) && k("overflow"), (X += (mt - L) * Tr), (L = mt);
          var Kr = !0,
            Yn = !1,
            hn = void 0;
          try {
            for (var ui = R[Symbol.iterator](), Ki; !(Kr = (Ki = ui.next()).done); Kr = !0) {
              var Gi = Ki.value;
              if ((Gi < L && ++X > d && k("overflow"), Gi == L)) {
                for (var Xn = X, Ts = h; ; Ts += h) {
                  var Gr = Ts <= Pe ? p : Ts >= Pe + y ? y : Ts - Pe;
                  if (Xn < Gr) break;
                  var Ps = Xn - Gr,
                    da = h - Gr;
                  A.push(M(U(Gr + (Ps % da), 0))), (Xn = v(Ps / da));
                }
                A.push(M(U(Xn, 0))), (Pe = z(X, Tr, ze == lt)), (X = 0), ++ze;
              }
            }
          } catch (P) {
            (Yn = !0), (hn = P);
          } finally {
            try {
              !Kr && ui.return && ui.return();
            } finally {
              if (Yn) throw hn;
            }
          }
          ++X, ++L;
        }
        return A.join("");
      },
      ce = function (R) {
        return ie(R, function (A) {
          return T.test(A) ? oe(A.slice(4).toLowerCase()) : A;
        });
      },
      Se = function (R) {
        return ie(R, function (A) {
          return N.test(A) ? "xn--" + Te(A) : A;
        });
      },
      Ee = {
        version: "2.1.0",
        ucs2: { decode: Z, encode: G },
        decode: oe,
        encode: Te,
        toASCII: Se,
        toUnicode: ce,
      },
      ue = {};
    function Re(O) {
      var R = O.charCodeAt(0),
        A = void 0;
      return (
        R < 16
          ? (A = "%0" + R.toString(16).toUpperCase())
          : R < 128
            ? (A = "%" + R.toString(16).toUpperCase())
            : R < 2048
              ? (A =
                  "%" +
                  ((R >> 6) | 192).toString(16).toUpperCase() +
                  "%" +
                  ((R & 63) | 128).toString(16).toUpperCase())
              : (A =
                  "%" +
                  ((R >> 12) | 224).toString(16).toUpperCase() +
                  "%" +
                  (((R >> 6) & 63) | 128).toString(16).toUpperCase() +
                  "%" +
                  ((R & 63) | 128).toString(16).toUpperCase()),
        A
      );
    }
    function ee(O) {
      for (var R = "", A = 0, j = O.length; A < j; ) {
        var L = parseInt(O.substr(A + 1, 2), 16);
        if (L < 128) (R += String.fromCharCode(L)), (A += 3);
        else if (L >= 194 && L < 224) {
          if (j - A >= 6) {
            var X = parseInt(O.substr(A + 4, 2), 16);
            R += String.fromCharCode(((L & 31) << 6) | (X & 63));
          } else R += O.substr(A, 6);
          A += 6;
        } else if (L >= 224) {
          if (j - A >= 9) {
            var Pe = parseInt(O.substr(A + 4, 2), 16),
              xe = parseInt(O.substr(A + 7, 2), 16);
            R += String.fromCharCode(((L & 15) << 12) | ((Pe & 63) << 6) | (xe & 63));
          } else R += O.substr(A, 9);
          A += 9;
        } else (R += O.substr(A, 3)), (A += 3);
      }
      return R;
    }
    function ve(O, R) {
      function A(j) {
        var L = ee(j);
        return L.match(R.UNRESERVED) ? L : j;
      }
      return (
        O.scheme &&
          (O.scheme = String(O.scheme)
            .replace(R.PCT_ENCODED, A)
            .toLowerCase()
            .replace(R.NOT_SCHEME, "")),
        O.userinfo !== void 0 &&
          (O.userinfo = String(O.userinfo)
            .replace(R.PCT_ENCODED, A)
            .replace(R.NOT_USERINFO, Re)
            .replace(R.PCT_ENCODED, s)),
        O.host !== void 0 &&
          (O.host = String(O.host)
            .replace(R.PCT_ENCODED, A)
            .toLowerCase()
            .replace(R.NOT_HOST, Re)
            .replace(R.PCT_ENCODED, s)),
        O.path !== void 0 &&
          (O.path = String(O.path)
            .replace(R.PCT_ENCODED, A)
            .replace(O.scheme ? R.NOT_PATH : R.NOT_PATH_NOSCHEME, Re)
            .replace(R.PCT_ENCODED, s)),
        O.query !== void 0 &&
          (O.query = String(O.query)
            .replace(R.PCT_ENCODED, A)
            .replace(R.NOT_QUERY, Re)
            .replace(R.PCT_ENCODED, s)),
        O.fragment !== void 0 &&
          (O.fragment = String(O.fragment)
            .replace(R.PCT_ENCODED, A)
            .replace(R.NOT_FRAGMENT, Re)
            .replace(R.PCT_ENCODED, s)),
        O
      );
    }
    function Ae(O) {
      return O.replace(/^0*(.*)/, "$1") || "0";
    }
    function Oe(O, R) {
      var A = O.match(R.IPV4ADDRESS) || [],
        j = c(A, 2),
        L = j[1];
      return L ? L.split(".").map(Ae).join(".") : O;
    }
    function me(O, R) {
      var A = O.match(R.IPV6ADDRESS) || [],
        j = c(A, 3),
        L = j[1],
        X = j[2];
      if (L) {
        for (
          var Pe = L.toLowerCase().split("::").reverse(),
            xe = c(Pe, 2),
            Ke = xe[0],
            Pt = xe[1],
            je = Pt ? Pt.split(":").map(Ae) : [],
            pt = Ke.split(":").map(Ae),
            $t = R.IPV4ADDRESS.test(pt[pt.length - 1]),
            lt = $t ? 7 : 8,
            ze = pt.length - lt,
            mt = Array(lt),
            Qe = 0;
          Qe < lt;
          ++Qe
        )
          mt[Qe] = je[Qe] || pt[ze + Qe] || "";
        $t && (mt[lt - 1] = Oe(mt[lt - 1], R));
        var Wn = mt.reduce(function (Tr, Kr, Yn) {
            if (!Kr || Kr === "0") {
              var hn = Tr[Tr.length - 1];
              hn && hn.index + hn.length === Yn ? hn.length++ : Tr.push({ index: Yn, length: 1 });
            }
            return Tr;
          }, []),
          hr = Wn.sort(function (Tr, Kr) {
            return Kr.length - Tr.length;
          })[0],
          Rr = void 0;
        if (hr && hr.length > 1) {
          var Ye = mt.slice(0, hr.index),
            pr = mt.slice(hr.index + hr.length);
          Rr = Ye.join(":") + "::" + pr.join(":");
        } else Rr = mt.join(":");
        return X && (Rr += "%" + X), Rr;
      } else return O;
    }
    var C =
        /^(?:([^:\/?#]+):)?(?:\/\/((?:([^\/?#@]*)@)?(\[[^\/?#\]]+\]|[^\/?#:]*)(?:\:(\d*))?))?([^?#]*)(?:\?([^#]*))?(?:#((?:.|\n|\r)*))?/i,
      H = "".match(/(){0}/)[1] === void 0;
    function K(O) {
      var R = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {},
        A = {},
        j = R.iri !== !1 ? l : u;
      R.reference === "suffix" && (O = (R.scheme ? R.scheme + ":" : "") + "//" + O);
      var L = O.match(C);
      if (L) {
        H
          ? ((A.scheme = L[1]),
            (A.userinfo = L[3]),
            (A.host = L[4]),
            (A.port = parseInt(L[5], 10)),
            (A.path = L[6] || ""),
            (A.query = L[7]),
            (A.fragment = L[8]),
            isNaN(A.port) && (A.port = L[5]))
          : ((A.scheme = L[1] || void 0),
            (A.userinfo = O.indexOf("@") !== -1 ? L[3] : void 0),
            (A.host = O.indexOf("//") !== -1 ? L[4] : void 0),
            (A.port = parseInt(L[5], 10)),
            (A.path = L[6] || ""),
            (A.query = O.indexOf("?") !== -1 ? L[7] : void 0),
            (A.fragment = O.indexOf("#") !== -1 ? L[8] : void 0),
            isNaN(A.port) && (A.port = O.match(/\/\/(?:.|\n)*\:(?:\/|\?|\#|$)/) ? L[4] : void 0)),
          A.host && (A.host = me(Oe(A.host, j), j)),
          A.scheme === void 0 &&
          A.userinfo === void 0 &&
          A.host === void 0 &&
          A.port === void 0 &&
          !A.path &&
          A.query === void 0
            ? (A.reference = "same-document")
            : A.scheme === void 0
              ? (A.reference = "relative")
              : A.fragment === void 0
                ? (A.reference = "absolute")
                : (A.reference = "uri"),
          R.reference &&
            R.reference !== "suffix" &&
            R.reference !== A.reference &&
            (A.error = A.error || "URI is not a " + R.reference + " reference.");
        var X = ue[(R.scheme || A.scheme || "").toLowerCase()];
        if (!R.unicodeSupport && (!X || !X.unicodeSupport)) {
          if (A.host && (R.domainHost || (X && X.domainHost)))
            try {
              A.host = Ee.toASCII(A.host.replace(j.PCT_ENCODED, ee).toLowerCase());
            } catch (Pe) {
              A.error =
                A.error || "Host's domain name can not be converted to ASCII via punycode: " + Pe;
            }
          ve(A, u);
        } else ve(A, j);
        X && X.parse && X.parse(A, R);
      } else A.error = A.error || "URI can not be parsed.";
      return A;
    }
    function te(O, R) {
      var A = R.iri !== !1 ? l : u,
        j = [];
      return (
        O.userinfo !== void 0 && (j.push(O.userinfo), j.push("@")),
        O.host !== void 0 &&
          j.push(
            me(Oe(String(O.host), A), A).replace(A.IPV6ADDRESS, function (L, X, Pe) {
              return "[" + X + (Pe ? "%25" + Pe : "") + "]";
            }),
          ),
        (typeof O.port == "number" || typeof O.port == "string") &&
          (j.push(":"), j.push(String(O.port))),
        j.length ? j.join("") : void 0
      );
    }
    var _e = /^\.\.?\//,
      F = /^\/\.(\/|$)/,
      Me = /^\/\.\.(\/|$)/,
      Xe = /^\/?(?:.|\n)*?(?=\/|$)/;
    function Je(O) {
      for (var R = []; O.length; )
        if (O.match(_e)) O = O.replace(_e, "");
        else if (O.match(F)) O = O.replace(F, "/");
        else if (O.match(Me)) (O = O.replace(Me, "/")), R.pop();
        else if (O === "." || O === "..") O = "";
        else {
          var A = O.match(Xe);
          if (A) {
            var j = A[0];
            (O = O.slice(j.length)), R.push(j);
          } else throw new Error("Unexpected dot segment condition");
        }
      return R.join("");
    }
    function wt(O) {
      var R = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {},
        A = R.iri ? l : u,
        j = [],
        L = ue[(R.scheme || O.scheme || "").toLowerCase()];
      if ((L && L.serialize && L.serialize(O, R), O.host && !A.IPV6ADDRESS.test(O.host))) {
        if (R.domainHost || (L && L.domainHost))
          try {
            O.host = R.iri
              ? Ee.toUnicode(O.host)
              : Ee.toASCII(O.host.replace(A.PCT_ENCODED, ee).toLowerCase());
          } catch (xe) {
            O.error =
              O.error ||
              "Host's domain name can not be converted to " +
                (R.iri ? "Unicode" : "ASCII") +
                " via punycode: " +
                xe;
          }
      }
      ve(O, A), R.reference !== "suffix" && O.scheme && (j.push(O.scheme), j.push(":"));
      var X = te(O, R);
      if (
        (X !== void 0 &&
          (R.reference !== "suffix" && j.push("//"),
          j.push(X),
          O.path && O.path.charAt(0) !== "/" && j.push("/")),
        O.path !== void 0)
      ) {
        var Pe = O.path;
        !R.absolutePath && (!L || !L.absolutePath) && (Pe = Je(Pe)),
          X === void 0 && (Pe = Pe.replace(/^\/\//, "/%2F")),
          j.push(Pe);
      }
      return (
        O.query !== void 0 && (j.push("?"), j.push(O.query)),
        O.fragment !== void 0 && (j.push("#"), j.push(O.fragment)),
        j.join("")
      );
    }
    function bs(O, R) {
      var A = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {},
        j = arguments[3],
        L = {};
      return (
        j || ((O = K(wt(O, A), A)), (R = K(wt(R, A), A))),
        (A = A || {}),
        !A.tolerant && R.scheme
          ? ((L.scheme = R.scheme),
            (L.userinfo = R.userinfo),
            (L.host = R.host),
            (L.port = R.port),
            (L.path = Je(R.path || "")),
            (L.query = R.query))
          : (R.userinfo !== void 0 || R.host !== void 0 || R.port !== void 0
              ? ((L.userinfo = R.userinfo),
                (L.host = R.host),
                (L.port = R.port),
                (L.path = Je(R.path || "")),
                (L.query = R.query))
              : (R.path
                  ? (R.path.charAt(0) === "/"
                      ? (L.path = Je(R.path))
                      : ((O.userinfo !== void 0 || O.host !== void 0 || O.port !== void 0) &&
                        !O.path
                          ? (L.path = "/" + R.path)
                          : O.path
                            ? (L.path = O.path.slice(0, O.path.lastIndexOf("/") + 1) + R.path)
                            : (L.path = R.path),
                        (L.path = Je(L.path))),
                    (L.query = R.query))
                  : ((L.path = O.path),
                    R.query !== void 0 ? (L.query = R.query) : (L.query = O.query)),
                (L.userinfo = O.userinfo),
                (L.host = O.host),
                (L.port = O.port)),
            (L.scheme = O.scheme)),
        (L.fragment = R.fragment),
        L
      );
    }
    function jr(O, R, A) {
      var j = o({ scheme: "null" }, A);
      return wt(bs(K(O, j), K(R, j), j, !0), j);
    }
    function Hr(O, R) {
      return (
        typeof O == "string" ? (O = wt(K(O, R), R)) : n(O) === "object" && (O = K(wt(O, R), R)), O
      );
    }
    function Pn(O, R, A) {
      return (
        typeof O == "string" ? (O = wt(K(O, A), A)) : n(O) === "object" && (O = wt(O, A)),
        typeof R == "string" ? (R = wt(K(R, A), A)) : n(R) === "object" && (R = wt(R, A)),
        O === R
      );
    }
    function $n(O, R) {
      return O && O.toString().replace(!R || !R.iri ? u.ESCAPE : l.ESCAPE, Re);
    }
    function Lr(O, R) {
      return O && O.toString().replace(!R || !R.iri ? u.PCT_ENCODED : l.PCT_ENCODED, ee);
    }
    var Et = {
        scheme: "http",
        domainHost: !0,
        parse: function (R, A) {
          return R.host || (R.error = R.error || "HTTP URIs must have a host."), R;
        },
        serialize: function (R, A) {
          var j = String(R.scheme).toLowerCase() === "https";
          return (
            (R.port === (j ? 443 : 80) || R.port === "") && (R.port = void 0),
            R.path || (R.path = "/"),
            R
          );
        },
      },
      Ft = { scheme: "https", domainHost: Et.domainHost, parse: Et.parse, serialize: Et.serialize };
    function Hi(O) {
      return typeof O.secure == "boolean" ? O.secure : String(O.scheme).toLowerCase() === "wss";
    }
    var fn = {
        scheme: "ws",
        domainHost: !0,
        parse: function (R, A) {
          var j = R;
          return (
            (j.secure = Hi(j)),
            (j.resourceName = (j.path || "/") + (j.query ? "?" + j.query : "")),
            (j.path = void 0),
            (j.query = void 0),
            j
          );
        },
        serialize: function (R, A) {
          if (
            ((R.port === (Hi(R) ? 443 : 80) || R.port === "") && (R.port = void 0),
            typeof R.secure == "boolean" &&
              ((R.scheme = R.secure ? "wss" : "ws"), (R.secure = void 0)),
            R.resourceName)
          ) {
            var j = R.resourceName.split("?"),
              L = c(j, 2),
              X = L[0],
              Pe = L[1];
            (R.path = X && X !== "/" ? X : void 0), (R.query = Pe), (R.resourceName = void 0);
          }
          return (R.fragment = void 0), R;
        },
      },
      Ze = { scheme: "wss", domainHost: fn.domainHost, parse: fn.parse, serialize: fn.serialize },
      Bt = {},
      vl = !0,
      Zt =
        "[A-Za-z0-9\\-\\.\\_\\~" +
        (vl ? "\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF" : "") +
        "]",
      ht = "[0-9A-Fa-f]",
      ws = r(
        r("%[EFef]" + ht + "%" + ht + ht + "%" + ht + ht) +
          "|" +
          r("%[89A-Fa-f]" + ht + "%" + ht + ht) +
          "|" +
          r("%" + ht + ht),
      ),
      nt = "[A-Za-z0-9\\!\\$\\%\\'\\*\\+\\-\\^\\_\\`\\{\\|\\}\\~]",
      Es = "[\\!\\$\\%\\'\\(\\)\\*\\+\\,\\-\\.0-9\\<\\>A-Z\\x5E-\\x7E]",
      fa = t(Es, '[\\"\\\\]'),
      ut = "[\\!\\$\\'\\(\\)\\*\\+\\,\\;\\:\\@]",
      On = new RegExp(Zt, "g"),
      Rs = new RegExp(ws, "g"),
      xr = new RegExp(t("[^]", nt, "[\\.]", '[\\"]', fa), "g"),
      er = new RegExp(t("[^]", Zt, ut), "g"),
      Bi = er;
    function Br(O) {
      var R = ee(O);
      return R.match(On) ? R : O;
    }
    var Nn = {
        scheme: "mailto",
        parse: function (R, A) {
          var j = R,
            L = (j.to = j.path ? j.path.split(",") : []);
          if (((j.path = void 0), j.query)) {
            for (
              var X = !1, Pe = {}, xe = j.query.split("&"), Ke = 0, Pt = xe.length;
              Ke < Pt;
              ++Ke
            ) {
              var je = xe[Ke].split("=");
              switch (je[0]) {
                case "to":
                  for (var pt = je[1].split(","), $t = 0, lt = pt.length; $t < lt; ++$t)
                    L.push(pt[$t]);
                  break;
                case "subject":
                  j.subject = Lr(je[1], A);
                  break;
                case "body":
                  j.body = Lr(je[1], A);
                  break;
                default:
                  (X = !0), (Pe[Lr(je[0], A)] = Lr(je[1], A));
                  break;
              }
            }
            X && (j.headers = Pe);
          }
          j.query = void 0;
          for (var ze = 0, mt = L.length; ze < mt; ++ze) {
            var Qe = L[ze].split("@");
            if (((Qe[0] = Lr(Qe[0])), A.unicodeSupport)) Qe[1] = Lr(Qe[1], A).toLowerCase();
            else
              try {
                Qe[1] = Ee.toASCII(Lr(Qe[1], A).toLowerCase());
              } catch (Wn) {
                j.error =
                  j.error ||
                  "Email address's domain name can not be converted to ASCII via punycode: " + Wn;
              }
            L[ze] = Qe.join("@");
          }
          return j;
        },
        serialize: function (R, A) {
          var j = R,
            L = i(R.to);
          if (L) {
            for (var X = 0, Pe = L.length; X < Pe; ++X) {
              var xe = String(L[X]),
                Ke = xe.lastIndexOf("@"),
                Pt = xe.slice(0, Ke).replace(Rs, Br).replace(Rs, s).replace(xr, Re),
                je = xe.slice(Ke + 1);
              try {
                je = A.iri ? Ee.toUnicode(je) : Ee.toASCII(Lr(je, A).toLowerCase());
              } catch (ze) {
                j.error =
                  j.error ||
                  "Email address's domain name can not be converted to " +
                    (A.iri ? "Unicode" : "ASCII") +
                    " via punycode: " +
                    ze;
              }
              L[X] = Pt + "@" + je;
            }
            j.path = L.join(",");
          }
          var pt = (R.headers = R.headers || {});
          R.subject && (pt.subject = R.subject), R.body && (pt.body = R.body);
          var $t = [];
          for (var lt in pt)
            pt[lt] !== Bt[lt] &&
              $t.push(
                lt.replace(Rs, Br).replace(Rs, s).replace(er, Re) +
                  "=" +
                  pt[lt].replace(Rs, Br).replace(Rs, s).replace(Bi, Re),
              );
          return $t.length && (j.query = $t.join("&")), j;
        },
      },
      ai = /^([^\:]+)\:(.*)/,
      dn = {
        scheme: "urn",
        parse: function (R, A) {
          var j = R.path && R.path.match(ai),
            L = R;
          if (j) {
            var X = A.scheme || L.scheme || "urn",
              Pe = j[1].toLowerCase(),
              xe = j[2],
              Ke = X + ":" + (A.nid || Pe),
              Pt = ue[Ke];
            (L.nid = Pe), (L.nss = xe), (L.path = void 0), Pt && (L = Pt.parse(L, A));
          } else L.error = L.error || "URN can not be parsed.";
          return L;
        },
        serialize: function (R, A) {
          var j = A.scheme || R.scheme || "urn",
            L = R.nid,
            X = j + ":" + (A.nid || L),
            Pe = ue[X];
          Pe && (R = Pe.serialize(R, A));
          var xe = R,
            Ke = R.nss;
          return (xe.path = (L || A.nid) + ":" + Ke), xe;
        },
      },
      nh = /^[0-9A-Fa-f]{8}(?:\-[0-9A-Fa-f]{4}){3}\-[0-9A-Fa-f]{12}$/,
      bl = {
        scheme: "urn:uuid",
        parse: function (R, A) {
          var j = R;
          return (
            (j.uuid = j.nss),
            (j.nss = void 0),
            !A.tolerant &&
              (!j.uuid || !j.uuid.match(nh)) &&
              (j.error = j.error || "UUID is not valid."),
            j
          );
        },
        serialize: function (R, A) {
          var j = R;
          return (j.nss = (R.uuid || "").toLowerCase()), j;
        },
      };
    (ue[Et.scheme] = Et),
      (ue[Ft.scheme] = Ft),
      (ue[fn.scheme] = fn),
      (ue[Ze.scheme] = Ze),
      (ue[Nn.scheme] = Nn),
      (ue[dn.scheme] = dn),
      (ue[bl.scheme] = bl),
      (e.SCHEMES = ue),
      (e.pctEncChar = Re),
      (e.pctDecChars = ee),
      (e.parse = K),
      (e.removeDotSegments = Je),
      (e.serialize = wt),
      (e.resolveComponents = bs),
      (e.resolve = jr),
      (e.normalize = Hr),
      (e.equal = Pn),
      (e.escapeComponent = $n),
      (e.unescapeComponent = Lr),
      Object.defineProperty(e, "__esModule", { value: !0 });
  });
});
var H$ = b((my) => {
  "use strict";
  Object.defineProperty(my, "__esModule", { value: !0 });
  var U$ = V$();
  U$.code = 'require("ajv/dist/runtime/uri").default';
  my.default = U$;
});
var _y = b((Qt) => {
  "use strict";
  Object.defineProperty(Qt, "__esModule", { value: !0 });
  Qt.CodeGen = Qt.Name = Qt.nil = Qt.stringify = Qt.str = Qt._ = Qt.KeywordCxt = void 0;
  var q6 = vo();
  Object.defineProperty(Qt, "KeywordCxt", {
    enumerable: !0,
    get: function () {
      return q6.KeywordCxt;
    },
  });
  var wo = he();
  Object.defineProperty(Qt, "_", {
    enumerable: !0,
    get: function () {
      return wo._;
    },
  });
  Object.defineProperty(Qt, "str", {
    enumerable: !0,
    get: function () {
      return wo.str;
    },
  });
  Object.defineProperty(Qt, "stringify", {
    enumerable: !0,
    get: function () {
      return wo.stringify;
    },
  });
  Object.defineProperty(Qt, "nil", {
    enumerable: !0,
    get: function () {
      return wo.nil;
    },
  });
  Object.defineProperty(Qt, "Name", {
    enumerable: !0,
    get: function () {
      return wo.Name;
    },
  });
  Object.defineProperty(Qt, "CodeGen", {
    enumerable: !0,
    get: function () {
      return wo.CodeGen;
    },
  });
  var j6 = Ya(),
    Q$ = ls(),
    L6 = Wm(),
    Xa = Ti(),
    x6 = he(),
    Za = Ja(),
    cf = Ga(),
    gy = Ie(),
    B$ = M$(),
    F6 = H$(),
    W$ = (e, t) => new RegExp(e, t);
  W$.code = "new RegExp";
  var M6 = ["removeAdditional", "useDefaults", "coerceTypes"],
    z6 = new Set([
      "validate",
      "serialize",
      "parse",
      "wrapper",
      "root",
      "schema",
      "keyword",
      "pattern",
      "formats",
      "validate$data",
      "func",
      "obj",
      "Error",
    ]),
    V6 = {
      errorDataPath: "",
      format: "`validateFormats: false` can be used instead.",
      nullable: '"nullable" keyword is supported by default.',
      jsonPointers: "Deprecated jsPropertySyntax can be used instead.",
      extendRefs: "Deprecated ignoreKeywordsWithRef can be used instead.",
      missingRefs: "Pass empty schema with $id that should be ignored to ajv.addSchema.",
      processCode: "Use option `code: {process: (code, schemaEnv: object) => string}`",
      sourceCode: "Use option `code: {source: true}`",
      strictDefaults: "It is default now, see option `strict`.",
      strictKeywords: "It is default now, see option `strict`.",
      uniqueItems: '"uniqueItems" keyword is always validated.',
      unknownFormats:
        "Disable strict mode or pass `true` to `ajv.addFormat` (or `formats` option).",
      cache: "Map is used as cache, schema object as key.",
      serialize: "Map is used as cache, schema object as key.",
      ajvErrors: "It is default now.",
    },
    U6 = {
      ignoreKeywordsWithRef: "",
      jsPropertySyntax: "",
      unicode: '"minLength"/"maxLength" account for unicode characters by default.',
    },
    K$ = 200;
  function H6(e) {
    var t, r, n, s, i, o, a, u, l, c, f, d, h, p, y, _, S, E, g, m, T, N, w, $, D;
    let v = e.strict,
      M = (t = e.code) === null || t === void 0 ? void 0 : t.optimize,
      k = M === !0 || M === void 0 ? 1 : M || 0,
      x =
        (n = (r = e.code) === null || r === void 0 ? void 0 : r.regExp) !== null && n !== void 0
          ? n
          : W$,
      ie = (s = e.uriResolver) !== null && s !== void 0 ? s : F6.default;
    return {
      strictSchema:
        (o = (i = e.strictSchema) !== null && i !== void 0 ? i : v) !== null && o !== void 0
          ? o
          : !0,
      strictNumbers:
        (u = (a = e.strictNumbers) !== null && a !== void 0 ? a : v) !== null && u !== void 0
          ? u
          : !0,
      strictTypes:
        (c = (l = e.strictTypes) !== null && l !== void 0 ? l : v) !== null && c !== void 0
          ? c
          : "log",
      strictTuples:
        (d = (f = e.strictTuples) !== null && f !== void 0 ? f : v) !== null && d !== void 0
          ? d
          : "log",
      strictRequired:
        (p = (h = e.strictRequired) !== null && h !== void 0 ? h : v) !== null && p !== void 0
          ? p
          : !1,
      code: e.code ? { ...e.code, optimize: k, regExp: x } : { optimize: k, regExp: x },
      loopRequired: (y = e.loopRequired) !== null && y !== void 0 ? y : K$,
      loopEnum: (_ = e.loopEnum) !== null && _ !== void 0 ? _ : K$,
      meta: (S = e.meta) !== null && S !== void 0 ? S : !0,
      messages: (E = e.messages) !== null && E !== void 0 ? E : !0,
      inlineRefs: (g = e.inlineRefs) !== null && g !== void 0 ? g : !0,
      schemaId: (m = e.schemaId) !== null && m !== void 0 ? m : "$id",
      addUsedSchema: (T = e.addUsedSchema) !== null && T !== void 0 ? T : !0,
      validateSchema: (N = e.validateSchema) !== null && N !== void 0 ? N : !0,
      validateFormats: (w = e.validateFormats) !== null && w !== void 0 ? w : !0,
      unicodeRegExp: ($ = e.unicodeRegExp) !== null && $ !== void 0 ? $ : !0,
      int32range: (D = e.int32range) !== null && D !== void 0 ? D : !0,
      uriResolver: ie,
    };
  }
  var eu = class {
    constructor(t = {}) {
      (this.schemas = {}),
        (this.refs = {}),
        (this.formats = {}),
        (this._compilations = new Set()),
        (this._loading = {}),
        (this._cache = new Map()),
        (t = this.opts = { ...t, ...H6(t) });
      let { es5: r, lines: n } = this.opts.code;
      (this.scope = new x6.ValueScope({ scope: {}, prefixes: z6, es5: r, lines: n })),
        (this.logger = W6(t.logger));
      let s = t.validateFormats;
      (t.validateFormats = !1),
        (this.RULES = (0, L6.getRules)()),
        G$.call(this, V6, t, "NOT SUPPORTED"),
        G$.call(this, U6, t, "DEPRECATED", "warn"),
        (this._metaOpts = J6.call(this)),
        t.formats && K6.call(this),
        this._addVocabularies(),
        this._addDefaultMetaSchema(),
        t.keywords && G6.call(this, t.keywords),
        typeof t.meta == "object" && this.addMetaSchema(t.meta),
        B6.call(this),
        (t.validateFormats = s);
    }
    _addVocabularies() {
      this.addKeyword("$async");
    }
    _addDefaultMetaSchema() {
      let { $data: t, meta: r, schemaId: n } = this.opts,
        s = B$;
      n === "id" && ((s = { ...B$ }), (s.id = s.$id), delete s.$id),
        r && t && this.addMetaSchema(s, s[n], !1);
    }
    defaultMeta() {
      let { meta: t, schemaId: r } = this.opts;
      return (this.opts.defaultMeta = typeof t == "object" ? t[r] || t : void 0);
    }
    validate(t, r) {
      let n;
      if (typeof t == "string") {
        if (((n = this.getSchema(t)), !n)) throw new Error(`no schema with key or ref "${t}"`);
      } else n = this.compile(t);
      let s = n(r);
      return "$async" in n || (this.errors = n.errors), s;
    }
    compile(t, r) {
      let n = this._addSchema(t, r);
      return n.validate || this._compileSchemaEnv(n);
    }
    compileAsync(t, r) {
      if (typeof this.opts.loadSchema != "function")
        throw new Error("options.loadSchema should be a function");
      let { loadSchema: n } = this.opts;
      return s.call(this, t, r);
      async function s(c, f) {
        await i.call(this, c.$schema);
        let d = this._addSchema(c, f);
        return d.validate || o.call(this, d);
      }
      async function i(c) {
        c && !this.getSchema(c) && (await s.call(this, { $ref: c }, !0));
      }
      async function o(c) {
        try {
          return this._compileSchemaEnv(c);
        } catch (f) {
          if (!(f instanceof Q$.default)) throw f;
          return a.call(this, f), await u.call(this, f.missingSchema), o.call(this, c);
        }
      }
      function a({ missingSchema: c, missingRef: f }) {
        if (this.refs[c]) throw new Error(`AnySchema ${c} is loaded but ${f} cannot be resolved`);
      }
      async function u(c) {
        let f = await l.call(this, c);
        this.refs[c] || (await i.call(this, f.$schema)), this.refs[c] || this.addSchema(f, c, r);
      }
      async function l(c) {
        let f = this._loading[c];
        if (f) return f;
        try {
          return await (this._loading[c] = n(c));
        } finally {
          delete this._loading[c];
        }
      }
    }
    addSchema(t, r, n, s = this.opts.validateSchema) {
      if (Array.isArray(t)) {
        for (let o of t) this.addSchema(o, void 0, n, s);
        return this;
      }
      let i;
      if (typeof t == "object") {
        let { schemaId: o } = this.opts;
        if (((i = t[o]), i !== void 0 && typeof i != "string"))
          throw new Error(`schema ${o} must be string`);
      }
      return (
        (r = (0, Za.normalizeId)(r || i)),
        this._checkUnique(r),
        (this.schemas[r] = this._addSchema(t, n, r, s, !0)),
        this
      );
    }
    addMetaSchema(t, r, n = this.opts.validateSchema) {
      return this.addSchema(t, r, !0, n), this;
    }
    validateSchema(t, r) {
      if (typeof t == "boolean") return !0;
      let n;
      if (((n = t.$schema), n !== void 0 && typeof n != "string"))
        throw new Error("$schema must be a string");
      if (((n = n || this.opts.defaultMeta || this.defaultMeta()), !n))
        return this.logger.warn("meta-schema not available"), (this.errors = null), !0;
      let s = this.validate(n, t);
      if (!s && r) {
        let i = "schema is invalid: " + this.errorsText();
        if (this.opts.validateSchema === "log") this.logger.error(i);
        else throw new Error(i);
      }
      return s;
    }
    getSchema(t) {
      let r;
      for (; typeof (r = J$.call(this, t)) == "string"; ) t = r;
      if (r === void 0) {
        let { schemaId: n } = this.opts,
          s = new Xa.SchemaEnv({ schema: {}, schemaId: n });
        if (((r = Xa.resolveSchema.call(this, s, t)), !r)) return;
        this.refs[t] = r;
      }
      return r.validate || this._compileSchemaEnv(r);
    }
    removeSchema(t) {
      if (t instanceof RegExp)
        return this._removeAllSchemas(this.schemas, t), this._removeAllSchemas(this.refs, t), this;
      switch (typeof t) {
        case "undefined":
          return (
            this._removeAllSchemas(this.schemas),
            this._removeAllSchemas(this.refs),
            this._cache.clear(),
            this
          );
        case "string": {
          let r = J$.call(this, t);
          return (
            typeof r == "object" && this._cache.delete(r.schema),
            delete this.schemas[t],
            delete this.refs[t],
            this
          );
        }
        case "object": {
          let r = t;
          this._cache.delete(r);
          let n = t[this.opts.schemaId];
          return (
            n && ((n = (0, Za.normalizeId)(n)), delete this.schemas[n], delete this.refs[n]), this
          );
        }
        default:
          throw new Error("ajv.removeSchema: invalid parameter");
      }
    }
    addVocabulary(t) {
      for (let r of t) this.addKeyword(r);
      return this;
    }
    addKeyword(t, r) {
      let n;
      if (typeof t == "string")
        (n = t),
          typeof r == "object" &&
            (this.logger.warn("these parameters are deprecated, see docs for addKeyword"),
            (r.keyword = n));
      else if (typeof t == "object" && r === void 0) {
        if (((r = t), (n = r.keyword), Array.isArray(n) && !n.length))
          throw new Error("addKeywords: keyword must be string or non-empty array");
      } else throw new Error("invalid addKeywords parameters");
      if ((X6.call(this, n, r), !r)) return (0, gy.eachItem)(n, (i) => yy.call(this, i)), this;
      eK.call(this, r);
      let s = {
        ...r,
        type: (0, cf.getJSONTypes)(r.type),
        schemaType: (0, cf.getJSONTypes)(r.schemaType),
      };
      return (
        (0, gy.eachItem)(
          n,
          s.type.length === 0
            ? (i) => yy.call(this, i, s)
            : (i) => s.type.forEach((o) => yy.call(this, i, s, o)),
        ),
        this
      );
    }
    getKeyword(t) {
      let r = this.RULES.all[t];
      return typeof r == "object" ? r.definition : !!r;
    }
    removeKeyword(t) {
      let { RULES: r } = this;
      delete r.keywords[t], delete r.all[t];
      for (let n of r.rules) {
        let s = n.rules.findIndex((i) => i.keyword === t);
        s >= 0 && n.rules.splice(s, 1);
      }
      return this;
    }
    addFormat(t, r) {
      return typeof r == "string" && (r = new RegExp(r)), (this.formats[t] = r), this;
    }
    errorsText(t = this.errors, { separator: r = ", ", dataVar: n = "data" } = {}) {
      return !t || t.length === 0
        ? "No errors"
        : t.map((s) => `${n}${s.instancePath} ${s.message}`).reduce((s, i) => s + r + i);
    }
    $dataMetaSchema(t, r) {
      let n = this.RULES.all;
      t = JSON.parse(JSON.stringify(t));
      for (let s of r) {
        let i = s.split("/").slice(1),
          o = t;
        for (let a of i) o = o[a];
        for (let a in n) {
          let u = n[a];
          if (typeof u != "object") continue;
          let { $data: l } = u.definition,
            c = o[a];
          l && c && (o[a] = Y$(c));
        }
      }
      return t;
    }
    _removeAllSchemas(t, r) {
      for (let n in t) {
        let s = t[n];
        (!r || r.test(n)) &&
          (typeof s == "string"
            ? delete t[n]
            : s && !s.meta && (this._cache.delete(s.schema), delete t[n]));
      }
    }
    _addSchema(t, r, n, s = this.opts.validateSchema, i = this.opts.addUsedSchema) {
      let o,
        { schemaId: a } = this.opts;
      if (typeof t == "object") o = t[a];
      else {
        if (this.opts.jtd) throw new Error("schema must be object");
        if (typeof t != "boolean") throw new Error("schema must be object or boolean");
      }
      let u = this._cache.get(t);
      if (u !== void 0) return u;
      n = (0, Za.normalizeId)(o || n);
      let l = Za.getSchemaRefs.call(this, t, n);
      return (
        (u = new Xa.SchemaEnv({ schema: t, schemaId: a, meta: r, baseId: n, localRefs: l })),
        this._cache.set(u.schema, u),
        i && !n.startsWith("#") && (n && this._checkUnique(n), (this.refs[n] = u)),
        s && this.validateSchema(t, !0),
        u
      );
    }
    _checkUnique(t) {
      if (this.schemas[t] || this.refs[t])
        throw new Error(`schema with key or id "${t}" already exists`);
    }
    _compileSchemaEnv(t) {
      if ((t.meta ? this._compileMetaSchema(t) : Xa.compileSchema.call(this, t), !t.validate))
        throw new Error("ajv implementation error");
      return t.validate;
    }
    _compileMetaSchema(t) {
      let r = this.opts;
      this.opts = this._metaOpts;
      try {
        Xa.compileSchema.call(this, t);
      } finally {
        this.opts = r;
      }
    }
  };
  eu.ValidationError = j6.default;
  eu.MissingRefError = Q$.default;
  Qt.default = eu;
  function G$(e, t, r, n = "error") {
    for (let s in e) {
      let i = s;
      i in t && this.logger[n](`${r}: option ${s}. ${e[i]}`);
    }
  }
  function J$(e) {
    return (e = (0, Za.normalizeId)(e)), this.schemas[e] || this.refs[e];
  }
  function B6() {
    let e = this.opts.schemas;
    if (e)
      if (Array.isArray(e)) this.addSchema(e);
      else for (let t in e) this.addSchema(e[t], t);
  }
  function K6() {
    for (let e in this.opts.formats) {
      let t = this.opts.formats[e];
      t && this.addFormat(e, t);
    }
  }
  function G6(e) {
    if (Array.isArray(e)) {
      this.addVocabulary(e);
      return;
    }
    this.logger.warn("keywords option as map is deprecated, pass array");
    for (let t in e) {
      let r = e[t];
      r.keyword || (r.keyword = t), this.addKeyword(r);
    }
  }
  function J6() {
    let e = { ...this.opts };
    for (let t of M6) delete e[t];
    return e;
  }
  var Q6 = { log() {}, warn() {}, error() {} };
  function W6(e) {
    if (e === !1) return Q6;
    if (e === void 0) return console;
    if (e.log && e.warn && e.error) return e;
    throw new Error("logger must implement log, warn and error methods");
  }
  var Y6 = /^[a-z_$][a-z0-9_$:-]*$/i;
  function X6(e, t) {
    let { RULES: r } = this;
    if (
      ((0, gy.eachItem)(e, (n) => {
        if (r.keywords[n]) throw new Error(`Keyword ${n} is already defined`);
        if (!Y6.test(n)) throw new Error(`Keyword ${n} has invalid name`);
      }),
      !!t && t.$data && !("code" in t || "validate" in t))
    )
      throw new Error('$data keyword must have "code" or "validate" function');
  }
  function yy(e, t, r) {
    var n;
    let s = t?.post;
    if (r && s) throw new Error('keyword with "post" flag cannot have "type"');
    let { RULES: i } = this,
      o = s ? i.post : i.rules.find(({ type: u }) => u === r);
    if ((o || ((o = { type: r, rules: [] }), i.rules.push(o)), (i.keywords[e] = !0), !t)) return;
    let a = {
      keyword: e,
      definition: {
        ...t,
        type: (0, cf.getJSONTypes)(t.type),
        schemaType: (0, cf.getJSONTypes)(t.schemaType),
      },
    };
    t.before ? Z6.call(this, o, a, t.before) : o.rules.push(a),
      (i.all[e] = a),
      (n = t.implements) === null || n === void 0 || n.forEach((u) => this.addKeyword(u));
  }
  function Z6(e, t, r) {
    let n = e.rules.findIndex((s) => s.keyword === r);
    n >= 0
      ? e.rules.splice(n, 0, t)
      : (e.rules.push(t), this.logger.warn(`rule ${r} is not defined`));
  }
  function eK(e) {
    let { metaSchema: t } = e;
    t !== void 0 &&
      (e.$data && this.opts.$data && (t = Y$(t)), (e.validateSchema = this.compile(t, !0)));
  }
  var tK = {
    $ref: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#",
  };
  function Y$(e) {
    return { anyOf: [e, tK] };
  }
});
var X$ = b((Sy) => {
  "use strict";
  Object.defineProperty(Sy, "__esModule", { value: !0 });
  var rK = {
    keyword: "id",
    code() {
      throw new Error('NOT SUPPORTED: keyword "id", use "$id" for schema ID');
    },
  };
  Sy.default = rK;
});
var vy = b((Pi) => {
  "use strict";
  Object.defineProperty(Pi, "__esModule", { value: !0 });
  Pi.callRef = Pi.getValidate = void 0;
  var nK = ls(),
    Z$ = Jt(),
    Cr = he(),
    Eo = tn(),
    eO = Ti(),
    ff = Ie(),
    sK = {
      keyword: "$ref",
      schemaType: "string",
      code(e) {
        let { gen: t, schema: r, it: n } = e,
          { baseId: s, schemaEnv: i, validateName: o, opts: a, self: u } = n,
          { root: l } = i;
        if ((r === "#" || r === "#/") && s === l.baseId) return f();
        let c = eO.resolveRef.call(u, l, s, r);
        if (c === void 0) throw new nK.default(n.opts.uriResolver, s, r);
        if (c instanceof eO.SchemaEnv) return d(c);
        return h(c);
        function f() {
          if (i === l) return df(e, o, i, i.$async);
          let p = t.scopeValue("root", { ref: l });
          return df(e, (0, Cr._)`${p}.validate`, l, l.$async);
        }
        function d(p) {
          let y = tO(e, p);
          df(e, y, p, p.$async);
        }
        function h(p) {
          let y = t.scopeValue(
              "schema",
              a.code.source === !0 ? { ref: p, code: (0, Cr.stringify)(p) } : { ref: p },
            ),
            _ = t.name("valid"),
            S = e.subschema(
              { schema: p, dataTypes: [], schemaPath: Cr.nil, topSchemaRef: y, errSchemaPath: r },
              _,
            );
          e.mergeEvaluated(S), e.ok(_);
        }
      },
    };
  function tO(e, t) {
    let { gen: r } = e;
    return t.validate
      ? r.scopeValue("validate", { ref: t.validate })
      : (0, Cr._)`${r.scopeValue("wrapper", { ref: t })}.validate`;
  }
  Pi.getValidate = tO;
  function df(e, t, r, n) {
    let { gen: s, it: i } = e,
      { allErrors: o, schemaEnv: a, opts: u } = i,
      l = u.passContext ? Eo.default.this : Cr.nil;
    n ? c() : f();
    function c() {
      if (!a.$async) throw new Error("async schema referenced by sync schema");
      let p = s.let("valid");
      s.try(
        () => {
          s.code((0, Cr._)`await ${(0, Z$.callValidateCode)(e, t, l)}`), h(t), o || s.assign(p, !0);
        },
        (y) => {
          s.if((0, Cr._)`!(${y} instanceof ${i.ValidationError})`, () => s.throw(y)),
            d(y),
            o || s.assign(p, !1);
        },
      ),
        e.ok(p);
    }
    function f() {
      e.result(
        (0, Z$.callValidateCode)(e, t, l),
        () => h(t),
        () => d(t),
      );
    }
    function d(p) {
      let y = (0, Cr._)`${p}.errors`;
      s.assign(
        Eo.default.vErrors,
        (0, Cr._)`${Eo.default.vErrors} === null ? ${y} : ${Eo.default.vErrors}.concat(${y})`,
      ),
        s.assign(Eo.default.errors, (0, Cr._)`${Eo.default.vErrors}.length`);
    }
    function h(p) {
      var y;
      if (!i.opts.unevaluated) return;
      let _ = (y = r?.validate) === null || y === void 0 ? void 0 : y.evaluated;
      if (i.props !== !0)
        if (_ && !_.dynamicProps)
          _.props !== void 0 && (i.props = ff.mergeEvaluated.props(s, _.props, i.props));
        else {
          let S = s.var("props", (0, Cr._)`${p}.evaluated.props`);
          i.props = ff.mergeEvaluated.props(s, S, i.props, Cr.Name);
        }
      if (i.items !== !0)
        if (_ && !_.dynamicItems)
          _.items !== void 0 && (i.items = ff.mergeEvaluated.items(s, _.items, i.items));
        else {
          let S = s.var("items", (0, Cr._)`${p}.evaluated.items`);
          i.items = ff.mergeEvaluated.items(s, S, i.items, Cr.Name);
        }
    }
  }
  Pi.callRef = df;
  Pi.default = sK;
});
var rO = b((by) => {
  "use strict";
  Object.defineProperty(by, "__esModule", { value: !0 });
  var iK = X$(),
    oK = vy(),
    aK = [
      "$schema",
      "$id",
      "$defs",
      "$vocabulary",
      { keyword: "$comment" },
      "definitions",
      iK.default,
      oK.default,
    ];
  by.default = aK;
});
var nO = b((wy) => {
  "use strict";
  Object.defineProperty(wy, "__esModule", { value: !0 });
  var hf = he(),
    Vs = hf.operators,
    pf = {
      maximum: { okStr: "<=", ok: Vs.LTE, fail: Vs.GT },
      minimum: { okStr: ">=", ok: Vs.GTE, fail: Vs.LT },
      exclusiveMaximum: { okStr: "<", ok: Vs.LT, fail: Vs.GTE },
      exclusiveMinimum: { okStr: ">", ok: Vs.GT, fail: Vs.LTE },
    },
    uK = {
      message: ({ keyword: e, schemaCode: t }) => (0, hf.str)`must be ${pf[e].okStr} ${t}`,
      params: ({ keyword: e, schemaCode: t }) =>
        (0, hf._)`{comparison: ${pf[e].okStr}, limit: ${t}}`,
    },
    lK = {
      keyword: Object.keys(pf),
      type: "number",
      schemaType: "number",
      $data: !0,
      error: uK,
      code(e) {
        let { keyword: t, data: r, schemaCode: n } = e;
        e.fail$data((0, hf._)`${r} ${pf[t].fail} ${n} || isNaN(${r})`);
      },
    };
  wy.default = lK;
});
var sO = b((Ey) => {
  "use strict";
  Object.defineProperty(Ey, "__esModule", { value: !0 });
  var tu = he(),
    cK = {
      message: ({ schemaCode: e }) => (0, tu.str)`must be multiple of ${e}`,
      params: ({ schemaCode: e }) => (0, tu._)`{multipleOf: ${e}}`,
    },
    fK = {
      keyword: "multipleOf",
      type: "number",
      schemaType: "number",
      $data: !0,
      error: cK,
      code(e) {
        let { gen: t, data: r, schemaCode: n, it: s } = e,
          i = s.opts.multipleOfPrecision,
          o = t.let("res"),
          a = i
            ? (0, tu._)`Math.abs(Math.round(${o}) - ${o}) > 1e-${i}`
            : (0, tu._)`${o} !== parseInt(${o})`;
        e.fail$data((0, tu._)`(${n} === 0 || (${o} = ${r}/${n}, ${a}))`);
      },
    };
  Ey.default = fK;
});
var oO = b((Ry) => {
  "use strict";
  Object.defineProperty(Ry, "__esModule", { value: !0 });
  function iO(e) {
    let t = e.length,
      r = 0,
      n = 0,
      s;
    for (; n < t; )
      r++,
        (s = e.charCodeAt(n++)),
        s >= 55296 && s <= 56319 && n < t && ((s = e.charCodeAt(n)), (s & 64512) === 56320 && n++);
    return r;
  }
  Ry.default = iO;
  iO.code = 'require("ajv/dist/runtime/ucs2length").default';
});
var aO = b((Ty) => {
  "use strict";
  Object.defineProperty(Ty, "__esModule", { value: !0 });
  var $i = he(),
    dK = Ie(),
    hK = oO(),
    pK = {
      message({ keyword: e, schemaCode: t }) {
        let r = e === "maxLength" ? "more" : "fewer";
        return (0, $i.str)`must NOT have ${r} than ${t} characters`;
      },
      params: ({ schemaCode: e }) => (0, $i._)`{limit: ${e}}`,
    },
    mK = {
      keyword: ["maxLength", "minLength"],
      type: "string",
      schemaType: "number",
      $data: !0,
      error: pK,
      code(e) {
        let { keyword: t, data: r, schemaCode: n, it: s } = e,
          i = t === "maxLength" ? $i.operators.GT : $i.operators.LT,
          o =
            s.opts.unicode === !1
              ? (0, $i._)`${r}.length`
              : (0, $i._)`${(0, dK.useFunc)(e.gen, hK.default)}(${r})`;
        e.fail$data((0, $i._)`${o} ${i} ${n}`);
      },
    };
  Ty.default = mK;
});
var uO = b((Py) => {
  "use strict";
  Object.defineProperty(Py, "__esModule", { value: !0 });
  var yK = Jt(),
    mf = he(),
    gK = {
      message: ({ schemaCode: e }) => (0, mf.str)`must match pattern "${e}"`,
      params: ({ schemaCode: e }) => (0, mf._)`{pattern: ${e}}`,
    },
    _K = {
      keyword: "pattern",
      type: "string",
      schemaType: "string",
      $data: !0,
      error: gK,
      code(e) {
        let { data: t, $data: r, schema: n, schemaCode: s, it: i } = e,
          o = i.opts.unicodeRegExp ? "u" : "",
          a = r ? (0, mf._)`(new RegExp(${s}, ${o}))` : (0, yK.usePattern)(e, n);
        e.fail$data((0, mf._)`!${a}.test(${t})`);
      },
    };
  Py.default = _K;
});
var lO = b(($y) => {
  "use strict";
  Object.defineProperty($y, "__esModule", { value: !0 });
  var ru = he(),
    SK = {
      message({ keyword: e, schemaCode: t }) {
        let r = e === "maxProperties" ? "more" : "fewer";
        return (0, ru.str)`must NOT have ${r} than ${t} properties`;
      },
      params: ({ schemaCode: e }) => (0, ru._)`{limit: ${e}}`,
    },
    vK = {
      keyword: ["maxProperties", "minProperties"],
      type: "object",
      schemaType: "number",
      $data: !0,
      error: SK,
      code(e) {
        let { keyword: t, data: r, schemaCode: n } = e,
          s = t === "maxProperties" ? ru.operators.GT : ru.operators.LT;
        e.fail$data((0, ru._)`Object.keys(${r}).length ${s} ${n}`);
      },
    };
  $y.default = vK;
});
var cO = b((Oy) => {
  "use strict";
  Object.defineProperty(Oy, "__esModule", { value: !0 });
  var nu = Jt(),
    su = he(),
    bK = Ie(),
    wK = {
      message: ({ params: { missingProperty: e } }) =>
        (0, su.str)`must have required property '${e}'`,
      params: ({ params: { missingProperty: e } }) => (0, su._)`{missingProperty: ${e}}`,
    },
    EK = {
      keyword: "required",
      type: "object",
      schemaType: "array",
      $data: !0,
      error: wK,
      code(e) {
        let { gen: t, schema: r, schemaCode: n, data: s, $data: i, it: o } = e,
          { opts: a } = o;
        if (!i && r.length === 0) return;
        let u = r.length >= a.loopRequired;
        if ((o.allErrors ? l() : c(), a.strictRequired)) {
          let h = e.parentSchema.properties,
            { definedProperties: p } = e.it;
          for (let y of r)
            if (h?.[y] === void 0 && !p.has(y)) {
              let _ = o.schemaEnv.baseId + o.errSchemaPath,
                S = `required property "${y}" is not defined at "${_}" (strictRequired)`;
              (0, bK.checkStrictMode)(o, S, o.opts.strictRequired);
            }
        }
        function l() {
          if (u || i) e.block$data(su.nil, f);
          else for (let h of r) (0, nu.checkReportMissingProp)(e, h);
        }
        function c() {
          let h = t.let("missing");
          if (u || i) {
            let p = t.let("valid", !0);
            e.block$data(p, () => d(h, p)), e.ok(p);
          } else t.if((0, nu.checkMissingProp)(e, r, h)), (0, nu.reportMissingProp)(e, h), t.else();
        }
        function f() {
          t.forOf("prop", n, (h) => {
            e.setParams({ missingProperty: h }),
              t.if((0, nu.noPropertyInData)(t, s, h, a.ownProperties), () => e.error());
          });
        }
        function d(h, p) {
          e.setParams({ missingProperty: h }),
            t.forOf(
              h,
              n,
              () => {
                t.assign(p, (0, nu.propertyInData)(t, s, h, a.ownProperties)),
                  t.if((0, su.not)(p), () => {
                    e.error(), t.break();
                  });
              },
              su.nil,
            );
        }
      },
    };
  Oy.default = EK;
});
var fO = b((Ny) => {
  "use strict";
  Object.defineProperty(Ny, "__esModule", { value: !0 });
  var iu = he(),
    RK = {
      message({ keyword: e, schemaCode: t }) {
        let r = e === "maxItems" ? "more" : "fewer";
        return (0, iu.str)`must NOT have ${r} than ${t} items`;
      },
      params: ({ schemaCode: e }) => (0, iu._)`{limit: ${e}}`,
    },
    TK = {
      keyword: ["maxItems", "minItems"],
      type: "array",
      schemaType: "number",
      $data: !0,
      error: RK,
      code(e) {
        let { keyword: t, data: r, schemaCode: n } = e,
          s = t === "maxItems" ? iu.operators.GT : iu.operators.LT;
        e.fail$data((0, iu._)`${r}.length ${s} ${n}`);
      },
    };
  Ny.default = TK;
});
var ou = b((Ay) => {
  "use strict";
  Object.defineProperty(Ay, "__esModule", { value: !0 });
  var dO = qs();
  dO.code = 'require("ajv/dist/runtime/equal").default';
  Ay.default = dO;
});
var hO = b((Cy) => {
  "use strict";
  Object.defineProperty(Cy, "__esModule", { value: !0 });
  var Iy = Ga(),
    Wt = he(),
    PK = Ie(),
    $K = ou(),
    OK = {
      message: ({ params: { i: e, j: t } }) =>
        (0, Wt.str)`must NOT have duplicate items (items ## ${t} and ${e} are identical)`,
      params: ({ params: { i: e, j: t } }) => (0, Wt._)`{i: ${e}, j: ${t}}`,
    },
    NK = {
      keyword: "uniqueItems",
      type: "array",
      schemaType: "boolean",
      $data: !0,
      error: OK,
      code(e) {
        let { gen: t, data: r, $data: n, schema: s, parentSchema: i, schemaCode: o, it: a } = e;
        if (!n && !s) return;
        let u = t.let("valid"),
          l = i.items ? (0, Iy.getSchemaTypes)(i.items) : [];
        e.block$data(u, c, (0, Wt._)`${o} === false`), e.ok(u);
        function c() {
          let p = t.let("i", (0, Wt._)`${r}.length`),
            y = t.let("j");
          e.setParams({ i: p, j: y }),
            t.assign(u, !0),
            t.if((0, Wt._)`${p} > 1`, () => (f() ? d : h)(p, y));
        }
        function f() {
          return l.length > 0 && !l.some((p) => p === "object" || p === "array");
        }
        function d(p, y) {
          let _ = t.name("item"),
            S = (0, Iy.checkDataTypes)(l, _, a.opts.strictNumbers, Iy.DataType.Wrong),
            E = t.const("indices", (0, Wt._)`{}`);
          t.for((0, Wt._)`;${p}--;`, () => {
            t.let(_, (0, Wt._)`${r}[${p}]`),
              t.if(S, (0, Wt._)`continue`),
              l.length > 1 && t.if((0, Wt._)`typeof ${_} == "string"`, (0, Wt._)`${_} += "_"`),
              t
                .if((0, Wt._)`typeof ${E}[${_}] == "number"`, () => {
                  t.assign(y, (0, Wt._)`${E}[${_}]`), e.error(), t.assign(u, !1).break();
                })
                .code((0, Wt._)`${E}[${_}] = ${p}`);
          });
        }
        function h(p, y) {
          let _ = (0, PK.useFunc)(t, $K.default),
            S = t.name("outer");
          t.label(S).for((0, Wt._)`;${p}--;`, () =>
            t.for((0, Wt._)`${y} = ${p}; ${y}--;`, () =>
              t.if((0, Wt._)`${_}(${r}[${p}], ${r}[${y}])`, () => {
                e.error(), t.assign(u, !1).break(S);
              }),
            ),
          );
        }
      },
    };
  Cy.default = NK;
});
var pO = b((Dy) => {
  "use strict";
  Object.defineProperty(Dy, "__esModule", { value: !0 });
  var ky = he(),
    AK = Ie(),
    IK = ou(),
    CK = {
      message: "must be equal to constant",
      params: ({ schemaCode: e }) => (0, ky._)`{allowedValue: ${e}}`,
    },
    kK = {
      keyword: "const",
      $data: !0,
      error: CK,
      code(e) {
        let { gen: t, data: r, $data: n, schemaCode: s, schema: i } = e;
        n || (i && typeof i == "object")
          ? e.fail$data((0, ky._)`!${(0, AK.useFunc)(t, IK.default)}(${r}, ${s})`)
          : e.fail((0, ky._)`${i} !== ${r}`);
      },
    };
  Dy.default = kK;
});
var mO = b((qy) => {
  "use strict";
  Object.defineProperty(qy, "__esModule", { value: !0 });
  var au = he(),
    DK = Ie(),
    qK = ou(),
    jK = {
      message: "must be equal to one of the allowed values",
      params: ({ schemaCode: e }) => (0, au._)`{allowedValues: ${e}}`,
    },
    LK = {
      keyword: "enum",
      schemaType: "array",
      $data: !0,
      error: jK,
      code(e) {
        let { gen: t, data: r, $data: n, schema: s, schemaCode: i, it: o } = e;
        if (!n && s.length === 0) throw new Error("enum must have non-empty array");
        let a = s.length >= o.opts.loopEnum,
          u,
          l = () => u ?? (u = (0, DK.useFunc)(t, qK.default)),
          c;
        if (a || n) (c = t.let("valid")), e.block$data(c, f);
        else {
          if (!Array.isArray(s)) throw new Error("ajv implementation error");
          let h = t.const("vSchema", i);
          c = (0, au.or)(...s.map((p, y) => d(h, y)));
        }
        e.pass(c);
        function f() {
          t.assign(c, !1),
            t.forOf("v", i, (h) =>
              t.if((0, au._)`${l()}(${r}, ${h})`, () => t.assign(c, !0).break()),
            );
        }
        function d(h, p) {
          let y = s[p];
          return typeof y == "object" && y !== null
            ? (0, au._)`${l()}(${r}, ${h}[${p}])`
            : (0, au._)`${r} === ${y}`;
        }
      },
    };
  qy.default = LK;
});
var yO = b((jy) => {
  "use strict";
  Object.defineProperty(jy, "__esModule", { value: !0 });
  var xK = nO(),
    FK = sO(),
    MK = aO(),
    zK = uO(),
    VK = lO(),
    UK = cO(),
    HK = fO(),
    BK = hO(),
    KK = pO(),
    GK = mO(),
    JK = [
      xK.default,
      FK.default,
      MK.default,
      zK.default,
      VK.default,
      UK.default,
      HK.default,
      BK.default,
      { keyword: "type", schemaType: ["string", "array"] },
      { keyword: "nullable", schemaType: "boolean" },
      KK.default,
      GK.default,
    ];
  jy.default = JK;
});
var xy = b((uu) => {
  "use strict";
  Object.defineProperty(uu, "__esModule", { value: !0 });
  uu.validateAdditionalItems = void 0;
  var Oi = he(),
    Ly = Ie(),
    QK = {
      message: ({ params: { len: e } }) => (0, Oi.str)`must NOT have more than ${e} items`,
      params: ({ params: { len: e } }) => (0, Oi._)`{limit: ${e}}`,
    },
    WK = {
      keyword: "additionalItems",
      type: "array",
      schemaType: ["boolean", "object"],
      before: "uniqueItems",
      error: QK,
      code(e) {
        let { parentSchema: t, it: r } = e,
          { items: n } = t;
        if (!Array.isArray(n)) {
          (0, Ly.checkStrictMode)(
            r,
            '"additionalItems" is ignored when "items" is not an array of schemas',
          );
          return;
        }
        gO(e, n);
      },
    };
  function gO(e, t) {
    let { gen: r, schema: n, data: s, keyword: i, it: o } = e;
    o.items = !0;
    let a = r.const("len", (0, Oi._)`${s}.length`);
    if (n === !1) e.setParams({ len: t.length }), e.pass((0, Oi._)`${a} <= ${t.length}`);
    else if (typeof n == "object" && !(0, Ly.alwaysValidSchema)(o, n)) {
      let l = r.var("valid", (0, Oi._)`${a} <= ${t.length}`);
      r.if((0, Oi.not)(l), () => u(l)), e.ok(l);
    }
    function u(l) {
      r.forRange("i", t.length, a, (c) => {
        e.subschema({ keyword: i, dataProp: c, dataPropType: Ly.Type.Num }, l),
          o.allErrors || r.if((0, Oi.not)(l), () => r.break());
      });
    }
  }
  uu.validateAdditionalItems = gO;
  uu.default = WK;
});
var Fy = b((lu) => {
  "use strict";
  Object.defineProperty(lu, "__esModule", { value: !0 });
  lu.validateTuple = void 0;
  var _O = he(),
    yf = Ie(),
    YK = Jt(),
    XK = {
      keyword: "items",
      type: "array",
      schemaType: ["object", "array", "boolean"],
      before: "uniqueItems",
      code(e) {
        let { schema: t, it: r } = e;
        if (Array.isArray(t)) return SO(e, "additionalItems", t);
        (r.items = !0), !(0, yf.alwaysValidSchema)(r, t) && e.ok((0, YK.validateArray)(e));
      },
    };
  function SO(e, t, r = e.schema) {
    let { gen: n, parentSchema: s, data: i, keyword: o, it: a } = e;
    c(s),
      a.opts.unevaluated &&
        r.length &&
        a.items !== !0 &&
        (a.items = yf.mergeEvaluated.items(n, r.length, a.items));
    let u = n.name("valid"),
      l = n.const("len", (0, _O._)`${i}.length`);
    r.forEach((f, d) => {
      (0, yf.alwaysValidSchema)(a, f) ||
        (n.if((0, _O._)`${l} > ${d}`, () =>
          e.subschema({ keyword: o, schemaProp: d, dataProp: d }, u),
        ),
        e.ok(u));
    });
    function c(f) {
      let { opts: d, errSchemaPath: h } = a,
        p = r.length,
        y = p === f.minItems && (p === f.maxItems || f[t] === !1);
      if (d.strictTuples && !y) {
        let _ = `"${o}" is ${p}-tuple, but minItems or maxItems/${t} are not specified or different at path "${h}"`;
        (0, yf.checkStrictMode)(a, _, d.strictTuples);
      }
    }
  }
  lu.validateTuple = SO;
  lu.default = XK;
});
var vO = b((My) => {
  "use strict";
  Object.defineProperty(My, "__esModule", { value: !0 });
  var ZK = Fy(),
    e8 = {
      keyword: "prefixItems",
      type: "array",
      schemaType: ["array"],
      before: "uniqueItems",
      code: (e) => (0, ZK.validateTuple)(e, "items"),
    };
  My.default = e8;
});
var wO = b((zy) => {
  "use strict";
  Object.defineProperty(zy, "__esModule", { value: !0 });
  var bO = he(),
    t8 = Ie(),
    r8 = Jt(),
    n8 = xy(),
    s8 = {
      message: ({ params: { len: e } }) => (0, bO.str)`must NOT have more than ${e} items`,
      params: ({ params: { len: e } }) => (0, bO._)`{limit: ${e}}`,
    },
    i8 = {
      keyword: "items",
      type: "array",
      schemaType: ["object", "boolean"],
      before: "uniqueItems",
      error: s8,
      code(e) {
        let { schema: t, parentSchema: r, it: n } = e,
          { prefixItems: s } = r;
        (n.items = !0),
          !(0, t8.alwaysValidSchema)(n, t) &&
            (s ? (0, n8.validateAdditionalItems)(e, s) : e.ok((0, r8.validateArray)(e)));
      },
    };
  zy.default = i8;
});
var EO = b((Vy) => {
  "use strict";
  Object.defineProperty(Vy, "__esModule", { value: !0 });
  var nn = he(),
    gf = Ie(),
    o8 = {
      message: ({ params: { min: e, max: t } }) =>
        t === void 0
          ? (0, nn.str)`must contain at least ${e} valid item(s)`
          : (0, nn.str)`must contain at least ${e} and no more than ${t} valid item(s)`,
      params: ({ params: { min: e, max: t } }) =>
        t === void 0
          ? (0, nn._)`{minContains: ${e}}`
          : (0, nn._)`{minContains: ${e}, maxContains: ${t}}`,
    },
    a8 = {
      keyword: "contains",
      type: "array",
      schemaType: ["object", "boolean"],
      before: "uniqueItems",
      trackErrors: !0,
      error: o8,
      code(e) {
        let { gen: t, schema: r, parentSchema: n, data: s, it: i } = e,
          o,
          a,
          { minContains: u, maxContains: l } = n;
        i.opts.next ? ((o = u === void 0 ? 1 : u), (a = l)) : (o = 1);
        let c = t.const("len", (0, nn._)`${s}.length`);
        if ((e.setParams({ min: o, max: a }), a === void 0 && o === 0)) {
          (0, gf.checkStrictMode)(
            i,
            '"minContains" == 0 without "maxContains": "contains" keyword ignored',
          );
          return;
        }
        if (a !== void 0 && o > a) {
          (0, gf.checkStrictMode)(i, '"minContains" > "maxContains" is always invalid'), e.fail();
          return;
        }
        if ((0, gf.alwaysValidSchema)(i, r)) {
          let y = (0, nn._)`${c} >= ${o}`;
          a !== void 0 && (y = (0, nn._)`${y} && ${c} <= ${a}`), e.pass(y);
          return;
        }
        i.items = !0;
        let f = t.name("valid");
        a === void 0 && o === 1
          ? h(f, () => t.if(f, () => t.break()))
          : o === 0
            ? (t.let(f, !0), a !== void 0 && t.if((0, nn._)`${s}.length > 0`, d))
            : (t.let(f, !1), d()),
          e.result(f, () => e.reset());
        function d() {
          let y = t.name("_valid"),
            _ = t.let("count", 0);
          h(y, () => t.if(y, () => p(_)));
        }
        function h(y, _) {
          t.forRange("i", 0, c, (S) => {
            e.subschema(
              { keyword: "contains", dataProp: S, dataPropType: gf.Type.Num, compositeRule: !0 },
              y,
            ),
              _();
          });
        }
        function p(y) {
          t.code((0, nn._)`${y}++`),
            a === void 0
              ? t.if((0, nn._)`${y} >= ${o}`, () => t.assign(f, !0).break())
              : (t.if((0, nn._)`${y} > ${a}`, () => t.assign(f, !1).break()),
                o === 1 ? t.assign(f, !0) : t.if((0, nn._)`${y} >= ${o}`, () => t.assign(f, !0)));
        }
      },
    };
  Vy.default = a8;
});
var PO = b((jn) => {
  "use strict";
  Object.defineProperty(jn, "__esModule", { value: !0 });
  jn.validateSchemaDeps = jn.validatePropertyDeps = jn.error = void 0;
  var Uy = he(),
    u8 = Ie(),
    cu = Jt();
  jn.error = {
    message: ({ params: { property: e, depsCount: t, deps: r } }) => {
      let n = t === 1 ? "property" : "properties";
      return (0, Uy.str)`must have ${n} ${r} when property ${e} is present`;
    },
    params: ({ params: { property: e, depsCount: t, deps: r, missingProperty: n } }) => (0,
    Uy._)`{property: ${e},
    missingProperty: ${n},
    depsCount: ${t},
    deps: ${r}}`,
  };
  var l8 = {
    keyword: "dependencies",
    type: "object",
    schemaType: "object",
    error: jn.error,
    code(e) {
      let [t, r] = c8(e);
      RO(e, t), TO(e, r);
    },
  };
  function c8({ schema: e }) {
    let t = {},
      r = {};
    for (let n in e) {
      if (n === "__proto__") continue;
      let s = Array.isArray(e[n]) ? t : r;
      s[n] = e[n];
    }
    return [t, r];
  }
  function RO(e, t = e.schema) {
    let { gen: r, data: n, it: s } = e;
    if (Object.keys(t).length === 0) return;
    let i = r.let("missing");
    for (let o in t) {
      let a = t[o];
      if (a.length === 0) continue;
      let u = (0, cu.propertyInData)(r, n, o, s.opts.ownProperties);
      e.setParams({ property: o, depsCount: a.length, deps: a.join(", ") }),
        s.allErrors
          ? r.if(u, () => {
              for (let l of a) (0, cu.checkReportMissingProp)(e, l);
            })
          : (r.if((0, Uy._)`${u} && (${(0, cu.checkMissingProp)(e, a, i)})`),
            (0, cu.reportMissingProp)(e, i),
            r.else());
    }
  }
  jn.validatePropertyDeps = RO;
  function TO(e, t = e.schema) {
    let { gen: r, data: n, keyword: s, it: i } = e,
      o = r.name("valid");
    for (let a in t)
      (0, u8.alwaysValidSchema)(i, t[a]) ||
        (r.if(
          (0, cu.propertyInData)(r, n, a, i.opts.ownProperties),
          () => {
            let u = e.subschema({ keyword: s, schemaProp: a }, o);
            e.mergeValidEvaluated(u, o);
          },
          () => r.var(o, !0),
        ),
        e.ok(o));
  }
  jn.validateSchemaDeps = TO;
  jn.default = l8;
});
var OO = b((Hy) => {
  "use strict";
  Object.defineProperty(Hy, "__esModule", { value: !0 });
  var $O = he(),
    f8 = Ie(),
    d8 = {
      message: "property name must be valid",
      params: ({ params: e }) => (0, $O._)`{propertyName: ${e.propertyName}}`,
    },
    h8 = {
      keyword: "propertyNames",
      type: "object",
      schemaType: ["object", "boolean"],
      error: d8,
      code(e) {
        let { gen: t, schema: r, data: n, it: s } = e;
        if ((0, f8.alwaysValidSchema)(s, r)) return;
        let i = t.name("valid");
        t.forIn("key", n, (o) => {
          e.setParams({ propertyName: o }),
            e.subschema(
              {
                keyword: "propertyNames",
                data: o,
                dataTypes: ["string"],
                propertyName: o,
                compositeRule: !0,
              },
              i,
            ),
            t.if((0, $O.not)(i), () => {
              e.error(!0), s.allErrors || t.break();
            });
        }),
          e.ok(i);
      },
    };
  Hy.default = h8;
});
var Ky = b((By) => {
  "use strict";
  Object.defineProperty(By, "__esModule", { value: !0 });
  var _f = Jt(),
    Sn = he(),
    p8 = tn(),
    Sf = Ie(),
    m8 = {
      message: "must NOT have additional properties",
      params: ({ params: e }) => (0, Sn._)`{additionalProperty: ${e.additionalProperty}}`,
    },
    y8 = {
      keyword: "additionalProperties",
      type: ["object"],
      schemaType: ["boolean", "object"],
      allowUndefined: !0,
      trackErrors: !0,
      error: m8,
      code(e) {
        let { gen: t, schema: r, parentSchema: n, data: s, errsCount: i, it: o } = e;
        if (!i) throw new Error("ajv implementation error");
        let { allErrors: a, opts: u } = o;
        if (((o.props = !0), u.removeAdditional !== "all" && (0, Sf.alwaysValidSchema)(o, r)))
          return;
        let l = (0, _f.allSchemaProperties)(n.properties),
          c = (0, _f.allSchemaProperties)(n.patternProperties);
        f(), e.ok((0, Sn._)`${i} === ${p8.default.errors}`);
        function f() {
          t.forIn("key", s, (_) => {
            !l.length && !c.length ? p(_) : t.if(d(_), () => p(_));
          });
        }
        function d(_) {
          let S;
          if (l.length > 8) {
            let E = (0, Sf.schemaRefOrVal)(o, n.properties, "properties");
            S = (0, _f.isOwnProperty)(t, E, _);
          } else
            l.length ? (S = (0, Sn.or)(...l.map((E) => (0, Sn._)`${_} === ${E}`))) : (S = Sn.nil);
          return (
            c.length &&
              (S = (0, Sn.or)(
                S,
                ...c.map((E) => (0, Sn._)`${(0, _f.usePattern)(e, E)}.test(${_})`),
              )),
            (0, Sn.not)(S)
          );
        }
        function h(_) {
          t.code((0, Sn._)`delete ${s}[${_}]`);
        }
        function p(_) {
          if (u.removeAdditional === "all" || (u.removeAdditional && r === !1)) {
            h(_);
            return;
          }
          if (r === !1) {
            e.setParams({ additionalProperty: _ }), e.error(), a || t.break();
            return;
          }
          if (typeof r == "object" && !(0, Sf.alwaysValidSchema)(o, r)) {
            let S = t.name("valid");
            u.removeAdditional === "failing"
              ? (y(_, S, !1),
                t.if((0, Sn.not)(S), () => {
                  e.reset(), h(_);
                }))
              : (y(_, S), a || t.if((0, Sn.not)(S), () => t.break()));
          }
        }
        function y(_, S, E) {
          let g = { keyword: "additionalProperties", dataProp: _, dataPropType: Sf.Type.Str };
          E === !1 && Object.assign(g, { compositeRule: !0, createErrors: !1, allErrors: !1 }),
            e.subschema(g, S);
        }
      },
    };
  By.default = y8;
});
var IO = b((Jy) => {
  "use strict";
  Object.defineProperty(Jy, "__esModule", { value: !0 });
  var g8 = vo(),
    NO = Jt(),
    Gy = Ie(),
    AO = Ky(),
    _8 = {
      keyword: "properties",
      type: "object",
      schemaType: "object",
      code(e) {
        let { gen: t, schema: r, parentSchema: n, data: s, it: i } = e;
        i.opts.removeAdditional === "all" &&
          n.additionalProperties === void 0 &&
          AO.default.code(new g8.KeywordCxt(i, AO.default, "additionalProperties"));
        let o = (0, NO.allSchemaProperties)(r);
        for (let f of o) i.definedProperties.add(f);
        i.opts.unevaluated &&
          o.length &&
          i.props !== !0 &&
          (i.props = Gy.mergeEvaluated.props(t, (0, Gy.toHash)(o), i.props));
        let a = o.filter((f) => !(0, Gy.alwaysValidSchema)(i, r[f]));
        if (a.length === 0) return;
        let u = t.name("valid");
        for (let f of a)
          l(f)
            ? c(f)
            : (t.if((0, NO.propertyInData)(t, s, f, i.opts.ownProperties)),
              c(f),
              i.allErrors || t.else().var(u, !0),
              t.endIf()),
            e.it.definedProperties.add(f),
            e.ok(u);
        function l(f) {
          return i.opts.useDefaults && !i.compositeRule && r[f].default !== void 0;
        }
        function c(f) {
          e.subschema({ keyword: "properties", schemaProp: f, dataProp: f }, u);
        }
      },
    };
  Jy.default = _8;
});
var qO = b((Qy) => {
  "use strict";
  Object.defineProperty(Qy, "__esModule", { value: !0 });
  var CO = Jt(),
    vf = he(),
    kO = Ie(),
    DO = Ie(),
    S8 = {
      keyword: "patternProperties",
      type: "object",
      schemaType: "object",
      code(e) {
        let { gen: t, schema: r, data: n, parentSchema: s, it: i } = e,
          { opts: o } = i,
          a = (0, CO.allSchemaProperties)(r),
          u = a.filter((y) => (0, kO.alwaysValidSchema)(i, r[y]));
        if (a.length === 0 || (u.length === a.length && (!i.opts.unevaluated || i.props === !0)))
          return;
        let l = o.strictSchema && !o.allowMatchingProperties && s.properties,
          c = t.name("valid");
        i.props !== !0 &&
          !(i.props instanceof vf.Name) &&
          (i.props = (0, DO.evaluatedPropsToName)(t, i.props));
        let { props: f } = i;
        d();
        function d() {
          for (let y of a) l && h(y), i.allErrors ? p(y) : (t.var(c, !0), p(y), t.if(c));
        }
        function h(y) {
          for (let _ in l)
            new RegExp(y).test(_) &&
              (0, kO.checkStrictMode)(
                i,
                `property ${_} matches pattern ${y} (use allowMatchingProperties)`,
              );
        }
        function p(y) {
          t.forIn("key", n, (_) => {
            t.if((0, vf._)`${(0, CO.usePattern)(e, y)}.test(${_})`, () => {
              let S = u.includes(y);
              S ||
                e.subschema(
                  {
                    keyword: "patternProperties",
                    schemaProp: y,
                    dataProp: _,
                    dataPropType: DO.Type.Str,
                  },
                  c,
                ),
                i.opts.unevaluated && f !== !0
                  ? t.assign((0, vf._)`${f}[${_}]`, !0)
                  : !S && !i.allErrors && t.if((0, vf.not)(c), () => t.break());
            });
          });
        }
      },
    };
  Qy.default = S8;
});
var jO = b((Wy) => {
  "use strict";
  Object.defineProperty(Wy, "__esModule", { value: !0 });
  var v8 = Ie(),
    b8 = {
      keyword: "not",
      schemaType: ["object", "boolean"],
      trackErrors: !0,
      code(e) {
        let { gen: t, schema: r, it: n } = e;
        if ((0, v8.alwaysValidSchema)(n, r)) {
          e.fail();
          return;
        }
        let s = t.name("valid");
        e.subschema({ keyword: "not", compositeRule: !0, createErrors: !1, allErrors: !1 }, s),
          e.failResult(
            s,
            () => e.reset(),
            () => e.error(),
          );
      },
      error: { message: "must NOT be valid" },
    };
  Wy.default = b8;
});
var LO = b((Yy) => {
  "use strict";
  Object.defineProperty(Yy, "__esModule", { value: !0 });
  var w8 = Jt(),
    E8 = {
      keyword: "anyOf",
      schemaType: "array",
      trackErrors: !0,
      code: w8.validateUnion,
      error: { message: "must match a schema in anyOf" },
    };
  Yy.default = E8;
});
var xO = b((Xy) => {
  "use strict";
  Object.defineProperty(Xy, "__esModule", { value: !0 });
  var bf = he(),
    R8 = Ie(),
    T8 = {
      message: "must match exactly one schema in oneOf",
      params: ({ params: e }) => (0, bf._)`{passingSchemas: ${e.passing}}`,
    },
    P8 = {
      keyword: "oneOf",
      schemaType: "array",
      trackErrors: !0,
      error: T8,
      code(e) {
        let { gen: t, schema: r, parentSchema: n, it: s } = e;
        if (!Array.isArray(r)) throw new Error("ajv implementation error");
        if (s.opts.discriminator && n.discriminator) return;
        let i = r,
          o = t.let("valid", !1),
          a = t.let("passing", null),
          u = t.name("_valid");
        e.setParams({ passing: a }),
          t.block(l),
          e.result(
            o,
            () => e.reset(),
            () => e.error(!0),
          );
        function l() {
          i.forEach((c, f) => {
            let d;
            (0, R8.alwaysValidSchema)(s, c)
              ? t.var(u, !0)
              : (d = e.subschema({ keyword: "oneOf", schemaProp: f, compositeRule: !0 }, u)),
              f > 0 &&
                t
                  .if((0, bf._)`${u} && ${o}`)
                  .assign(o, !1)
                  .assign(a, (0, bf._)`[${a}, ${f}]`)
                  .else(),
              t.if(u, () => {
                t.assign(o, !0), t.assign(a, f), d && e.mergeEvaluated(d, bf.Name);
              });
          });
        }
      },
    };
  Xy.default = P8;
});
var FO = b((Zy) => {
  "use strict";
  Object.defineProperty(Zy, "__esModule", { value: !0 });
  var $8 = Ie(),
    O8 = {
      keyword: "allOf",
      schemaType: "array",
      code(e) {
        let { gen: t, schema: r, it: n } = e;
        if (!Array.isArray(r)) throw new Error("ajv implementation error");
        let s = t.name("valid");
        r.forEach((i, o) => {
          if ((0, $8.alwaysValidSchema)(n, i)) return;
          let a = e.subschema({ keyword: "allOf", schemaProp: o }, s);
          e.ok(s), e.mergeEvaluated(a);
        });
      },
    };
  Zy.default = O8;
});
var VO = b((eg) => {
  "use strict";
  Object.defineProperty(eg, "__esModule", { value: !0 });
  var wf = he(),
    zO = Ie(),
    N8 = {
      message: ({ params: e }) => (0, wf.str)`must match "${e.ifClause}" schema`,
      params: ({ params: e }) => (0, wf._)`{failingKeyword: ${e.ifClause}}`,
    },
    A8 = {
      keyword: "if",
      schemaType: ["object", "boolean"],
      trackErrors: !0,
      error: N8,
      code(e) {
        let { gen: t, parentSchema: r, it: n } = e;
        r.then === void 0 &&
          r.else === void 0 &&
          (0, zO.checkStrictMode)(n, '"if" without "then" and "else" is ignored');
        let s = MO(n, "then"),
          i = MO(n, "else");
        if (!s && !i) return;
        let o = t.let("valid", !0),
          a = t.name("_valid");
        if ((u(), e.reset(), s && i)) {
          let c = t.let("ifClause");
          e.setParams({ ifClause: c }), t.if(a, l("then", c), l("else", c));
        } else s ? t.if(a, l("then")) : t.if((0, wf.not)(a), l("else"));
        e.pass(o, () => e.error(!0));
        function u() {
          let c = e.subschema(
            { keyword: "if", compositeRule: !0, createErrors: !1, allErrors: !1 },
            a,
          );
          e.mergeEvaluated(c);
        }
        function l(c, f) {
          return () => {
            let d = e.subschema({ keyword: c }, a);
            t.assign(o, a),
              e.mergeValidEvaluated(d, o),
              f ? t.assign(f, (0, wf._)`${c}`) : e.setParams({ ifClause: c });
          };
        }
      },
    };
  function MO(e, t) {
    let r = e.schema[t];
    return r !== void 0 && !(0, zO.alwaysValidSchema)(e, r);
  }
  eg.default = A8;
});
var UO = b((tg) => {
  "use strict";
  Object.defineProperty(tg, "__esModule", { value: !0 });
  var I8 = Ie(),
    C8 = {
      keyword: ["then", "else"],
      schemaType: ["object", "boolean"],
      code({ keyword: e, parentSchema: t, it: r }) {
        t.if === void 0 && (0, I8.checkStrictMode)(r, `"${e}" without "if" is ignored`);
      },
    };
  tg.default = C8;
});
var HO = b((rg) => {
  "use strict";
  Object.defineProperty(rg, "__esModule", { value: !0 });
  var k8 = xy(),
    D8 = vO(),
    q8 = Fy(),
    j8 = wO(),
    L8 = EO(),
    x8 = PO(),
    F8 = OO(),
    M8 = Ky(),
    z8 = IO(),
    V8 = qO(),
    U8 = jO(),
    H8 = LO(),
    B8 = xO(),
    K8 = FO(),
    G8 = VO(),
    J8 = UO();
  function Q8(e = !1) {
    let t = [
      U8.default,
      H8.default,
      B8.default,
      K8.default,
      G8.default,
      J8.default,
      F8.default,
      M8.default,
      x8.default,
      z8.default,
      V8.default,
    ];
    return (
      e ? t.push(D8.default, j8.default) : t.push(k8.default, q8.default), t.push(L8.default), t
    );
  }
  rg.default = Q8;
});
var BO = b((ng) => {
  "use strict";
  Object.defineProperty(ng, "__esModule", { value: !0 });
  var kt = he(),
    W8 = {
      message: ({ schemaCode: e }) => (0, kt.str)`must match format "${e}"`,
      params: ({ schemaCode: e }) => (0, kt._)`{format: ${e}}`,
    },
    Y8 = {
      keyword: "format",
      type: ["number", "string"],
      schemaType: "string",
      $data: !0,
      error: W8,
      code(e, t) {
        let { gen: r, data: n, $data: s, schema: i, schemaCode: o, it: a } = e,
          { opts: u, errSchemaPath: l, schemaEnv: c, self: f } = a;
        if (!u.validateFormats) return;
        s ? d() : h();
        function d() {
          let p = r.scopeValue("formats", { ref: f.formats, code: u.code.formats }),
            y = r.const("fDef", (0, kt._)`${p}[${o}]`),
            _ = r.let("fType"),
            S = r.let("format");
          r.if(
            (0, kt._)`typeof ${y} == "object" && !(${y} instanceof RegExp)`,
            () => r.assign(_, (0, kt._)`${y}.type || "string"`).assign(S, (0, kt._)`${y}.validate`),
            () => r.assign(_, (0, kt._)`"string"`).assign(S, y),
          ),
            e.fail$data((0, kt.or)(E(), g()));
          function E() {
            return u.strictSchema === !1 ? kt.nil : (0, kt._)`${o} && !${S}`;
          }
          function g() {
            let m = c.$async
                ? (0, kt._)`(${y}.async ? await ${S}(${n}) : ${S}(${n}))`
                : (0, kt._)`${S}(${n})`,
              T = (0, kt._)`(typeof ${S} == "function" ? ${m} : ${S}.test(${n}))`;
            return (0, kt._)`${S} && ${S} !== true && ${_} === ${t} && !${T}`;
          }
        }
        function h() {
          let p = f.formats[i];
          if (!p) {
            E();
            return;
          }
          if (p === !0) return;
          let [y, _, S] = g(p);
          y === t && e.pass(m());
          function E() {
            if (u.strictSchema === !1) {
              f.logger.warn(T());
              return;
            }
            throw new Error(T());
            function T() {
              return `unknown format "${i}" ignored in schema at path "${l}"`;
            }
          }
          function g(T) {
            let N =
                T instanceof RegExp
                  ? (0, kt.regexpCode)(T)
                  : u.code.formats
                    ? (0, kt._)`${u.code.formats}${(0, kt.getProperty)(i)}`
                    : void 0,
              w = r.scopeValue("formats", { key: i, ref: T, code: N });
            return typeof T == "object" && !(T instanceof RegExp)
              ? [T.type || "string", T.validate, (0, kt._)`${w}.validate`]
              : ["string", T, w];
          }
          function m() {
            if (typeof p == "object" && !(p instanceof RegExp) && p.async) {
              if (!c.$async) throw new Error("async format in sync schema");
              return (0, kt._)`await ${S}(${n})`;
            }
            return typeof _ == "function" ? (0, kt._)`${S}(${n})` : (0, kt._)`${S}.test(${n})`;
          }
        }
      },
    };
  ng.default = Y8;
});
var KO = b((sg) => {
  "use strict";
  Object.defineProperty(sg, "__esModule", { value: !0 });
  var X8 = BO(),
    Z8 = [X8.default];
  sg.default = Z8;
});
var GO = b((Ro) => {
  "use strict";
  Object.defineProperty(Ro, "__esModule", { value: !0 });
  Ro.contentVocabulary = Ro.metadataVocabulary = void 0;
  Ro.metadataVocabulary = [
    "title",
    "description",
    "default",
    "deprecated",
    "readOnly",
    "writeOnly",
    "examples",
  ];
  Ro.contentVocabulary = ["contentMediaType", "contentEncoding", "contentSchema"];
});
var QO = b((ig) => {
  "use strict";
  Object.defineProperty(ig, "__esModule", { value: !0 });
  var eG = rO(),
    tG = yO(),
    rG = HO(),
    nG = KO(),
    JO = GO(),
    sG = [
      eG.default,
      tG.default,
      (0, rG.default)(),
      nG.default,
      JO.metadataVocabulary,
      JO.contentVocabulary,
    ];
  ig.default = sG;
});
var og = b((Ef) => {
  "use strict";
  Object.defineProperty(Ef, "__esModule", { value: !0 });
  Ef.DiscrError = void 0;
  var WO;
  (function (e) {
    (e.Tag = "tag"), (e.Mapping = "mapping");
  })(WO || (Ef.DiscrError = WO = {}));
});
var XO = b((ug) => {
  "use strict";
  Object.defineProperty(ug, "__esModule", { value: !0 });
  var To = he(),
    ag = og(),
    YO = Ti(),
    iG = ls(),
    oG = Ie(),
    aG = {
      message: ({ params: { discrError: e, tagName: t } }) =>
        e === ag.DiscrError.Tag
          ? `tag "${t}" must be string`
          : `value of tag "${t}" must be in oneOf`,
      params: ({ params: { discrError: e, tag: t, tagName: r } }) =>
        (0, To._)`{error: ${e}, tag: ${r}, tagValue: ${t}}`,
    },
    uG = {
      keyword: "discriminator",
      type: "object",
      schemaType: "object",
      error: aG,
      code(e) {
        let { gen: t, data: r, schema: n, parentSchema: s, it: i } = e,
          { oneOf: o } = s;
        if (!i.opts.discriminator) throw new Error("discriminator: requires discriminator option");
        let a = n.propertyName;
        if (typeof a != "string") throw new Error("discriminator: requires propertyName");
        if (n.mapping) throw new Error("discriminator: mapping is not supported");
        if (!o) throw new Error("discriminator: requires oneOf keyword");
        let u = t.let("valid", !1),
          l = t.const("tag", (0, To._)`${r}${(0, To.getProperty)(a)}`);
        t.if(
          (0, To._)`typeof ${l} == "string"`,
          () => c(),
          () => e.error(!1, { discrError: ag.DiscrError.Tag, tag: l, tagName: a }),
        ),
          e.ok(u);
        function c() {
          let h = d();
          t.if(!1);
          for (let p in h) t.elseIf((0, To._)`${l} === ${p}`), t.assign(u, f(h[p]));
          t.else(),
            e.error(!1, { discrError: ag.DiscrError.Mapping, tag: l, tagName: a }),
            t.endIf();
        }
        function f(h) {
          let p = t.name("valid"),
            y = e.subschema({ keyword: "oneOf", schemaProp: h }, p);
          return e.mergeEvaluated(y, To.Name), p;
        }
        function d() {
          var h;
          let p = {},
            y = S(s),
            _ = !0;
          for (let m = 0; m < o.length; m++) {
            let T = o[m];
            if (T?.$ref && !(0, oG.schemaHasRulesButRef)(T, i.self.RULES)) {
              let w = T.$ref;
              if (
                ((T = YO.resolveRef.call(i.self, i.schemaEnv.root, i.baseId, w)),
                T instanceof YO.SchemaEnv && (T = T.schema),
                T === void 0)
              )
                throw new iG.default(i.opts.uriResolver, i.baseId, w);
            }
            let N = (h = T?.properties) === null || h === void 0 ? void 0 : h[a];
            if (typeof N != "object")
              throw new Error(
                `discriminator: oneOf subschemas (or referenced schemas) must have "properties/${a}"`,
              );
            (_ = _ && (y || S(T))), E(N, m);
          }
          if (!_) throw new Error(`discriminator: "${a}" must be required`);
          return p;
          function S({ required: m }) {
            return Array.isArray(m) && m.includes(a);
          }
          function E(m, T) {
            if (m.const) g(m.const, T);
            else if (m.enum) for (let N of m.enum) g(N, T);
            else throw new Error(`discriminator: "properties/${a}" must have "const" or "enum"`);
          }
          function g(m, T) {
            if (typeof m != "string" || m in p)
              throw new Error(`discriminator: "${a}" values must be unique strings`);
            p[m] = T;
          }
        }
      },
    };
  ug.default = uG;
});
var ZO = b((Doe, lG) => {
  lG.exports = {
    $schema: "http://json-schema.org/draft-07/schema#",
    $id: "http://json-schema.org/draft-07/schema#",
    title: "Core schema meta-schema",
    definitions: {
      schemaArray: { type: "array", minItems: 1, items: { $ref: "#" } },
      nonNegativeInteger: { type: "integer", minimum: 0 },
      nonNegativeIntegerDefault0: {
        allOf: [{ $ref: "#/definitions/nonNegativeInteger" }, { default: 0 }],
      },
      simpleTypes: { enum: ["array", "boolean", "integer", "null", "number", "object", "string"] },
      stringArray: { type: "array", items: { type: "string" }, uniqueItems: !0, default: [] },
    },
    type: ["object", "boolean"],
    properties: {
      $id: { type: "string", format: "uri-reference" },
      $schema: { type: "string", format: "uri" },
      $ref: { type: "string", format: "uri-reference" },
      $comment: { type: "string" },
      title: { type: "string" },
      description: { type: "string" },
      default: !0,
      readOnly: { type: "boolean", default: !1 },
      examples: { type: "array", items: !0 },
      multipleOf: { type: "number", exclusiveMinimum: 0 },
      maximum: { type: "number" },
      exclusiveMaximum: { type: "number" },
      minimum: { type: "number" },
      exclusiveMinimum: { type: "number" },
      maxLength: { $ref: "#/definitions/nonNegativeInteger" },
      minLength: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
      pattern: { type: "string", format: "regex" },
      additionalItems: { $ref: "#" },
      items: { anyOf: [{ $ref: "#" }, { $ref: "#/definitions/schemaArray" }], default: !0 },
      maxItems: { $ref: "#/definitions/nonNegativeInteger" },
      minItems: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
      uniqueItems: { type: "boolean", default: !1 },
      contains: { $ref: "#" },
      maxProperties: { $ref: "#/definitions/nonNegativeInteger" },
      minProperties: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
      required: { $ref: "#/definitions/stringArray" },
      additionalProperties: { $ref: "#" },
      definitions: { type: "object", additionalProperties: { $ref: "#" }, default: {} },
      properties: { type: "object", additionalProperties: { $ref: "#" }, default: {} },
      patternProperties: {
        type: "object",
        additionalProperties: { $ref: "#" },
        propertyNames: { format: "regex" },
        default: {},
      },
      dependencies: {
        type: "object",
        additionalProperties: { anyOf: [{ $ref: "#" }, { $ref: "#/definitions/stringArray" }] },
      },
      propertyNames: { $ref: "#" },
      const: !0,
      enum: { type: "array", items: !0, minItems: 1, uniqueItems: !0 },
      type: {
        anyOf: [
          { $ref: "#/definitions/simpleTypes" },
          {
            type: "array",
            items: { $ref: "#/definitions/simpleTypes" },
            minItems: 1,
            uniqueItems: !0,
          },
        ],
      },
      format: { type: "string" },
      contentMediaType: { type: "string" },
      contentEncoding: { type: "string" },
      if: { $ref: "#" },
      then: { $ref: "#" },
      else: { $ref: "#" },
      allOf: { $ref: "#/definitions/schemaArray" },
      anyOf: { $ref: "#/definitions/schemaArray" },
      oneOf: { $ref: "#/definitions/schemaArray" },
      not: { $ref: "#" },
    },
    default: !0,
  };
});
var fu = b((_t, lg) => {
  "use strict";
  Object.defineProperty(_t, "__esModule", { value: !0 });
  _t.MissingRefError =
    _t.ValidationError =
    _t.CodeGen =
    _t.Name =
    _t.nil =
    _t.stringify =
    _t.str =
    _t._ =
    _t.KeywordCxt =
    _t.Ajv =
      void 0;
  var cG = _y(),
    fG = QO(),
    dG = XO(),
    e1 = ZO(),
    hG = ["/properties"],
    Rf = "http://json-schema.org/draft-07/schema",
    Po = class extends cG.default {
      _addVocabularies() {
        super._addVocabularies(),
          fG.default.forEach((t) => this.addVocabulary(t)),
          this.opts.discriminator && this.addKeyword(dG.default);
      }
      _addDefaultMetaSchema() {
        if ((super._addDefaultMetaSchema(), !this.opts.meta)) return;
        let t = this.opts.$data ? this.$dataMetaSchema(e1, hG) : e1;
        this.addMetaSchema(t, Rf, !1), (this.refs["http://json-schema.org/schema"] = Rf);
      }
      defaultMeta() {
        return (this.opts.defaultMeta = super.defaultMeta() || (this.getSchema(Rf) ? Rf : void 0));
      }
    };
  _t.Ajv = Po;
  lg.exports = _t = Po;
  lg.exports.Ajv = Po;
  Object.defineProperty(_t, "__esModule", { value: !0 });
  _t.default = Po;
  var pG = vo();
  Object.defineProperty(_t, "KeywordCxt", {
    enumerable: !0,
    get: function () {
      return pG.KeywordCxt;
    },
  });
  var $o = he();
  Object.defineProperty(_t, "_", {
    enumerable: !0,
    get: function () {
      return $o._;
    },
  });
  Object.defineProperty(_t, "str", {
    enumerable: !0,
    get: function () {
      return $o.str;
    },
  });
  Object.defineProperty(_t, "stringify", {
    enumerable: !0,
    get: function () {
      return $o.stringify;
    },
  });
  Object.defineProperty(_t, "nil", {
    enumerable: !0,
    get: function () {
      return $o.nil;
    },
  });
  Object.defineProperty(_t, "Name", {
    enumerable: !0,
    get: function () {
      return $o.Name;
    },
  });
  Object.defineProperty(_t, "CodeGen", {
    enumerable: !0,
    get: function () {
      return $o.CodeGen;
    },
  });
  var mG = Ya();
  Object.defineProperty(_t, "ValidationError", {
    enumerable: !0,
    get: function () {
      return mG.default;
    },
  });
  var yG = ls();
  Object.defineProperty(_t, "MissingRefError", {
    enumerable: !0,
    get: function () {
      return yG.default;
    },
  });
});
var r1 = b((qoe, t1) => {
  "use strict";
  var gG = {
    0: 0,
    1: 1,
    2: 2,
    3: 3,
    4: 4,
    5: 5,
    6: 6,
    7: 7,
    8: 8,
    9: 9,
    a: 10,
    A: 10,
    b: 11,
    B: 11,
    c: 12,
    C: 12,
    d: 13,
    D: 13,
    e: 14,
    E: 14,
    f: 15,
    F: 15,
  };
  t1.exports = { HEX: gG };
});
var c1 = b((joe, l1) => {
  "use strict";
  var { HEX: _G } = r1();
  function o1(e) {
    if (u1(e, ".") < 3) return { host: e, isIPV4: !1 };
    let t =
        e.match(/^(\b[01]?\d{1,2}|\b2[0-4]\d|\b25[0-5])(\.([01]?\d{1,2}|2[0-4]\d|25[0-5])){3}$/u) ||
        [],
      [r] = t;
    return r ? { host: vG(r, "."), isIPV4: !0 } : { host: e, isIPV4: !1 };
  }
  function cg(e) {
    let t = "",
      r = !0;
    for (let n of e) {
      if ((n !== "0" && r === !0 && (r = !1), _G[n] === void 0)) return;
      r || (t += n);
    }
    return t;
  }
  function SG(e) {
    let t = 0,
      r = { error: !1, address: "", zone: "" },
      n = [],
      s = [],
      i = !1,
      o = !1,
      a = !1;
    function u() {
      if (s.length) {
        if (i === !1) {
          let l = cg(s.join(""));
          if (l !== void 0) n.push(l);
          else return (r.error = !0), !1;
        }
        s.length = 0;
      }
      return !0;
    }
    for (let l = 0; l < e.length; l++) {
      let c = e[l];
      if (!(c === "[" || c === "]"))
        if (c === ":") {
          if ((o === !0 && (a = !0), !u())) break;
          if ((t++, n.push(":"), t > 7)) {
            r.error = !0;
            break;
          }
          l - 1 >= 0 && e[l - 1] === ":" && (o = !0);
          continue;
        } else if (c === "%") {
          if (!u()) break;
          i = !0;
        } else {
          s.push(c);
          continue;
        }
    }
    return (
      s.length && (i ? (r.zone = s.join("")) : a ? n.push(s.join("")) : n.push(cg(s.join("")))),
      (r.address = n.join("")),
      r
    );
  }
  function a1(e, t = {}) {
    if (u1(e, ":") < 2) return { host: e, isIPV6: !1 };
    let r = SG(e);
    if (r.error) return { host: e, isIPV6: !1 };
    {
      let n = r.address,
        s = r.address;
      return (
        r.zone && ((n += "%" + r.zone), (s += "%25" + r.zone)),
        { host: n, escapedHost: s, isIPV6: !0 }
      );
    }
  }
  function vG(e, t) {
    let r = "",
      n = !0,
      s = e.length;
    for (let i = 0; i < s; i++) {
      let o = e[i];
      o === "0" && n
        ? ((i + 1 <= s && e[i + 1] === t) || i + 1 === s) && ((r += o), (n = !1))
        : (o === t ? (n = !0) : (n = !1), (r += o));
    }
    return r;
  }
  function u1(e, t) {
    let r = 0;
    for (let n = 0; n < e.length; n++) e[n] === t && r++;
    return r;
  }
  var n1 = /^\.\.?\//u,
    s1 = /^\/\.(?:\/|$)/u,
    i1 = /^\/\.\.(?:\/|$)/u,
    bG = /^\/?(?:.|\n)*?(?=\/|$)/u;
  function wG(e) {
    let t = [];
    for (; e.length; )
      if (e.match(n1)) e = e.replace(n1, "");
      else if (e.match(s1)) e = e.replace(s1, "/");
      else if (e.match(i1)) (e = e.replace(i1, "/")), t.pop();
      else if (e === "." || e === "..") e = "";
      else {
        let r = e.match(bG);
        if (r) {
          let n = r[0];
          (e = e.slice(n.length)), t.push(n);
        } else throw new Error("Unexpected dot segment condition");
      }
    return t.join("");
  }
  function EG(e, t) {
    let r = t !== !0 ? escape : unescape;
    return (
      e.scheme !== void 0 && (e.scheme = r(e.scheme)),
      e.userinfo !== void 0 && (e.userinfo = r(e.userinfo)),
      e.host !== void 0 && (e.host = r(e.host)),
      e.path !== void 0 && (e.path = r(e.path)),
      e.query !== void 0 && (e.query = r(e.query)),
      e.fragment !== void 0 && (e.fragment = r(e.fragment)),
      e
    );
  }
  function RG(e, t) {
    let r = [];
    if ((e.userinfo !== void 0 && (r.push(e.userinfo), r.push("@")), e.host !== void 0)) {
      let n = unescape(e.host),
        s = o1(n);
      if (s.isIPV4) n = s.host;
      else {
        let i = a1(s.host, { isIPV4: !1 });
        i.isIPV6 === !0 ? (n = `[${i.escapedHost}]`) : (n = e.host);
      }
      r.push(n);
    }
    return (
      (typeof e.port == "number" || typeof e.port == "string") &&
        (r.push(":"), r.push(String(e.port))),
      r.length ? r.join("") : void 0
    );
  }
  l1.exports = {
    recomposeAuthority: RG,
    normalizeComponentEncoding: EG,
    removeDotSegments: wG,
    normalizeIPv4: o1,
    normalizeIPv6: a1,
    stringToHexStripped: cg,
  };
});
var y1 = b((Loe, m1) => {
  "use strict";
  var TG = /^[\da-f]{8}\b-[\da-f]{4}\b-[\da-f]{4}\b-[\da-f]{4}\b-[\da-f]{12}$/iu,
    PG = /([\da-z][\d\-a-z]{0,31}):((?:[\w!$'()*+,\-.:;=@]|%[\da-f]{2})+)/iu;
  function f1(e) {
    return typeof e.secure == "boolean" ? e.secure : String(e.scheme).toLowerCase() === "wss";
  }
  function d1(e) {
    return e.host || (e.error = e.error || "HTTP URIs must have a host."), e;
  }
  function h1(e) {
    let t = String(e.scheme).toLowerCase() === "https";
    return (
      (e.port === (t ? 443 : 80) || e.port === "") && (e.port = void 0), e.path || (e.path = "/"), e
    );
  }
  function $G(e) {
    return (
      (e.secure = f1(e)),
      (e.resourceName = (e.path || "/") + (e.query ? "?" + e.query : "")),
      (e.path = void 0),
      (e.query = void 0),
      e
    );
  }
  function OG(e) {
    if (
      ((e.port === (f1(e) ? 443 : 80) || e.port === "") && (e.port = void 0),
      typeof e.secure == "boolean" && ((e.scheme = e.secure ? "wss" : "ws"), (e.secure = void 0)),
      e.resourceName)
    ) {
      let [t, r] = e.resourceName.split("?");
      (e.path = t && t !== "/" ? t : void 0), (e.query = r), (e.resourceName = void 0);
    }
    return (e.fragment = void 0), e;
  }
  function NG(e, t) {
    if (!e.path) return (e.error = "URN can not be parsed"), e;
    let r = e.path.match(PG);
    if (r) {
      let n = t.scheme || e.scheme || "urn";
      (e.nid = r[1].toLowerCase()), (e.nss = r[2]);
      let s = `${n}:${t.nid || e.nid}`,
        i = fg[s];
      (e.path = void 0), i && (e = i.parse(e, t));
    } else e.error = e.error || "URN can not be parsed.";
    return e;
  }
  function AG(e, t) {
    let r = t.scheme || e.scheme || "urn",
      n = e.nid.toLowerCase(),
      s = `${r}:${t.nid || n}`,
      i = fg[s];
    i && (e = i.serialize(e, t));
    let o = e,
      a = e.nss;
    return (o.path = `${n || t.nid}:${a}`), (t.skipEscape = !0), o;
  }
  function IG(e, t) {
    let r = e;
    return (
      (r.uuid = r.nss),
      (r.nss = void 0),
      !t.tolerant && (!r.uuid || !TG.test(r.uuid)) && (r.error = r.error || "UUID is not valid."),
      r
    );
  }
  function CG(e) {
    let t = e;
    return (t.nss = (e.uuid || "").toLowerCase()), t;
  }
  var p1 = { scheme: "http", domainHost: !0, parse: d1, serialize: h1 },
    kG = { scheme: "https", domainHost: p1.domainHost, parse: d1, serialize: h1 },
    Tf = { scheme: "ws", domainHost: !0, parse: $G, serialize: OG },
    DG = { scheme: "wss", domainHost: Tf.domainHost, parse: Tf.parse, serialize: Tf.serialize },
    qG = { scheme: "urn", parse: NG, serialize: AG, skipNormalize: !0 },
    jG = { scheme: "urn:uuid", parse: IG, serialize: CG, skipNormalize: !0 },
    fg = { http: p1, https: kG, ws: Tf, wss: DG, urn: qG, "urn:uuid": jG };
  m1.exports = fg;
});
var hg = b((xoe, $f) => {
  "use strict";
  var {
      normalizeIPv6: LG,
      normalizeIPv4: xG,
      removeDotSegments: du,
      recomposeAuthority: FG,
      normalizeComponentEncoding: Pf,
    } = c1(),
    g1 = y1();
  function MG(e, t) {
    return (
      typeof e == "string" ? (e = Ln(cs(e, t), t)) : typeof e == "object" && (e = cs(Ln(e, t), t)),
      e
    );
  }
  function zG(e, t, r) {
    let n = Object.assign({ scheme: "null" }, r),
      s = _1(cs(e, n), cs(t, n), n, !0);
    return Ln(s, { ...n, skipEscape: !0 });
  }
  function _1(e, t, r, n) {
    let s = {};
    return (
      n || ((e = cs(Ln(e, r), r)), (t = cs(Ln(t, r), r))),
      (r = r || {}),
      !r.tolerant && t.scheme
        ? ((s.scheme = t.scheme),
          (s.userinfo = t.userinfo),
          (s.host = t.host),
          (s.port = t.port),
          (s.path = du(t.path || "")),
          (s.query = t.query))
        : (t.userinfo !== void 0 || t.host !== void 0 || t.port !== void 0
            ? ((s.userinfo = t.userinfo),
              (s.host = t.host),
              (s.port = t.port),
              (s.path = du(t.path || "")),
              (s.query = t.query))
            : (t.path
                ? (t.path.charAt(0) === "/"
                    ? (s.path = du(t.path))
                    : ((e.userinfo !== void 0 || e.host !== void 0 || e.port !== void 0) && !e.path
                        ? (s.path = "/" + t.path)
                        : e.path
                          ? (s.path = e.path.slice(0, e.path.lastIndexOf("/") + 1) + t.path)
                          : (s.path = t.path),
                      (s.path = du(s.path))),
                  (s.query = t.query))
                : ((s.path = e.path),
                  t.query !== void 0 ? (s.query = t.query) : (s.query = e.query)),
              (s.userinfo = e.userinfo),
              (s.host = e.host),
              (s.port = e.port)),
          (s.scheme = e.scheme)),
      (s.fragment = t.fragment),
      s
    );
  }
  function VG(e, t, r) {
    return (
      typeof e == "string"
        ? ((e = unescape(e)), (e = Ln(Pf(cs(e, r), !0), { ...r, skipEscape: !0 })))
        : typeof e == "object" && (e = Ln(Pf(e, !0), { ...r, skipEscape: !0 })),
      typeof t == "string"
        ? ((t = unescape(t)), (t = Ln(Pf(cs(t, r), !0), { ...r, skipEscape: !0 })))
        : typeof t == "object" && (t = Ln(Pf(t, !0), { ...r, skipEscape: !0 })),
      e.toLowerCase() === t.toLowerCase()
    );
  }
  function Ln(e, t) {
    let r = {
        host: e.host,
        scheme: e.scheme,
        userinfo: e.userinfo,
        port: e.port,
        path: e.path,
        query: e.query,
        nid: e.nid,
        nss: e.nss,
        uuid: e.uuid,
        fragment: e.fragment,
        reference: e.reference,
        resourceName: e.resourceName,
        secure: e.secure,
        error: "",
      },
      n = Object.assign({}, t),
      s = [],
      i = g1[(n.scheme || r.scheme || "").toLowerCase()];
    i && i.serialize && i.serialize(r, n),
      r.path !== void 0 &&
        (n.skipEscape
          ? (r.path = unescape(r.path))
          : ((r.path = escape(r.path)),
            r.scheme !== void 0 && (r.path = r.path.split("%3A").join(":")))),
      n.reference !== "suffix" && r.scheme && (s.push(r.scheme), s.push(":"));
    let o = FG(r, n);
    if (
      (o !== void 0 &&
        (n.reference !== "suffix" && s.push("//"),
        s.push(o),
        r.path && r.path.charAt(0) !== "/" && s.push("/")),
      r.path !== void 0)
    ) {
      let a = r.path;
      !n.absolutePath && (!i || !i.absolutePath) && (a = du(a)),
        o === void 0 && (a = a.replace(/^\/\//u, "/%2F")),
        s.push(a);
    }
    return (
      r.query !== void 0 && (s.push("?"), s.push(r.query)),
      r.fragment !== void 0 && (s.push("#"), s.push(r.fragment)),
      s.join("")
    );
  }
  var UG = Array.from({ length: 127 }, (e, t) =>
    /[^!"$&'()*+,\-.;=_`a-z{}~]/u.test(String.fromCharCode(t)),
  );
  function HG(e) {
    let t = 0;
    for (let r = 0, n = e.length; r < n; ++r)
      if (((t = e.charCodeAt(r)), t > 126 || UG[t])) return !0;
    return !1;
  }
  var BG =
    /^(?:([^#/:?]+):)?(?:\/\/((?:([^#/?@]*)@)?(\[[^#/?\]]+\]|[^#/:?]*)(?::(\d*))?))?([^#?]*)(?:\?([^#]*))?(?:#((?:.|[\n\r])*))?/u;
  function cs(e, t) {
    let r = Object.assign({}, t),
      n = {
        scheme: void 0,
        userinfo: void 0,
        host: "",
        port: void 0,
        path: "",
        query: void 0,
        fragment: void 0,
      },
      s = e.indexOf("%") !== -1;
    r.reference === "suffix" && (e = (r.scheme ? r.scheme + ":" : "") + "//" + e);
    let i = e.match(BG);
    if (i) {
      if (
        ((n.scheme = i[1]),
        (n.userinfo = i[3]),
        (n.host = i[4]),
        (n.port = parseInt(i[5], 10)),
        (n.path = i[6] || ""),
        (n.query = i[7]),
        (n.fragment = i[8]),
        isNaN(n.port) && (n.port = i[5]),
        n.host)
      ) {
        let a = xG(n.host);
        a.isIPV4 === !1
          ? (n.host = LG(a.host, { isIPV4: !1 }).host.toLowerCase())
          : (n.host = a.host);
      }
      n.scheme === void 0 &&
      n.userinfo === void 0 &&
      n.host === void 0 &&
      n.port === void 0 &&
      !n.path &&
      n.query === void 0
        ? (n.reference = "same-document")
        : n.scheme === void 0
          ? (n.reference = "relative")
          : n.fragment === void 0
            ? (n.reference = "absolute")
            : (n.reference = "uri"),
        r.reference &&
          r.reference !== "suffix" &&
          r.reference !== n.reference &&
          (n.error = n.error || "URI is not a " + r.reference + " reference.");
      let o = g1[(r.scheme || n.scheme || "").toLowerCase()];
      if (
        !r.unicodeSupport &&
        (!o || !o.unicodeSupport) &&
        n.host &&
        (r.domainHost || (o && o.domainHost)) &&
        HG(n.host)
      )
        try {
          n.host = URL.domainToASCII(n.host.toLowerCase());
        } catch (a) {
          n.error = n.error || "Host's domain name can not be converted to ASCII: " + a;
        }
      (!o || (o && !o.skipNormalize)) &&
        (s && n.scheme !== void 0 && (n.scheme = unescape(n.scheme)),
        s && n.userinfo !== void 0 && (n.userinfo = unescape(n.userinfo)),
        s && n.host !== void 0 && (n.host = unescape(n.host)),
        n.path !== void 0 && n.path.length && (n.path = escape(unescape(n.path))),
        n.fragment !== void 0 &&
          n.fragment.length &&
          (n.fragment = encodeURI(decodeURI(n.fragment)))),
        o && o.parse && o.parse(n, r);
    } else n.error = n.error || "URI can not be parsed.";
    return n;
  }
  var dg = {
    normalize: MG,
    resolve: zG,
    resolveComponents: _1,
    equal: VG,
    serialize: Ln,
    parse: cs,
  };
  $f.exports = dg;
  $f.exports.default = dg;
  $f.exports.fastUri = dg;
});
var Of = b((Fn) => {
  "use strict";
  Object.defineProperty(Fn, "__esModule", { value: !0 });
  Fn.formatNames = Fn.fastFormats = Fn.fullFormats = void 0;
  function xn(e, t) {
    return { validate: e, compare: t };
  }
  Fn.fullFormats = {
    date: xn(w1, gg),
    time: xn(mg(!0), _g),
    "date-time": xn(S1(!0), R1),
    "iso-time": xn(mg(), E1),
    "iso-date-time": xn(S1(), T1),
    duration: /^P(?!$)((\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+S)?)?|(\d+W)?)$/,
    uri: YG,
    "uri-reference":
      /^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i,
    "uri-template":
      /^(?:(?:[^\x00-\x20"'<>%\\^`{|}]|%[0-9a-f]{2})|\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?)*\})*$/i,
    url: /^(?:https?|ftp):\/\/(?:\S+(?::\S*)?@)?(?:(?!(?:10|127)(?:\.\d{1,3}){3})(?!(?:169\.254|192\.168)(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)(?:\.(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)*(?:\.(?:[a-z\u{00a1}-\u{ffff}]{2,})))(?::\d{2,5})?(?:\/[^\s]*)?$/iu,
    email:
      /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i,
    hostname:
      /^(?=.{1,253}\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\.?$/i,
    ipv4: /^(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)\.){3}(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)$/,
    ipv6: /^((([0-9a-f]{1,4}:){7}([0-9a-f]{1,4}|:))|(([0-9a-f]{1,4}:){6}(:[0-9a-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){5}(((:[0-9a-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){4}(((:[0-9a-f]{1,4}){1,3})|((:[0-9a-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){3}(((:[0-9a-f]{1,4}){1,4})|((:[0-9a-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){2}(((:[0-9a-f]{1,4}){1,5})|((:[0-9a-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){1}(((:[0-9a-f]{1,4}){1,6})|((:[0-9a-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9a-f]{1,4}){1,7})|((:[0-9a-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))$/i,
    regex: sJ,
    uuid: /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i,
    "json-pointer": /^(?:\/(?:[^~/]|~0|~1)*)*$/,
    "json-pointer-uri-fragment": /^#(?:\/(?:[a-z0-9_\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i,
    "relative-json-pointer": /^(?:0|[1-9][0-9]*)(?:#|(?:\/(?:[^~/]|~0|~1)*)*)$/,
    byte: XG,
    int32: { type: "number", validate: tJ },
    int64: { type: "number", validate: rJ },
    float: { type: "number", validate: b1 },
    double: { type: "number", validate: b1 },
    password: !0,
    binary: !0,
  };
  Fn.fastFormats = {
    ...Fn.fullFormats,
    date: xn(/^\d\d\d\d-[0-1]\d-[0-3]\d$/, gg),
    time: xn(/^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i, _g),
    "date-time": xn(
      /^\d\d\d\d-[0-1]\d-[0-3]\dt(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i,
      R1,
    ),
    "iso-time": xn(
      /^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)?$/i,
      E1,
    ),
    "iso-date-time": xn(
      /^\d\d\d\d-[0-1]\d-[0-3]\d[t\s](?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)?$/i,
      T1,
    ),
    uri: /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/)?[^\s]*$/i,
    "uri-reference": /^(?:(?:[a-z][a-z0-9+\-.]*:)?\/?\/)?(?:[^\\\s#][^\s#]*)?(?:#[^\\\s]*)?$/i,
    email:
      /^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$/i,
  };
  Fn.formatNames = Object.keys(Fn.fullFormats);
  function KG(e) {
    return e % 4 === 0 && (e % 100 !== 0 || e % 400 === 0);
  }
  var GG = /^(\d\d\d\d)-(\d\d)-(\d\d)$/,
    JG = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
  function w1(e) {
    let t = GG.exec(e);
    if (!t) return !1;
    let r = +t[1],
      n = +t[2],
      s = +t[3];
    return n >= 1 && n <= 12 && s >= 1 && s <= (n === 2 && KG(r) ? 29 : JG[n]);
  }
  function gg(e, t) {
    if (e && t) return e > t ? 1 : e < t ? -1 : 0;
  }
  var pg = /^(\d\d):(\d\d):(\d\d(?:\.\d+)?)(z|([+-])(\d\d)(?::?(\d\d))?)?$/i;
  function mg(e) {
    return function (r) {
      let n = pg.exec(r);
      if (!n) return !1;
      let s = +n[1],
        i = +n[2],
        o = +n[3],
        a = n[4],
        u = n[5] === "-" ? -1 : 1,
        l = +(n[6] || 0),
        c = +(n[7] || 0);
      if (l > 23 || c > 59 || (e && !a)) return !1;
      if (s <= 23 && i <= 59 && o < 60) return !0;
      let f = i - c * u,
        d = s - l * u - (f < 0 ? 1 : 0);
      return (d === 23 || d === -1) && (f === 59 || f === -1) && o < 61;
    };
  }
  function _g(e, t) {
    if (!(e && t)) return;
    let r = new Date("2020-01-01T" + e).valueOf(),
      n = new Date("2020-01-01T" + t).valueOf();
    if (r && n) return r - n;
  }
  function E1(e, t) {
    if (!(e && t)) return;
    let r = pg.exec(e),
      n = pg.exec(t);
    if (r && n)
      return (e = r[1] + r[2] + r[3]), (t = n[1] + n[2] + n[3]), e > t ? 1 : e < t ? -1 : 0;
  }
  var yg = /t|\s/i;
  function S1(e) {
    let t = mg(e);
    return function (n) {
      let s = n.split(yg);
      return s.length === 2 && w1(s[0]) && t(s[1]);
    };
  }
  function R1(e, t) {
    if (!(e && t)) return;
    let r = new Date(e).valueOf(),
      n = new Date(t).valueOf();
    if (r && n) return r - n;
  }
  function T1(e, t) {
    if (!(e && t)) return;
    let [r, n] = e.split(yg),
      [s, i] = t.split(yg),
      o = gg(r, s);
    if (o !== void 0) return o || _g(n, i);
  }
  var QG = /\/|:/,
    WG =
      /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\?(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
  function YG(e) {
    return QG.test(e) && WG.test(e);
  }
  var v1 = /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/gm;
  function XG(e) {
    return (v1.lastIndex = 0), v1.test(e);
  }
  var ZG = -(2 ** 31),
    eJ = 2 ** 31 - 1;
  function tJ(e) {
    return Number.isInteger(e) && e <= eJ && e >= ZG;
  }
  function rJ(e) {
    return Number.isInteger(e);
  }
  function b1() {
    return !0;
  }
  var nJ = /[^\\]\\Z/;
  function sJ(e) {
    if (nJ.test(e)) return !1;
    try {
      return new RegExp(e), !0;
    } catch {
      return !1;
    }
  }
});
var P1 = b((Oo) => {
  "use strict";
  Object.defineProperty(Oo, "__esModule", { value: !0 });
  Oo.formatLimitDefinition = void 0;
  var iJ = fu(),
    vn = he(),
    Us = vn.operators,
    Nf = {
      formatMaximum: { okStr: "<=", ok: Us.LTE, fail: Us.GT },
      formatMinimum: { okStr: ">=", ok: Us.GTE, fail: Us.LT },
      formatExclusiveMaximum: { okStr: "<", ok: Us.LT, fail: Us.GTE },
      formatExclusiveMinimum: { okStr: ">", ok: Us.GT, fail: Us.LTE },
    },
    oJ = {
      message: ({ keyword: e, schemaCode: t }) => (0, vn.str)`should be ${Nf[e].okStr} ${t}`,
      params: ({ keyword: e, schemaCode: t }) =>
        (0, vn._)`{comparison: ${Nf[e].okStr}, limit: ${t}}`,
    };
  Oo.formatLimitDefinition = {
    keyword: Object.keys(Nf),
    type: "string",
    schemaType: "string",
    $data: !0,
    error: oJ,
    code(e) {
      let { gen: t, data: r, schemaCode: n, keyword: s, it: i } = e,
        { opts: o, self: a } = i;
      if (!o.validateFormats) return;
      let u = new iJ.KeywordCxt(i, a.RULES.all.format.definition, "format");
      u.$data ? l() : c();
      function l() {
        let d = t.scopeValue("formats", { ref: a.formats, code: o.code.formats }),
          h = t.const("fmt", (0, vn._)`${d}[${u.schemaCode}]`);
        e.fail$data(
          (0, vn.or)(
            (0, vn._)`typeof ${h} != "object"`,
            (0, vn._)`${h} instanceof RegExp`,
            (0, vn._)`typeof ${h}.compare != "function"`,
            f(h),
          ),
        );
      }
      function c() {
        let d = u.schema,
          h = a.formats[d];
        if (!h || h === !0) return;
        if (typeof h != "object" || h instanceof RegExp || typeof h.compare != "function")
          throw new Error(`"${s}": format "${d}" does not define "compare" function`);
        let p = t.scopeValue("formats", {
          key: d,
          ref: h,
          code: o.code.formats ? (0, vn._)`${o.code.formats}${(0, vn.getProperty)(d)}` : void 0,
        });
        e.fail$data(f(p));
      }
      function f(d) {
        return (0, vn._)`${d}.compare(${r}, ${n}) ${Nf[s].fail} 0`;
      }
    },
    dependencies: ["format"],
  };
  var aJ = (e) => (e.addKeyword(Oo.formatLimitDefinition), e);
  Oo.default = aJ;
});
var A1 = b((hu, N1) => {
  "use strict";
  Object.defineProperty(hu, "__esModule", { value: !0 });
  var No = Of(),
    uJ = P1(),
    Sg = he(),
    $1 = new Sg.Name("fullFormats"),
    lJ = new Sg.Name("fastFormats"),
    vg = (e, t = { keywords: !0 }) => {
      if (Array.isArray(t)) return O1(e, t, No.fullFormats, $1), e;
      let [r, n] = t.mode === "fast" ? [No.fastFormats, lJ] : [No.fullFormats, $1],
        s = t.formats || No.formatNames;
      return O1(e, s, r, n), t.keywords && (0, uJ.default)(e), e;
    };
  vg.get = (e, t = "full") => {
    let n = (t === "fast" ? No.fastFormats : No.fullFormats)[e];
    if (!n) throw new Error(`Unknown format "${e}"`);
    return n;
  };
  function O1(e, t, r, n) {
    var s, i;
    ((s = (i = e.opts.code).formats) !== null && s !== void 0) ||
      (i.formats = (0, Sg._)`require("ajv-formats/dist/formats").${n}`);
    for (let o of t) e.addFormat(o, r[o]);
  }
  N1.exports = hu = vg;
  Object.defineProperty(hu, "__esModule", { value: !0 });
  hu.default = vg;
});
var wg = b((zoe, I1) => {
  "use strict";
  var cJ = fu(),
    fJ = hg(),
    dJ = A1(),
    hJ = dc()({ proto: !0 }),
    bg = class e {
      constructor(t) {
        (this.ajv = new cJ({
          ...t,
          strictSchema: !1,
          validateSchema: !1,
          allowUnionTypes: !0,
          uriResolver: fJ,
        })),
          dJ(this.ajv),
          this.ajv.addKeyword({
            keyword: "fjs_type",
            type: "object",
            errors: !1,
            validate: (r, n) => n instanceof Date,
          }),
          (this._ajvSchemas = {}),
          (this._ajvOptions = t || {});
      }
      addSchema(t, r) {
        let n = t.$id || r;
        if (
          (t.$id !== void 0 && t.$id[0] === "#" && (n = r + t.$id),
          this.ajv.refs[n] === void 0 && this.ajv.schemas[n] === void 0)
        ) {
          let s = hJ(t);
          this.convertSchemaToAjvFormat(s), this.ajv.addSchema(s, n), (this._ajvSchemas[n] = t);
        }
      }
      validate(t, r) {
        return this.ajv.validate(t, r);
      }
      convertSchemaToAjvFormat(t) {
        if (t !== null) {
          t.type === "string"
            ? ((t.fjs_type = "string"), (t.type = ["string", "object"]))
            : Array.isArray(t.type) &&
              t.type.includes("string") &&
              !t.type.includes("object") &&
              ((t.fjs_type = "string"), t.type.push("object"));
          for (let r in t) typeof t[r] == "object" && this.convertSchemaToAjvFormat(t[r]);
        }
      }
      getState() {
        return { ajvOptions: this._ajvOptions, ajvSchemas: this._ajvSchemas };
      }
      static restoreFromState(t) {
        let r = new e(t.ajvOptions);
        for (let [n, s] of Object.entries(t.ajvSchemas)) r.ajv.addSchema(s, n);
        return r;
      }
    };
  I1.exports = bg;
});
var k1 = b((Voe, C1) => {
  "use strict";
  var Eg = class e {
    constructor(t, r, n = "#") {
      (this.schema = t), (this.schemaId = r), (this.jsonPointer = n);
    }
    getPropertyLocation(t) {
      return new e(this.schema[t], this.schemaId, this.jsonPointer + "/" + t);
    }
    getSchemaRef() {
      return this.schemaId + this.jsonPointer;
    }
  };
  C1.exports = Eg;
});
var x1 = b((Uoe, Tg) => {
  "use strict";
  Tg.exports = Q;
  Tg.exports.default = Q;
  var pJ = {
      $schema: "http://json-schema.org/draft-07/schema#",
      $id: "http://json-schema.org/draft-07/schema#",
      title: "Core schema meta-schema",
      definitions: {
        schemaArray: { type: "array", minItems: 1, items: { $ref: "#" } },
        nonNegativeInteger: { type: "integer", minimum: 0 },
        nonNegativeIntegerDefault0: {
          allOf: [{ $ref: "#/definitions/nonNegativeInteger" }, { default: 0 }],
        },
        simpleTypes: {
          enum: ["array", "boolean", "integer", "null", "number", "object", "string"],
        },
        stringArray: { type: "array", items: { type: "string" }, uniqueItems: !0, default: [] },
      },
      type: ["object", "boolean"],
      properties: {
        $id: { type: "string", format: "uri-reference" },
        $schema: { type: "string", format: "uri" },
        $ref: { type: "string", format: "uri-reference" },
        $comment: { type: "string" },
        title: { type: "string" },
        description: { type: "string" },
        default: !0,
        readOnly: { type: "boolean", default: !1 },
        examples: { type: "array", items: !0 },
        multipleOf: { type: "number", exclusiveMinimum: 0 },
        maximum: { type: "number" },
        exclusiveMaximum: { type: "number" },
        minimum: { type: "number" },
        exclusiveMinimum: { type: "number" },
        maxLength: { $ref: "#/definitions/nonNegativeInteger" },
        minLength: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
        pattern: { type: "string", format: "regex" },
        additionalItems: { $ref: "#" },
        items: { anyOf: [{ $ref: "#" }, { $ref: "#/definitions/schemaArray" }], default: !0 },
        maxItems: { $ref: "#/definitions/nonNegativeInteger" },
        minItems: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
        uniqueItems: { type: "boolean", default: !1 },
        contains: { $ref: "#" },
        maxProperties: { $ref: "#/definitions/nonNegativeInteger" },
        minProperties: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
        required: { $ref: "#/definitions/stringArray" },
        additionalProperties: { $ref: "#" },
        definitions: { type: "object", additionalProperties: { $ref: "#" }, default: {} },
        properties: { type: "object", additionalProperties: { $ref: "#" }, default: {} },
        patternProperties: {
          type: "object",
          additionalProperties: { $ref: "#" },
          propertyNames: { format: "regex" },
          default: {},
        },
        dependencies: {
          type: "object",
          additionalProperties: { anyOf: [{ $ref: "#" }, { $ref: "#/definitions/stringArray" }] },
        },
        propertyNames: { $ref: "#" },
        const: !0,
        enum: { type: "array", items: !0, minItems: 1, uniqueItems: !0 },
        type: {
          anyOf: [
            { $ref: "#/definitions/simpleTypes" },
            {
              type: "array",
              items: { $ref: "#/definitions/simpleTypes" },
              minItems: 1,
              uniqueItems: !0,
            },
          ],
        },
        format: { type: "string" },
        contentMediaType: { type: "string" },
        contentEncoding: { type: "string" },
        if: { $ref: "#" },
        then: { $ref: "#" },
        else: { $ref: "#" },
        allOf: { $ref: "#/definitions/schemaArray" },
        anyOf: { $ref: "#/definitions/schemaArray" },
        oneOf: { $ref: "#/definitions/schemaArray" },
        not: { $ref: "#" },
      },
      default: !0,
    },
    D1 = { enum: ["array", "boolean", "integer", "null", "number", "object", "string"] },
    q1 =
      /^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i,
    mJ = Of().fullFormats.uri,
    j1 = Of().fullFormats.regex;
  function sn(
    e,
    { instancePath: t = "", parentData: r, parentDataProperty: n, rootData: s = e } = {},
  ) {
    let i = null,
      o = 0,
      a = o;
    return typeof e == "number" && !(e % 1) && !isNaN(e) && isFinite(e)
      ? o === a && typeof e == "number" && isFinite(e) && (e < 0 || isNaN(e))
        ? ((sn.errors = [
            {
              instancePath: t,
              schemaPath: "#/definitions/nonNegativeInteger/minimum",
              keyword: "minimum",
              params: { comparison: ">=", limit: 0 },
              message: "must be >= 0",
            },
          ]),
          !1)
        : ((sn.errors = i), o === 0)
      : ((sn.errors = [
          {
            instancePath: t,
            schemaPath: "#/definitions/nonNegativeInteger/type",
            keyword: "type",
            params: { type: "integer" },
            message: "must be integer",
          },
        ]),
        !1);
  }
  var Rg = { validate: Q };
  function Sr(
    e,
    { instancePath: t = "", parentData: r, parentDataProperty: n, rootData: s = e } = {},
  ) {
    let i = null,
      o = 0;
    if (o === 0)
      if (Array.isArray(e)) {
        if (e.length < 1)
          return (
            (Sr.errors = [
              {
                instancePath: t,
                schemaPath: "#/minItems",
                keyword: "minItems",
                params: { limit: 1 },
                message: "must NOT have fewer than 1 items",
              },
            ]),
            !1
          );
        {
          var a = !0;
          let u = e.length;
          for (let l = 0; l < u; l++) {
            let c = o;
            Rg.validate(e[l], {
              instancePath: t + "/" + l,
              parentData: e,
              parentDataProperty: l,
              rootData: s,
            }) ||
              ((i = i === null ? Rg.validate.errors : i.concat(Rg.validate.errors)),
              (o = i.length));
            var a = c === o;
            if (!a) break;
          }
        }
      } else
        return (
          (Sr.errors = [
            {
              instancePath: t,
              schemaPath: "#/type",
              keyword: "type",
              params: { type: "array" },
              message: "must be array",
            },
          ]),
          !1
        );
    return (Sr.errors = i), o === 0;
  }
  var L1 = ou().default;
  function Q(
    e,
    { instancePath: t = "", parentData: r, parentDataProperty: n, rootData: s = e } = {},
  ) {
    let i = null,
      o = 0;
    if (!(e && typeof e == "object" && !Array.isArray(e)) && typeof e != "boolean")
      return (
        (Q.errors = [
          {
            instancePath: t,
            schemaPath: "#/type",
            keyword: "type",
            params: { type: pJ.type },
            message: "must be object,boolean",
          },
        ]),
        !1
      );
    if (o === 0 && e && typeof e == "object" && !Array.isArray(e)) {
      if (e.$id !== void 0) {
        let g = e.$id,
          m = o;
        if (o === m && o === m)
          if (typeof g == "string") {
            if (!q1.test(g))
              return (
                (Q.errors = [
                  {
                    instancePath: t + "/$id",
                    schemaPath: "#/properties/%24id/format",
                    keyword: "format",
                    params: { format: "uri-reference" },
                    message: 'must match format "uri-reference"',
                  },
                ]),
                !1
              );
          } else
            return (
              (Q.errors = [
                {
                  instancePath: t + "/$id",
                  schemaPath: "#/properties/%24id/type",
                  keyword: "type",
                  params: { type: "string" },
                  message: "must be string",
                },
              ]),
              !1
            );
        var a = m === o;
      } else var a = !0;
      if (a) {
        if (e.$schema !== void 0) {
          let g = e.$schema,
            m = o;
          if (o === m && o === m)
            if (typeof g == "string") {
              if (!mJ(g))
                return (
                  (Q.errors = [
                    {
                      instancePath: t + "/$schema",
                      schemaPath: "#/properties/%24schema/format",
                      keyword: "format",
                      params: { format: "uri" },
                      message: 'must match format "uri"',
                    },
                  ]),
                  !1
                );
            } else
              return (
                (Q.errors = [
                  {
                    instancePath: t + "/$schema",
                    schemaPath: "#/properties/%24schema/type",
                    keyword: "type",
                    params: { type: "string" },
                    message: "must be string",
                  },
                ]),
                !1
              );
          var a = m === o;
        } else var a = !0;
        if (a) {
          if (e.$ref !== void 0) {
            let g = e.$ref,
              m = o;
            if (o === m && o === m)
              if (typeof g == "string") {
                if (!q1.test(g))
                  return (
                    (Q.errors = [
                      {
                        instancePath: t + "/$ref",
                        schemaPath: "#/properties/%24ref/format",
                        keyword: "format",
                        params: { format: "uri-reference" },
                        message: 'must match format "uri-reference"',
                      },
                    ]),
                    !1
                  );
              } else
                return (
                  (Q.errors = [
                    {
                      instancePath: t + "/$ref",
                      schemaPath: "#/properties/%24ref/type",
                      keyword: "type",
                      params: { type: "string" },
                      message: "must be string",
                    },
                  ]),
                  !1
                );
            var a = m === o;
          } else var a = !0;
          if (a) {
            if (e.$comment !== void 0) {
              let g = o;
              if (typeof e.$comment != "string")
                return (
                  (Q.errors = [
                    {
                      instancePath: t + "/$comment",
                      schemaPath: "#/properties/%24comment/type",
                      keyword: "type",
                      params: { type: "string" },
                      message: "must be string",
                    },
                  ]),
                  !1
                );
              var a = g === o;
            } else var a = !0;
            if (a) {
              if (e.title !== void 0) {
                let g = o;
                if (typeof e.title != "string")
                  return (
                    (Q.errors = [
                      {
                        instancePath: t + "/title",
                        schemaPath: "#/properties/title/type",
                        keyword: "type",
                        params: { type: "string" },
                        message: "must be string",
                      },
                    ]),
                    !1
                  );
                var a = g === o;
              } else var a = !0;
              if (a) {
                if (e.description !== void 0) {
                  let g = o;
                  if (typeof e.description != "string")
                    return (
                      (Q.errors = [
                        {
                          instancePath: t + "/description",
                          schemaPath: "#/properties/description/type",
                          keyword: "type",
                          params: { type: "string" },
                          message: "must be string",
                        },
                      ]),
                      !1
                    );
                  var a = g === o;
                } else var a = !0;
                if (a) {
                  if (e.readOnly !== void 0) {
                    let g = o;
                    if (typeof e.readOnly != "boolean")
                      return (
                        (Q.errors = [
                          {
                            instancePath: t + "/readOnly",
                            schemaPath: "#/properties/readOnly/type",
                            keyword: "type",
                            params: { type: "boolean" },
                            message: "must be boolean",
                          },
                        ]),
                        !1
                      );
                    var a = g === o;
                  } else var a = !0;
                  if (a) {
                    if (e.examples !== void 0) {
                      let g = o;
                      if (o === g && !Array.isArray(e.examples))
                        return (
                          (Q.errors = [
                            {
                              instancePath: t + "/examples",
                              schemaPath: "#/properties/examples/type",
                              keyword: "type",
                              params: { type: "array" },
                              message: "must be array",
                            },
                          ]),
                          !1
                        );
                      var a = g === o;
                    } else var a = !0;
                    if (a) {
                      if (e.multipleOf !== void 0) {
                        let g = e.multipleOf,
                          m = o;
                        if (o === m)
                          if (typeof g == "number" && isFinite(g)) {
                            if (g <= 0 || isNaN(g))
                              return (
                                (Q.errors = [
                                  {
                                    instancePath: t + "/multipleOf",
                                    schemaPath: "#/properties/multipleOf/exclusiveMinimum",
                                    keyword: "exclusiveMinimum",
                                    params: { comparison: ">", limit: 0 },
                                    message: "must be > 0",
                                  },
                                ]),
                                !1
                              );
                          } else
                            return (
                              (Q.errors = [
                                {
                                  instancePath: t + "/multipleOf",
                                  schemaPath: "#/properties/multipleOf/type",
                                  keyword: "type",
                                  params: { type: "number" },
                                  message: "must be number",
                                },
                              ]),
                              !1
                            );
                        var a = m === o;
                      } else var a = !0;
                      if (a) {
                        if (e.maximum !== void 0) {
                          let g = e.maximum,
                            m = o;
                          if (!(typeof g == "number" && isFinite(g)))
                            return (
                              (Q.errors = [
                                {
                                  instancePath: t + "/maximum",
                                  schemaPath: "#/properties/maximum/type",
                                  keyword: "type",
                                  params: { type: "number" },
                                  message: "must be number",
                                },
                              ]),
                              !1
                            );
                          var a = m === o;
                        } else var a = !0;
                        if (a) {
                          if (e.exclusiveMaximum !== void 0) {
                            let g = e.exclusiveMaximum,
                              m = o;
                            if (!(typeof g == "number" && isFinite(g)))
                              return (
                                (Q.errors = [
                                  {
                                    instancePath: t + "/exclusiveMaximum",
                                    schemaPath: "#/properties/exclusiveMaximum/type",
                                    keyword: "type",
                                    params: { type: "number" },
                                    message: "must be number",
                                  },
                                ]),
                                !1
                              );
                            var a = m === o;
                          } else var a = !0;
                          if (a) {
                            if (e.minimum !== void 0) {
                              let g = e.minimum,
                                m = o;
                              if (!(typeof g == "number" && isFinite(g)))
                                return (
                                  (Q.errors = [
                                    {
                                      instancePath: t + "/minimum",
                                      schemaPath: "#/properties/minimum/type",
                                      keyword: "type",
                                      params: { type: "number" },
                                      message: "must be number",
                                    },
                                  ]),
                                  !1
                                );
                              var a = m === o;
                            } else var a = !0;
                            if (a) {
                              if (e.exclusiveMinimum !== void 0) {
                                let g = e.exclusiveMinimum,
                                  m = o;
                                if (!(typeof g == "number" && isFinite(g)))
                                  return (
                                    (Q.errors = [
                                      {
                                        instancePath: t + "/exclusiveMinimum",
                                        schemaPath: "#/properties/exclusiveMinimum/type",
                                        keyword: "type",
                                        params: { type: "number" },
                                        message: "must be number",
                                      },
                                    ]),
                                    !1
                                  );
                                var a = m === o;
                              } else var a = !0;
                              if (a) {
                                if (e.maxLength !== void 0) {
                                  let g = e.maxLength,
                                    m = o,
                                    T = o;
                                  if (
                                    !(typeof g == "number" && !(g % 1) && !isNaN(g) && isFinite(g))
                                  )
                                    return (
                                      (Q.errors = [
                                        {
                                          instancePath: t + "/maxLength",
                                          schemaPath: "#/definitions/nonNegativeInteger/type",
                                          keyword: "type",
                                          params: { type: "integer" },
                                          message: "must be integer",
                                        },
                                      ]),
                                      !1
                                    );
                                  if (
                                    o === T &&
                                    typeof g == "number" &&
                                    isFinite(g) &&
                                    (g < 0 || isNaN(g))
                                  )
                                    return (
                                      (Q.errors = [
                                        {
                                          instancePath: t + "/maxLength",
                                          schemaPath: "#/definitions/nonNegativeInteger/minimum",
                                          keyword: "minimum",
                                          params: { comparison: ">=", limit: 0 },
                                          message: "must be >= 0",
                                        },
                                      ]),
                                      !1
                                    );
                                  var a = m === o;
                                } else var a = !0;
                                if (a) {
                                  if (e.minLength !== void 0) {
                                    let g = o;
                                    sn(e.minLength, {
                                      instancePath: t + "/minLength",
                                      parentData: e,
                                      parentDataProperty: "minLength",
                                      rootData: s,
                                    }) ||
                                      ((i = i === null ? sn.errors : i.concat(sn.errors)),
                                      (o = i.length));
                                    var a = g === o;
                                  } else var a = !0;
                                  if (a) {
                                    if (e.pattern !== void 0) {
                                      let g = e.pattern,
                                        m = o;
                                      if (o === m && o === m)
                                        if (typeof g == "string") {
                                          if (!j1(g))
                                            return (
                                              (Q.errors = [
                                                {
                                                  instancePath: t + "/pattern",
                                                  schemaPath: "#/properties/pattern/format",
                                                  keyword: "format",
                                                  params: { format: "regex" },
                                                  message: 'must match format "regex"',
                                                },
                                              ]),
                                              !1
                                            );
                                        } else
                                          return (
                                            (Q.errors = [
                                              {
                                                instancePath: t + "/pattern",
                                                schemaPath: "#/properties/pattern/type",
                                                keyword: "type",
                                                params: { type: "string" },
                                                message: "must be string",
                                              },
                                            ]),
                                            !1
                                          );
                                      var a = m === o;
                                    } else var a = !0;
                                    if (a) {
                                      if (e.additionalItems !== void 0) {
                                        let g = o;
                                        Q(e.additionalItems, {
                                          instancePath: t + "/additionalItems",
                                          parentData: e,
                                          parentDataProperty: "additionalItems",
                                          rootData: s,
                                        }) ||
                                          ((i = i === null ? Q.errors : i.concat(Q.errors)),
                                          (o = i.length));
                                        var a = g === o;
                                      } else var a = !0;
                                      if (a) {
                                        if (e.items !== void 0) {
                                          let g = e.items,
                                            m = o,
                                            T = o,
                                            N = !1,
                                            w = o;
                                          Q(g, {
                                            instancePath: t + "/items",
                                            parentData: e,
                                            parentDataProperty: "items",
                                            rootData: s,
                                          }) ||
                                            ((i = i === null ? Q.errors : i.concat(Q.errors)),
                                            (o = i.length));
                                          var u = w === o;
                                          if (((N = N || u), !N)) {
                                            let D = o;
                                            Sr(g, {
                                              instancePath: t + "/items",
                                              parentData: e,
                                              parentDataProperty: "items",
                                              rootData: s,
                                            }) ||
                                              ((i = i === null ? Sr.errors : i.concat(Sr.errors)),
                                              (o = i.length));
                                            var u = D === o;
                                            N = N || u;
                                          }
                                          if (N)
                                            (o = T),
                                              i !== null && (T ? (i.length = T) : (i = null));
                                          else {
                                            let D = {
                                              instancePath: t + "/items",
                                              schemaPath: "#/properties/items/anyOf",
                                              keyword: "anyOf",
                                              params: {},
                                              message: "must match a schema in anyOf",
                                            };
                                            return (
                                              i === null ? (i = [D]) : i.push(D),
                                              o++,
                                              (Q.errors = i),
                                              !1
                                            );
                                          }
                                          var a = m === o;
                                        } else var a = !0;
                                        if (a) {
                                          if (e.maxItems !== void 0) {
                                            let g = e.maxItems,
                                              m = o,
                                              T = o;
                                            if (
                                              !(
                                                typeof g == "number" &&
                                                !(g % 1) &&
                                                !isNaN(g) &&
                                                isFinite(g)
                                              )
                                            )
                                              return (
                                                (Q.errors = [
                                                  {
                                                    instancePath: t + "/maxItems",
                                                    schemaPath:
                                                      "#/definitions/nonNegativeInteger/type",
                                                    keyword: "type",
                                                    params: { type: "integer" },
                                                    message: "must be integer",
                                                  },
                                                ]),
                                                !1
                                              );
                                            if (
                                              o === T &&
                                              typeof g == "number" &&
                                              isFinite(g) &&
                                              (g < 0 || isNaN(g))
                                            )
                                              return (
                                                (Q.errors = [
                                                  {
                                                    instancePath: t + "/maxItems",
                                                    schemaPath:
                                                      "#/definitions/nonNegativeInteger/minimum",
                                                    keyword: "minimum",
                                                    params: { comparison: ">=", limit: 0 },
                                                    message: "must be >= 0",
                                                  },
                                                ]),
                                                !1
                                              );
                                            var a = m === o;
                                          } else var a = !0;
                                          if (a) {
                                            if (e.minItems !== void 0) {
                                              let g = o;
                                              sn(e.minItems, {
                                                instancePath: t + "/minItems",
                                                parentData: e,
                                                parentDataProperty: "minItems",
                                                rootData: s,
                                              }) ||
                                                ((i = i === null ? sn.errors : i.concat(sn.errors)),
                                                (o = i.length));
                                              var a = g === o;
                                            } else var a = !0;
                                            if (a) {
                                              if (e.uniqueItems !== void 0) {
                                                let g = o;
                                                if (typeof e.uniqueItems != "boolean")
                                                  return (
                                                    (Q.errors = [
                                                      {
                                                        instancePath: t + "/uniqueItems",
                                                        schemaPath: "#/properties/uniqueItems/type",
                                                        keyword: "type",
                                                        params: { type: "boolean" },
                                                        message: "must be boolean",
                                                      },
                                                    ]),
                                                    !1
                                                  );
                                                var a = g === o;
                                              } else var a = !0;
                                              if (a) {
                                                if (e.contains !== void 0) {
                                                  let g = o;
                                                  Q(e.contains, {
                                                    instancePath: t + "/contains",
                                                    parentData: e,
                                                    parentDataProperty: "contains",
                                                    rootData: s,
                                                  }) ||
                                                    ((i =
                                                      i === null ? Q.errors : i.concat(Q.errors)),
                                                    (o = i.length));
                                                  var a = g === o;
                                                } else var a = !0;
                                                if (a) {
                                                  if (e.maxProperties !== void 0) {
                                                    let g = e.maxProperties,
                                                      m = o,
                                                      T = o;
                                                    if (
                                                      !(
                                                        typeof g == "number" &&
                                                        !(g % 1) &&
                                                        !isNaN(g) &&
                                                        isFinite(g)
                                                      )
                                                    )
                                                      return (
                                                        (Q.errors = [
                                                          {
                                                            instancePath: t + "/maxProperties",
                                                            schemaPath:
                                                              "#/definitions/nonNegativeInteger/type",
                                                            keyword: "type",
                                                            params: { type: "integer" },
                                                            message: "must be integer",
                                                          },
                                                        ]),
                                                        !1
                                                      );
                                                    if (
                                                      o === T &&
                                                      typeof g == "number" &&
                                                      isFinite(g) &&
                                                      (g < 0 || isNaN(g))
                                                    )
                                                      return (
                                                        (Q.errors = [
                                                          {
                                                            instancePath: t + "/maxProperties",
                                                            schemaPath:
                                                              "#/definitions/nonNegativeInteger/minimum",
                                                            keyword: "minimum",
                                                            params: { comparison: ">=", limit: 0 },
                                                            message: "must be >= 0",
                                                          },
                                                        ]),
                                                        !1
                                                      );
                                                    var a = m === o;
                                                  } else var a = !0;
                                                  if (a) {
                                                    if (e.minProperties !== void 0) {
                                                      let g = o;
                                                      sn(e.minProperties, {
                                                        instancePath: t + "/minProperties",
                                                        parentData: e,
                                                        parentDataProperty: "minProperties",
                                                        rootData: s,
                                                      }) ||
                                                        ((i =
                                                          i === null
                                                            ? sn.errors
                                                            : i.concat(sn.errors)),
                                                        (o = i.length));
                                                      var a = g === o;
                                                    } else var a = !0;
                                                    if (a) {
                                                      if (e.required !== void 0) {
                                                        let g = e.required,
                                                          m = o;
                                                        if (o === o)
                                                          if (Array.isArray(g)) {
                                                            var l = !0;
                                                            let w = g.length;
                                                            for (let $ = 0; $ < w; $++) {
                                                              let D = o;
                                                              if (typeof g[$] != "string")
                                                                return (
                                                                  (Q.errors = [
                                                                    {
                                                                      instancePath:
                                                                        t + "/required/" + $,
                                                                      schemaPath:
                                                                        "#/definitions/stringArray/items/type",
                                                                      keyword: "type",
                                                                      params: { type: "string" },
                                                                      message: "must be string",
                                                                    },
                                                                  ]),
                                                                  !1
                                                                );
                                                              var l = D === o;
                                                              if (!l) break;
                                                            }
                                                            if (l) {
                                                              let $ = g.length,
                                                                D;
                                                              if ($ > 1) {
                                                                let v = {};
                                                                for (; $--; ) {
                                                                  let M = g[$];
                                                                  if (typeof M == "string") {
                                                                    if (typeof v[M] == "number") {
                                                                      return (
                                                                        (D = v[M]),
                                                                        (Q.errors = [
                                                                          {
                                                                            instancePath:
                                                                              t + "/required",
                                                                            schemaPath:
                                                                              "#/definitions/stringArray/uniqueItems",
                                                                            keyword: "uniqueItems",
                                                                            params: { i: $, j: D },
                                                                            message:
                                                                              "must NOT have duplicate items (items ## " +
                                                                              D +
                                                                              " and " +
                                                                              $ +
                                                                              " are identical)",
                                                                          },
                                                                        ]),
                                                                        !1
                                                                      );
                                                                      break;
                                                                    }
                                                                    v[M] = $;
                                                                  }
                                                                }
                                                              }
                                                            }
                                                          } else
                                                            return (
                                                              (Q.errors = [
                                                                {
                                                                  instancePath: t + "/required",
                                                                  schemaPath:
                                                                    "#/definitions/stringArray/type",
                                                                  keyword: "type",
                                                                  params: { type: "array" },
                                                                  message: "must be array",
                                                                },
                                                              ]),
                                                              !1
                                                            );
                                                        var a = m === o;
                                                      } else var a = !0;
                                                      if (a) {
                                                        if (e.additionalProperties !== void 0) {
                                                          let g = o;
                                                          Q(e.additionalProperties, {
                                                            instancePath:
                                                              t + "/additionalProperties",
                                                            parentData: e,
                                                            parentDataProperty:
                                                              "additionalProperties",
                                                            rootData: s,
                                                          }) ||
                                                            ((i =
                                                              i === null
                                                                ? Q.errors
                                                                : i.concat(Q.errors)),
                                                            (o = i.length));
                                                          var a = g === o;
                                                        } else var a = !0;
                                                        if (a) {
                                                          if (e.definitions !== void 0) {
                                                            let g = e.definitions,
                                                              m = o;
                                                            if (o === m)
                                                              if (
                                                                g &&
                                                                typeof g == "object" &&
                                                                !Array.isArray(g)
                                                              )
                                                                for (let N in g) {
                                                                  let w = o;
                                                                  Q(g[N], {
                                                                    instancePath:
                                                                      t +
                                                                      "/definitions/" +
                                                                      N.replace(/~/g, "~0").replace(
                                                                        /\//g,
                                                                        "~1",
                                                                      ),
                                                                    parentData: g,
                                                                    parentDataProperty: N,
                                                                    rootData: s,
                                                                  }) ||
                                                                    ((i =
                                                                      i === null
                                                                        ? Q.errors
                                                                        : i.concat(Q.errors)),
                                                                    (o = i.length));
                                                                  var c = w === o;
                                                                  if (!c) break;
                                                                }
                                                              else
                                                                return (
                                                                  (Q.errors = [
                                                                    {
                                                                      instancePath:
                                                                        t + "/definitions",
                                                                      schemaPath:
                                                                        "#/properties/definitions/type",
                                                                      keyword: "type",
                                                                      params: { type: "object" },
                                                                      message: "must be object",
                                                                    },
                                                                  ]),
                                                                  !1
                                                                );
                                                            var a = m === o;
                                                          } else var a = !0;
                                                          if (a) {
                                                            if (e.properties !== void 0) {
                                                              let g = e.properties,
                                                                m = o;
                                                              if (o === m)
                                                                if (
                                                                  g &&
                                                                  typeof g == "object" &&
                                                                  !Array.isArray(g)
                                                                )
                                                                  for (let N in g) {
                                                                    let w = o;
                                                                    Q(g[N], {
                                                                      instancePath:
                                                                        t +
                                                                        "/properties/" +
                                                                        N.replace(
                                                                          /~/g,
                                                                          "~0",
                                                                        ).replace(/\//g, "~1"),
                                                                      parentData: g,
                                                                      parentDataProperty: N,
                                                                      rootData: s,
                                                                    }) ||
                                                                      ((i =
                                                                        i === null
                                                                          ? Q.errors
                                                                          : i.concat(Q.errors)),
                                                                      (o = i.length));
                                                                    var f = w === o;
                                                                    if (!f) break;
                                                                  }
                                                                else
                                                                  return (
                                                                    (Q.errors = [
                                                                      {
                                                                        instancePath:
                                                                          t + "/properties",
                                                                        schemaPath:
                                                                          "#/properties/properties/type",
                                                                        keyword: "type",
                                                                        params: { type: "object" },
                                                                        message: "must be object",
                                                                      },
                                                                    ]),
                                                                    !1
                                                                  );
                                                              var a = m === o;
                                                            } else var a = !0;
                                                            if (a) {
                                                              if (e.patternProperties !== void 0) {
                                                                let g = e.patternProperties,
                                                                  m = o;
                                                                if (o === m)
                                                                  if (
                                                                    g &&
                                                                    typeof g == "object" &&
                                                                    !Array.isArray(g)
                                                                  ) {
                                                                    for (let N in g) {
                                                                      let w = o;
                                                                      if (
                                                                        o === w &&
                                                                        typeof N == "string" &&
                                                                        !j1(N)
                                                                      ) {
                                                                        let $ = {
                                                                          instancePath:
                                                                            t +
                                                                            "/patternProperties",
                                                                          schemaPath:
                                                                            "#/properties/patternProperties/propertyNames/format",
                                                                          keyword: "format",
                                                                          params: {
                                                                            format: "regex",
                                                                          },
                                                                          message:
                                                                            'must match format "regex"',
                                                                          propertyName: N,
                                                                        };
                                                                        i === null
                                                                          ? (i = [$])
                                                                          : i.push($),
                                                                          o++;
                                                                      }
                                                                      var d = w === o;
                                                                      if (!d) {
                                                                        let $ = {
                                                                          instancePath:
                                                                            t +
                                                                            "/patternProperties",
                                                                          schemaPath:
                                                                            "#/properties/patternProperties/propertyNames",
                                                                          keyword: "propertyNames",
                                                                          params: {
                                                                            propertyName: N,
                                                                          },
                                                                          message:
                                                                            "property name must be valid",
                                                                        };
                                                                        return (
                                                                          i === null
                                                                            ? (i = [$])
                                                                            : i.push($),
                                                                          o++,
                                                                          (Q.errors = i),
                                                                          !1
                                                                        );
                                                                        break;
                                                                      }
                                                                    }
                                                                    if (d)
                                                                      for (let N in g) {
                                                                        let w = o;
                                                                        Q(g[N], {
                                                                          instancePath:
                                                                            t +
                                                                            "/patternProperties/" +
                                                                            N.replace(
                                                                              /~/g,
                                                                              "~0",
                                                                            ).replace(/\//g, "~1"),
                                                                          parentData: g,
                                                                          parentDataProperty: N,
                                                                          rootData: s,
                                                                        }) ||
                                                                          ((i =
                                                                            i === null
                                                                              ? Q.errors
                                                                              : i.concat(Q.errors)),
                                                                          (o = i.length));
                                                                        var h = w === o;
                                                                        if (!h) break;
                                                                      }
                                                                  } else
                                                                    return (
                                                                      (Q.errors = [
                                                                        {
                                                                          instancePath:
                                                                            t +
                                                                            "/patternProperties",
                                                                          schemaPath:
                                                                            "#/properties/patternProperties/type",
                                                                          keyword: "type",
                                                                          params: {
                                                                            type: "object",
                                                                          },
                                                                          message: "must be object",
                                                                        },
                                                                      ]),
                                                                      !1
                                                                    );
                                                                var a = m === o;
                                                              } else var a = !0;
                                                              if (a) {
                                                                if (e.dependencies !== void 0) {
                                                                  let g = e.dependencies,
                                                                    m = o;
                                                                  if (o === m)
                                                                    if (
                                                                      g &&
                                                                      typeof g == "object" &&
                                                                      !Array.isArray(g)
                                                                    )
                                                                      for (let N in g) {
                                                                        let w = g[N],
                                                                          $ = o,
                                                                          D = o,
                                                                          v = !1,
                                                                          M = o;
                                                                        Q(w, {
                                                                          instancePath:
                                                                            t +
                                                                            "/dependencies/" +
                                                                            N.replace(
                                                                              /~/g,
                                                                              "~0",
                                                                            ).replace(/\//g, "~1"),
                                                                          parentData: g,
                                                                          parentDataProperty: N,
                                                                          rootData: s,
                                                                        }) ||
                                                                          ((i =
                                                                            i === null
                                                                              ? Q.errors
                                                                              : i.concat(Q.errors)),
                                                                          (o = i.length));
                                                                        var p = M === o;
                                                                        if (((v = v || p), !v)) {
                                                                          let k = o;
                                                                          if (o === o)
                                                                            if (Array.isArray(w)) {
                                                                              var y = !0;
                                                                              let Z = w.length;
                                                                              for (
                                                                                let G = 0;
                                                                                G < Z;
                                                                                G++
                                                                              ) {
                                                                                let Y = o;
                                                                                if (
                                                                                  typeof w[G] !=
                                                                                  "string"
                                                                                ) {
                                                                                  let z = {
                                                                                    instancePath:
                                                                                      t +
                                                                                      "/dependencies/" +
                                                                                      N.replace(
                                                                                        /~/g,
                                                                                        "~0",
                                                                                      ).replace(
                                                                                        /\//g,
                                                                                        "~1",
                                                                                      ) +
                                                                                      "/" +
                                                                                      G,
                                                                                    schemaPath:
                                                                                      "#/definitions/stringArray/items/type",
                                                                                    keyword: "type",
                                                                                    params: {
                                                                                      type: "string",
                                                                                    },
                                                                                    message:
                                                                                      "must be string",
                                                                                  };
                                                                                  i === null
                                                                                    ? (i = [z])
                                                                                    : i.push(z),
                                                                                    o++;
                                                                                }
                                                                                var y = Y === o;
                                                                                if (!y) break;
                                                                              }
                                                                              if (y) {
                                                                                let G = w.length,
                                                                                  Y;
                                                                                if (G > 1) {
                                                                                  let U = {};
                                                                                  for (; G--; ) {
                                                                                    let z = w[G];
                                                                                    if (
                                                                                      typeof z ==
                                                                                      "string"
                                                                                    ) {
                                                                                      if (
                                                                                        typeof U[
                                                                                          z
                                                                                        ] ==
                                                                                        "number"
                                                                                      ) {
                                                                                        Y = U[z];
                                                                                        let oe = {
                                                                                          instancePath:
                                                                                            t +
                                                                                            "/dependencies/" +
                                                                                            N.replace(
                                                                                              /~/g,
                                                                                              "~0",
                                                                                            ).replace(
                                                                                              /\//g,
                                                                                              "~1",
                                                                                            ),
                                                                                          schemaPath:
                                                                                            "#/definitions/stringArray/uniqueItems",
                                                                                          keyword:
                                                                                            "uniqueItems",
                                                                                          params: {
                                                                                            i: G,
                                                                                            j: Y,
                                                                                          },
                                                                                          message:
                                                                                            "must NOT have duplicate items (items ## " +
                                                                                            Y +
                                                                                            " and " +
                                                                                            G +
                                                                                            " are identical)",
                                                                                        };
                                                                                        i === null
                                                                                          ? (i = [
                                                                                              oe,
                                                                                            ])
                                                                                          : i.push(
                                                                                              oe,
                                                                                            ),
                                                                                          o++;
                                                                                        break;
                                                                                      }
                                                                                      U[z] = G;
                                                                                    }
                                                                                  }
                                                                                }
                                                                              }
                                                                            } else {
                                                                              let Z = {
                                                                                instancePath:
                                                                                  t +
                                                                                  "/dependencies/" +
                                                                                  N.replace(
                                                                                    /~/g,
                                                                                    "~0",
                                                                                  ).replace(
                                                                                    /\//g,
                                                                                    "~1",
                                                                                  ),
                                                                                schemaPath:
                                                                                  "#/definitions/stringArray/type",
                                                                                keyword: "type",
                                                                                params: {
                                                                                  type: "array",
                                                                                },
                                                                                message:
                                                                                  "must be array",
                                                                              };
                                                                              i === null
                                                                                ? (i = [Z])
                                                                                : i.push(Z),
                                                                                o++;
                                                                            }
                                                                          var p = k === o;
                                                                          v = v || p;
                                                                        }
                                                                        if (v)
                                                                          (o = D),
                                                                            i !== null &&
                                                                              (D
                                                                                ? (i.length = D)
                                                                                : (i = null));
                                                                        else {
                                                                          let k = {
                                                                            instancePath:
                                                                              t +
                                                                              "/dependencies/" +
                                                                              N.replace(
                                                                                /~/g,
                                                                                "~0",
                                                                              ).replace(
                                                                                /\//g,
                                                                                "~1",
                                                                              ),
                                                                            schemaPath:
                                                                              "#/properties/dependencies/additionalProperties/anyOf",
                                                                            keyword: "anyOf",
                                                                            params: {},
                                                                            message:
                                                                              "must match a schema in anyOf",
                                                                          };
                                                                          return (
                                                                            i === null
                                                                              ? (i = [k])
                                                                              : i.push(k),
                                                                            o++,
                                                                            (Q.errors = i),
                                                                            !1
                                                                          );
                                                                        }
                                                                        var _ = $ === o;
                                                                        if (!_) break;
                                                                      }
                                                                    else
                                                                      return (
                                                                        (Q.errors = [
                                                                          {
                                                                            instancePath:
                                                                              t + "/dependencies",
                                                                            schemaPath:
                                                                              "#/properties/dependencies/type",
                                                                            keyword: "type",
                                                                            params: {
                                                                              type: "object",
                                                                            },
                                                                            message:
                                                                              "must be object",
                                                                          },
                                                                        ]),
                                                                        !1
                                                                      );
                                                                  var a = m === o;
                                                                } else var a = !0;
                                                                if (a) {
                                                                  if (e.propertyNames !== void 0) {
                                                                    let g = o;
                                                                    Q(e.propertyNames, {
                                                                      instancePath:
                                                                        t + "/propertyNames",
                                                                      parentData: e,
                                                                      parentDataProperty:
                                                                        "propertyNames",
                                                                      rootData: s,
                                                                    }) ||
                                                                      ((i =
                                                                        i === null
                                                                          ? Q.errors
                                                                          : i.concat(Q.errors)),
                                                                      (o = i.length));
                                                                    var a = g === o;
                                                                  } else var a = !0;
                                                                  if (a) {
                                                                    if (e.enum !== void 0) {
                                                                      let g = e.enum,
                                                                        m = o;
                                                                      if (o === m)
                                                                        if (Array.isArray(g)) {
                                                                          if (g.length < 1)
                                                                            return (
                                                                              (Q.errors = [
                                                                                {
                                                                                  instancePath:
                                                                                    t + "/enum",
                                                                                  schemaPath:
                                                                                    "#/properties/enum/minItems",
                                                                                  keyword:
                                                                                    "minItems",
                                                                                  params: {
                                                                                    limit: 1,
                                                                                  },
                                                                                  message:
                                                                                    "must NOT have fewer than 1 items",
                                                                                },
                                                                              ]),
                                                                              !1
                                                                            );
                                                                          {
                                                                            let N = g.length,
                                                                              w;
                                                                            if (N > 1) {
                                                                              e: for (; N--; )
                                                                                for (w = N; w--; )
                                                                                  if (
                                                                                    L1(g[N], g[w])
                                                                                  ) {
                                                                                    return (
                                                                                      (Q.errors = [
                                                                                        {
                                                                                          instancePath:
                                                                                            t +
                                                                                            "/enum",
                                                                                          schemaPath:
                                                                                            "#/properties/enum/uniqueItems",
                                                                                          keyword:
                                                                                            "uniqueItems",
                                                                                          params: {
                                                                                            i: N,
                                                                                            j: w,
                                                                                          },
                                                                                          message:
                                                                                            "must NOT have duplicate items (items ## " +
                                                                                            w +
                                                                                            " and " +
                                                                                            N +
                                                                                            " are identical)",
                                                                                        },
                                                                                      ]),
                                                                                      !1
                                                                                    );
                                                                                    break e;
                                                                                  }
                                                                            }
                                                                          }
                                                                        } else
                                                                          return (
                                                                            (Q.errors = [
                                                                              {
                                                                                instancePath:
                                                                                  t + "/enum",
                                                                                schemaPath:
                                                                                  "#/properties/enum/type",
                                                                                keyword: "type",
                                                                                params: {
                                                                                  type: "array",
                                                                                },
                                                                                message:
                                                                                  "must be array",
                                                                              },
                                                                            ]),
                                                                            !1
                                                                          );
                                                                      var a = m === o;
                                                                    } else var a = !0;
                                                                    if (a) {
                                                                      if (e.type !== void 0) {
                                                                        let g = e.type,
                                                                          m = o,
                                                                          T = o,
                                                                          N = !1,
                                                                          w = o;
                                                                        if (
                                                                          !(
                                                                            g === "array" ||
                                                                            g === "boolean" ||
                                                                            g === "integer" ||
                                                                            g === "null" ||
                                                                            g === "number" ||
                                                                            g === "object" ||
                                                                            g === "string"
                                                                          )
                                                                        ) {
                                                                          let D = {
                                                                            instancePath:
                                                                              t + "/type",
                                                                            schemaPath:
                                                                              "#/definitions/simpleTypes/enum",
                                                                            keyword: "enum",
                                                                            params: {
                                                                              allowedValues:
                                                                                D1.enum,
                                                                            },
                                                                            message:
                                                                              "must be equal to one of the allowed values",
                                                                          };
                                                                          i === null
                                                                            ? (i = [D])
                                                                            : i.push(D),
                                                                            o++;
                                                                        }
                                                                        var S = w === o;
                                                                        if (((N = N || S), !N)) {
                                                                          let D = o;
                                                                          if (o === D)
                                                                            if (Array.isArray(g))
                                                                              if (g.length < 1) {
                                                                                let M = {
                                                                                  instancePath:
                                                                                    t + "/type",
                                                                                  schemaPath:
                                                                                    "#/properties/type/anyOf/1/minItems",
                                                                                  keyword:
                                                                                    "minItems",
                                                                                  params: {
                                                                                    limit: 1,
                                                                                  },
                                                                                  message:
                                                                                    "must NOT have fewer than 1 items",
                                                                                };
                                                                                i === null
                                                                                  ? (i = [M])
                                                                                  : i.push(M),
                                                                                  o++;
                                                                              } else {
                                                                                var E = !0;
                                                                                let M = g.length;
                                                                                for (
                                                                                  let k = 0;
                                                                                  k < M;
                                                                                  k++
                                                                                ) {
                                                                                  let x = g[k],
                                                                                    ie = o;
                                                                                  if (
                                                                                    !(
                                                                                      x ===
                                                                                        "array" ||
                                                                                      x ===
                                                                                        "boolean" ||
                                                                                      x ===
                                                                                        "integer" ||
                                                                                      x ===
                                                                                        "null" ||
                                                                                      x ===
                                                                                        "number" ||
                                                                                      x ===
                                                                                        "object" ||
                                                                                      x === "string"
                                                                                    )
                                                                                  ) {
                                                                                    let G = {
                                                                                      instancePath:
                                                                                        t +
                                                                                        "/type/" +
                                                                                        k,
                                                                                      schemaPath:
                                                                                        "#/definitions/simpleTypes/enum",
                                                                                      keyword:
                                                                                        "enum",
                                                                                      params: {
                                                                                        allowedValues:
                                                                                          D1.enum,
                                                                                      },
                                                                                      message:
                                                                                        "must be equal to one of the allowed values",
                                                                                    };
                                                                                    i === null
                                                                                      ? (i = [G])
                                                                                      : i.push(G),
                                                                                      o++;
                                                                                  }
                                                                                  var E = ie === o;
                                                                                  if (!E) break;
                                                                                }
                                                                                if (E) {
                                                                                  let k = g.length,
                                                                                    x;
                                                                                  if (k > 1) {
                                                                                    e: for (; k--; )
                                                                                      for (
                                                                                        x = k;
                                                                                        x--;

                                                                                      )
                                                                                        if (
                                                                                          L1(
                                                                                            g[k],
                                                                                            g[x],
                                                                                          )
                                                                                        ) {
                                                                                          let ie = {
                                                                                            instancePath:
                                                                                              t +
                                                                                              "/type",
                                                                                            schemaPath:
                                                                                              "#/properties/type/anyOf/1/uniqueItems",
                                                                                            keyword:
                                                                                              "uniqueItems",
                                                                                            params:
                                                                                              {
                                                                                                i: k,
                                                                                                j: x,
                                                                                              },
                                                                                            message:
                                                                                              "must NOT have duplicate items (items ## " +
                                                                                              x +
                                                                                              " and " +
                                                                                              k +
                                                                                              " are identical)",
                                                                                          };
                                                                                          i === null
                                                                                            ? (i = [
                                                                                                ie,
                                                                                              ])
                                                                                            : i.push(
                                                                                                ie,
                                                                                              ),
                                                                                            o++;
                                                                                          break e;
                                                                                        }
                                                                                  }
                                                                                }
                                                                              }
                                                                            else {
                                                                              let M = {
                                                                                instancePath:
                                                                                  t + "/type",
                                                                                schemaPath:
                                                                                  "#/properties/type/anyOf/1/type",
                                                                                keyword: "type",
                                                                                params: {
                                                                                  type: "array",
                                                                                },
                                                                                message:
                                                                                  "must be array",
                                                                              };
                                                                              i === null
                                                                                ? (i = [M])
                                                                                : i.push(M),
                                                                                o++;
                                                                            }
                                                                          var S = D === o;
                                                                          N = N || S;
                                                                        }
                                                                        if (N)
                                                                          (o = T),
                                                                            i !== null &&
                                                                              (T
                                                                                ? (i.length = T)
                                                                                : (i = null));
                                                                        else {
                                                                          let D = {
                                                                            instancePath:
                                                                              t + "/type",
                                                                            schemaPath:
                                                                              "#/properties/type/anyOf",
                                                                            keyword: "anyOf",
                                                                            params: {},
                                                                            message:
                                                                              "must match a schema in anyOf",
                                                                          };
                                                                          return (
                                                                            i === null
                                                                              ? (i = [D])
                                                                              : i.push(D),
                                                                            o++,
                                                                            (Q.errors = i),
                                                                            !1
                                                                          );
                                                                        }
                                                                        var a = m === o;
                                                                      } else var a = !0;
                                                                      if (a) {
                                                                        if (e.format !== void 0) {
                                                                          let g = o;
                                                                          if (
                                                                            typeof e.format !=
                                                                            "string"
                                                                          )
                                                                            return (
                                                                              (Q.errors = [
                                                                                {
                                                                                  instancePath:
                                                                                    t + "/format",
                                                                                  schemaPath:
                                                                                    "#/properties/format/type",
                                                                                  keyword: "type",
                                                                                  params: {
                                                                                    type: "string",
                                                                                  },
                                                                                  message:
                                                                                    "must be string",
                                                                                },
                                                                              ]),
                                                                              !1
                                                                            );
                                                                          var a = g === o;
                                                                        } else var a = !0;
                                                                        if (a) {
                                                                          if (
                                                                            e.contentMediaType !==
                                                                            void 0
                                                                          ) {
                                                                            let g = o;
                                                                            if (
                                                                              typeof e.contentMediaType !=
                                                                              "string"
                                                                            )
                                                                              return (
                                                                                (Q.errors = [
                                                                                  {
                                                                                    instancePath:
                                                                                      t +
                                                                                      "/contentMediaType",
                                                                                    schemaPath:
                                                                                      "#/properties/contentMediaType/type",
                                                                                    keyword: "type",
                                                                                    params: {
                                                                                      type: "string",
                                                                                    },
                                                                                    message:
                                                                                      "must be string",
                                                                                  },
                                                                                ]),
                                                                                !1
                                                                              );
                                                                            var a = g === o;
                                                                          } else var a = !0;
                                                                          if (a) {
                                                                            if (
                                                                              e.contentEncoding !==
                                                                              void 0
                                                                            ) {
                                                                              let g = o;
                                                                              if (
                                                                                typeof e.contentEncoding !=
                                                                                "string"
                                                                              )
                                                                                return (
                                                                                  (Q.errors = [
                                                                                    {
                                                                                      instancePath:
                                                                                        t +
                                                                                        "/contentEncoding",
                                                                                      schemaPath:
                                                                                        "#/properties/contentEncoding/type",
                                                                                      keyword:
                                                                                        "type",
                                                                                      params: {
                                                                                        type: "string",
                                                                                      },
                                                                                      message:
                                                                                        "must be string",
                                                                                    },
                                                                                  ]),
                                                                                  !1
                                                                                );
                                                                              var a = g === o;
                                                                            } else var a = !0;
                                                                            if (a) {
                                                                              if (e.if !== void 0) {
                                                                                let g = o;
                                                                                Q(e.if, {
                                                                                  instancePath:
                                                                                    t + "/if",
                                                                                  parentData: e,
                                                                                  parentDataProperty:
                                                                                    "if",
                                                                                  rootData: s,
                                                                                }) ||
                                                                                  ((i =
                                                                                    i === null
                                                                                      ? Q.errors
                                                                                      : i.concat(
                                                                                          Q.errors,
                                                                                        )),
                                                                                  (o = i.length));
                                                                                var a = g === o;
                                                                              } else var a = !0;
                                                                              if (a) {
                                                                                if (
                                                                                  e.then !== void 0
                                                                                ) {
                                                                                  let g = o;
                                                                                  Q(e.then, {
                                                                                    instancePath:
                                                                                      t + "/then",
                                                                                    parentData: e,
                                                                                    parentDataProperty:
                                                                                      "then",
                                                                                    rootData: s,
                                                                                  }) ||
                                                                                    ((i =
                                                                                      i === null
                                                                                        ? Q.errors
                                                                                        : i.concat(
                                                                                            Q.errors,
                                                                                          )),
                                                                                    (o = i.length));
                                                                                  var a = g === o;
                                                                                } else var a = !0;
                                                                                if (a) {
                                                                                  if (
                                                                                    e.else !==
                                                                                    void 0
                                                                                  ) {
                                                                                    let g = o;
                                                                                    Q(e.else, {
                                                                                      instancePath:
                                                                                        t + "/else",
                                                                                      parentData: e,
                                                                                      parentDataProperty:
                                                                                        "else",
                                                                                      rootData: s,
                                                                                    }) ||
                                                                                      ((i =
                                                                                        i === null
                                                                                          ? Q.errors
                                                                                          : i.concat(
                                                                                              Q.errors,
                                                                                            )),
                                                                                      (o =
                                                                                        i.length));
                                                                                    var a = g === o;
                                                                                  } else var a = !0;
                                                                                  if (a) {
                                                                                    if (
                                                                                      e.allOf !==
                                                                                      void 0
                                                                                    ) {
                                                                                      let g = o;
                                                                                      Sr(e.allOf, {
                                                                                        instancePath:
                                                                                          t +
                                                                                          "/allOf",
                                                                                        parentData:
                                                                                          e,
                                                                                        parentDataProperty:
                                                                                          "allOf",
                                                                                        rootData: s,
                                                                                      }) ||
                                                                                        ((i =
                                                                                          i === null
                                                                                            ? Sr.errors
                                                                                            : i.concat(
                                                                                                Sr.errors,
                                                                                              )),
                                                                                        (o =
                                                                                          i.length));
                                                                                      var a =
                                                                                        g === o;
                                                                                    } else
                                                                                      var a = !0;
                                                                                    if (a) {
                                                                                      if (
                                                                                        e.anyOf !==
                                                                                        void 0
                                                                                      ) {
                                                                                        let g = o;
                                                                                        Sr(
                                                                                          e.anyOf,
                                                                                          {
                                                                                            instancePath:
                                                                                              t +
                                                                                              "/anyOf",
                                                                                            parentData:
                                                                                              e,
                                                                                            parentDataProperty:
                                                                                              "anyOf",
                                                                                            rootData:
                                                                                              s,
                                                                                          },
                                                                                        ) ||
                                                                                          ((i =
                                                                                            i ===
                                                                                            null
                                                                                              ? Sr.errors
                                                                                              : i.concat(
                                                                                                  Sr.errors,
                                                                                                )),
                                                                                          (o =
                                                                                            i.length));
                                                                                        var a =
                                                                                          g === o;
                                                                                      } else
                                                                                        var a = !0;
                                                                                      if (a) {
                                                                                        if (
                                                                                          e.oneOf !==
                                                                                          void 0
                                                                                        ) {
                                                                                          let g = o;
                                                                                          Sr(
                                                                                            e.oneOf,
                                                                                            {
                                                                                              instancePath:
                                                                                                t +
                                                                                                "/oneOf",
                                                                                              parentData:
                                                                                                e,
                                                                                              parentDataProperty:
                                                                                                "oneOf",
                                                                                              rootData:
                                                                                                s,
                                                                                            },
                                                                                          ) ||
                                                                                            ((i =
                                                                                              i ===
                                                                                              null
                                                                                                ? Sr.errors
                                                                                                : i.concat(
                                                                                                    Sr.errors,
                                                                                                  )),
                                                                                            (o =
                                                                                              i.length));
                                                                                          var a =
                                                                                            g === o;
                                                                                        } else
                                                                                          var a =
                                                                                            !0;
                                                                                        if (a)
                                                                                          if (
                                                                                            e.not !==
                                                                                            void 0
                                                                                          ) {
                                                                                            let g =
                                                                                              o;
                                                                                            Q(
                                                                                              e.not,
                                                                                              {
                                                                                                instancePath:
                                                                                                  t +
                                                                                                  "/not",
                                                                                                parentData:
                                                                                                  e,
                                                                                                parentDataProperty:
                                                                                                  "not",
                                                                                                rootData:
                                                                                                  s,
                                                                                              },
                                                                                            ) ||
                                                                                              ((i =
                                                                                                i ===
                                                                                                null
                                                                                                  ? Q.errors
                                                                                                  : i.concat(
                                                                                                      Q.errors,
                                                                                                    )),
                                                                                              (o =
                                                                                                i.length));
                                                                                            var a =
                                                                                              g ===
                                                                                              o;
                                                                                          } else
                                                                                            var a =
                                                                                              !0;
                                                                                      }
                                                                                    }
                                                                                  }
                                                                                }
                                                                              }
                                                                            }
                                                                          }
                                                                        }
                                                                      }
                                                                    }
                                                                  }
                                                                }
                                                              }
                                                            }
                                                          }
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    return (Q.errors = i), o === 0;
  }
});
var Ng = b((Hoe, F1) => {
  "use strict";
  var Pg = class extends Error {
      constructor(t, r) {
        super(),
          (this.name = "JsonSchemaMergeError"),
          (this.code = "JSON_SCHEMA_MERGE_ERROR"),
          (this.message = `Failed to merge "${t}" keyword schemas.`),
          (this.schemas = r);
      }
    },
    $g = class extends Error {
      constructor(t, r) {
        super(),
          (this.name = "JsonSchemaMergeError"),
          (this.code = "JSON_SCHEMA_MERGE_ERROR"),
          (this.message = `Resolver for "${t}" keyword not found.`),
          (this.schemas = r);
      }
    },
    Og = class extends Error {
      constructor(t) {
        super(),
          (this.name = "JsonSchemaMergeError"),
          (this.code = "JSON_SCHEMA_MERGE_ERROR"),
          (this.message = `Invalid "onConflict" option: "${t}".`);
      }
    };
  F1.exports = { MergeError: Pg, ResolverNotFoundError: $g, InvalidOnConflictOptionError: Og };
});
var V1 = b((Boe, z1) => {
  "use strict";
  var yJ = qs(),
    { MergeError: Ag } = Ng();
  function M1(e) {
    let t = e[0];
    for (let r = 1; r < e.length; r++) t = t.filter((n) => e[r].includes(n));
    return t;
  }
  function gJ(e, t, r) {
    let n = M1(t);
    if (n.length === 0) throw new Ag(e, t);
    r[e] = n;
  }
  function _J(e, t, r) {
    for (let s = 0; s < t.length; s++) Array.isArray(t[s]) || (t[s] = [t[s]]);
    let n = M1(t);
    if (n.length === 0) throw new Ag(e, t);
    n.length === 1 ? (r[e] = n[0]) : (r[e] = n);
  }
  function SJ(e, t, r) {
    let n = [];
    for (let s of t) for (let i of s) n.includes(i) || n.push(i);
    r[e] = n;
  }
  function vJ(e, t, r) {
    r[e] = Math.min(...t);
  }
  function bJ(e, t, r) {
    r[e] = Math.max(...t);
  }
  function wJ(e, t, r) {
    let n = (a, u) => (u ? n(u, a % u) : a),
      s = (a, u) => (a * u) / n(a, u),
      i = 1;
    for (let a of t) for (; (a * i) % 1 !== 0; ) i *= 10;
    let o = t[0] * i;
    for (let a of t) o = s(o, a * i);
    r[e] = o / i;
  }
  function EJ(e, t, r) {
    let n = t[0];
    for (let s = 1; s < t.length; s++) if (!yJ(t[s], n)) throw new Ag(e, t);
    r[e] = n;
  }
  function RJ() {}
  function TJ(e, t, r) {
    for (let n of t)
      if (n === !1) {
        r[e] = !1;
        return;
      }
    r[e] = !0;
  }
  function PJ(e, t, r) {
    for (let n of t)
      if (n === !0) {
        r[e] = !0;
        return;
      }
    r[e] = !1;
  }
  z1.exports = {
    arraysIntersection: gJ,
    hybridArraysIntersection: _J,
    arraysUnion: SJ,
    minNumber: vJ,
    maxNumber: bJ,
    commonMultiple: wJ,
    allEqual: EJ,
    booleanAnd: TJ,
    booleanOr: PJ,
    skip: RJ,
  };
});
var J1 = b((Koe, G1) => {
  "use strict";
  var $J = qs(),
    Rt = V1(),
    Cf = Ng(),
    B1 = {
      $id: Rt.skip,
      type: Rt.hybridArraysIntersection,
      enum: Rt.arraysIntersection,
      minLength: Rt.maxNumber,
      maxLength: Rt.minNumber,
      minimum: Rt.maxNumber,
      maximum: Rt.minNumber,
      multipleOf: Rt.commonMultiple,
      exclusiveMinimum: Rt.maxNumber,
      exclusiveMaximum: Rt.minNumber,
      minItems: Rt.maxNumber,
      maxItems: Rt.minNumber,
      maxProperties: Rt.minNumber,
      minProperties: Rt.maxNumber,
      const: Rt.allEqual,
      default: Rt.allEqual,
      format: Rt.allEqual,
      required: Rt.arraysUnion,
      properties: kJ,
      patternProperties: If,
      additionalProperties: Af,
      items: AJ,
      additionalItems: IJ,
      definitions: If,
      $defs: If,
      nullable: Rt.booleanAnd,
      oneOf: U1,
      anyOf: U1,
      allOf: Rt.arraysUnion,
      not: Af,
      if: DJ,
      then: Rt.skip,
      else: Rt.skip,
      dependencies: H1,
      dependentRequired: H1,
      dependentSchemas: If,
      propertyNames: Af,
      uniqueItems: Rt.booleanOr,
      contains: Af,
    };
  function Af(e, t, r, n, s) {
    r[e] = bn(t, s);
  }
  function OJ(e) {
    let t = [[]];
    for (let r of e) {
      let n = [];
      for (let s of t) for (let i of r) n.push([...s, i]);
      t = n;
    }
    return t;
  }
  function U1(e, t, r, n, s) {
    if (t.length === 1) {
      r[e] = t[0];
      return;
    }
    let i = OJ(t),
      o = [];
    for (let a of i)
      try {
        let u = bn(a, s);
        u !== void 0 && o.push(u);
      } catch (u) {
        if (u instanceof Cf.MergeError) continue;
        throw u;
      }
    r[e] = o;
  }
  function NJ(e, t) {
    let { items: r, additionalItems: n } = e;
    return Array.isArray(r) ? (t < r.length ? r[t] : n) : r !== void 0 ? r : n;
  }
  function AJ(e, t, r, n, s) {
    let i = 0;
    for (let a of t) Array.isArray(a) && (i = Math.max(i, a.length));
    if (i === 0) {
      r[e] = bn(t, s);
      return;
    }
    let o = [];
    for (let a = 0; a < i; a++) {
      let u = [];
      for (let l of n) {
        let c = NJ(l, a);
        c !== void 0 && u.push(c);
      }
      o[a] = bn(u, s);
    }
    r[e] = o;
  }
  function IJ(e, t, r, n, s) {
    let i = !1;
    for (let a of n)
      if (Array.isArray(a.items)) {
        i = !0;
        break;
      }
    if (!i) {
      r[e] = bn(t, s);
      return;
    }
    let o = [];
    for (let a of n) {
      let u = a.additionalItems;
      u === void 0 && !Array.isArray(a.items) && (u = a.items), u !== void 0 && o.push(u);
    }
    r[e] = bn(o, s);
  }
  function CJ(e, t) {
    let { properties: r, patternProperties: n, additionalProperties: s } = e;
    if (r?.[t] !== void 0) return r[t];
    for (let i of Object.keys(n ?? {})) if (new RegExp(i).test(t)) return n[i];
    return s;
  }
  function kJ(e, t, r, n, s) {
    let i = {};
    for (let a of n) {
      let u = a.properties ?? {};
      for (let l of Object.keys(u)) {
        if (i[l] !== void 0) continue;
        let c = u[l];
        i[l] = [c];
        for (let f of n) {
          if (a === f) continue;
          let d = CJ(f, l);
          d !== void 0 && i[l].push(d);
        }
      }
    }
    let o = {};
    for (let a of Object.keys(i)) {
      let u = i[a];
      o[a] = bn(u, s);
    }
    r[e] = o;
  }
  function If(e, t, r, n, s) {
    let i = {};
    for (let a of t) for (let u of Object.keys(a)) i[u] === void 0 && (i[u] = []), i[u].push(a[u]);
    let o = {};
    for (let a of Object.keys(i)) {
      let u = i[a],
        l = bn(u, s);
      o[a] = l;
    }
    r[e] = o;
  }
  function DJ(e, t, r, n, s) {
    for (let i = 0; i < n.length; i++) {
      let o = { if: n[i].if, then: n[i].then, else: n[i].else };
      if (o.if !== void 0) {
        if (r.if === void 0) {
          (r.if = o.if),
            o.then !== void 0 && (r.then = o.then),
            o.else !== void 0 && (r.else = o.else);
          continue;
        }
        r.then !== void 0 && (r.then = bn([r.then, o], s)),
          r.else !== void 0 && (r.else = bn([r.else, o], s));
      }
    }
  }
  function H1(e, t, r) {
    let n = {};
    for (let s of t)
      for (let i of Object.keys(s)) {
        n[i] === void 0 && (n[i] = []);
        let o = n[i];
        for (let a of s[i]) o.includes(a) || o.push(a);
      }
    r[e] = n;
  }
  function bn(e, t) {
    if (e.length === 0) return {};
    if (e.length === 1) return e[0];
    let r = {},
      n = {},
      s = !0;
    for (let i of e) {
      if (i === !1) return !1;
      if (i !== !0) {
        s = !1;
        for (let o of Object.keys(i)) n[o] === void 0 && (n[o] = []), n[o].push(i[o]);
      }
    }
    if (s) return !0;
    for (let i of Object.keys(n)) {
      let o = n[i];
      (t.resolvers[i] ?? t.defaultResolver)(i, o, r, e, t);
    }
    return r;
  }
  function K1(e, t, r, n, s) {
    let i = s.onConflict ?? "throw";
    if (t.length === 1 || i === "first") {
      r[e] = t[0];
      return;
    }
    let o = !0;
    for (let a = 1; a < t.length; a++)
      if (!$J(t[a], t[0])) {
        o = !1;
        break;
      }
    if (o) {
      r[e] = t[0];
      return;
    }
    if (i === "throw") throw new Cf.ResolverNotFoundError(e, t);
    if (i !== "skip") throw new Cf.InvalidOnConflictOptionError(i);
  }
  function qJ(e, t = {}) {
    return (
      t.defaultResolver === void 0 && (t.defaultResolver = K1),
      (t.resolvers = { ...B1, ...t.resolvers }),
      bn(e, t)
    );
  }
  G1.exports = { mergeSchemas: qJ, keywordsResolvers: B1, defaultResolver: K1, ...Cf };
});
var W1 = b((Goe, Q1) => {
  "use strict";
  var { mergeSchemas: jJ } = J1();
  function LJ(e) {
    return jJ(e, { onConflict: "skip" });
  }
  Q1.exports = LJ;
});
var Y1 = b((Joe, Ig) => {
  "use strict";
  function xJ(e, t, r, n) {
    let s = "";
    t.validatorSchemasIds.size > 0
      ? ((s += `const Validator = require('fast-json-stringify/lib/validator')
`),
        (s += `const validatorState = ${JSON.stringify(n.getState())}
`),
        (s += `const validator = Validator.restoreFromState(validatorState)
`))
      : (s += `const validator = null
`);
    let { schema: i, ...o } = r.getState();
    return `
  'use strict'

  const Serializer = require('fast-json-stringify/lib/serializer')
  const serializerState = ${JSON.stringify(o)}
  const serializer = Serializer.restoreFromState(serializerState)

  ${s}

  module.exports = ${e.toString()}(validator, serializer)`;
  }
  Ig.exports = xJ;
  Ig.exports.dependencies = { Serializer: pc(), Validator: wg() };
});
var oN = b((Qoe, Ao) => {
  "use strict";
  var { RefResolver: FJ } = VP(),
    MJ = pc(),
    zJ = wg(),
    Ni = k1(),
    X1 = x1(),
    VJ = W1(),
    UJ = /'/g,
    kf = 2e4,
    eN = "default",
    HJ = ["floor", "ceil", "round", "trunc"],
    tN = ["default", "json-stringify"],
    pu = 0;
  function Cg(e, t) {
    if (!X1(e)) {
      t ? (t = `"${t}" `) : (t = "");
      let r = X1.errors[0],
        n = new Error(`${t}schema is invalid: data${r.instancePath} ${r.message}`);
      throw ((n.errors = Cg.errors), n);
    }
  }
  function mu(e, t) {
    let r = t.schema.$ref,
      n = r.indexOf("#");
    n === -1 && (n = r.length);
    let s = r.slice(0, n) || t.schemaId,
      i = r.slice(n) || "#",
      o = e.refResolver.getSchema(s, i);
    if (o === null) throw new Error(`Cannot find reference "${r}"`);
    let a = new Ni(o, s, i);
    return o.$ref !== void 0 ? mu(e, a) : a;
  }
  function Df(e, t) {
    let r = e.refResolver.getSchema(t, "#");
    return new Ni(r, t, "#");
  }
  function Z1(e, t) {
    return e.$id && e.$id.charAt(0) !== "#" ? e.$id : t;
  }
  function kg(e, t) {
    Cg(e), (t = t || {});
    let r = {
        functions: [],
        functionsCounter: 0,
        functionsNamesBySchema: new Map(),
        options: t,
        refResolver: new FJ(),
        rootSchemaId: e.$id || `__fjs_root_${pu++}`,
        validatorSchemasIds: new Set(),
        mergedSchemasIds: new Map(),
      },
      n = Z1(e, r.rootSchemaId);
    if ((r.refResolver.hasSchema(n) || r.refResolver.addSchema(e, r.rootSchemaId), t.schema))
      for (let c in t.schema) {
        let f = t.schema[c],
          d = Z1(f, c);
        r.refResolver.hasSchema(d) || (Cg(f, c), r.refResolver.addSchema(f, c));
      }
    if (t.rounding && !HJ.includes(t.rounding))
      throw new Error(`Unsupported integer rounding method ${t.rounding}`);
    if (t.largeArrayMechanism)
      if (tN.includes(t.largeArrayMechanism)) eN = t.largeArrayMechanism;
      else throw new Error(`Unsupported large array mechanism ${t.largeArrayMechanism}`);
    if (t.largeArraySize)
      if (
        typeof t.largeArraySize == "string" &&
        Number.isFinite(Number.parseInt(t.largeArraySize, 10))
      )
        kf = Number.parseInt(t.largeArraySize, 10);
      else if (typeof t.largeArraySize == "number" && Number.isInteger(t.largeArraySize))
        kf = t.largeArraySize;
      else if (typeof t.largeArraySize == "bigint") kf = Number(t.largeArraySize);
      else
        throw new Error(
          `Unsupported large array size. Expected integer-like, got ${typeof t.largeArraySize} with value ${t.largeArraySize}`,
        );
    let s = new Ni(e, r.rootSchemaId),
      i = Fr(r, s, "input"),
      o = `
    const JSON_STR_BEGIN_OBJECT = '{'
    const JSON_STR_END_OBJECT = '}'
    const JSON_STR_BEGIN_ARRAY = '['
    const JSON_STR_END_ARRAY = ']'
    const JSON_STR_COMMA = ','
    const JSON_STR_COLONS = ':'
    const JSON_STR_QUOTE = '"'
    const JSON_STR_EMPTY_OBJECT = JSON_STR_BEGIN_OBJECT + JSON_STR_END_OBJECT
    const JSON_STR_EMPTY_ARRAY = JSON_STR_BEGIN_ARRAY + JSON_STR_END_ARRAY
    const JSON_STR_EMPTY_STRING = JSON_STR_QUOTE + JSON_STR_QUOTE
    const JSON_STR_NULL = 'null'
  `;
    i === "json += anonymous0(input)"
      ? (o += `
    ${r.functions.join(`
`)}
    const main = anonymous0
    return main
    `)
      : (o += `
    function main (input) {
      let json = ''
      ${i}
      return json
    }
    ${r.functions.join(`
`)}
    return main
    `);
    let a = new MJ(t),
      u = new zJ(t.ajv);
    for (let c of r.validatorSchemasIds) {
      let f = r.refResolver.getSchema(c);
      u.addSchema(f, c);
      let d = r.refResolver.getSchemaDependencies(c);
      for (let [h, p] of Object.entries(d)) u.addSchema(p, h);
    }
    if ((t.debugMode && (t.mode = "debug"), t.mode === "debug"))
      return {
        validator: u,
        serializer: a,
        code: `validator
serializer
${o}`,
        ajv: u.ajv,
      };
    let l = new Function("validator", "serializer", o);
    return t.mode === "standalone" ? Y1()(l, r, a, u) : l(u, a);
  }
  var BJ = [
      "properties",
      "required",
      "additionalProperties",
      "patternProperties",
      "maxProperties",
      "minProperties",
      "dependencies",
    ],
    KJ = ["items", "additionalItems", "maxItems", "minItems", "uniqueItems", "contains"],
    GJ = ["maxLength", "minLength", "pattern"],
    JJ = ["multipleOf", "maximum", "exclusiveMaximum", "minimum", "exclusiveMinimum"];
  function QJ(e) {
    for (var t of BJ) if (t in e) return "object";
    for (var t of KJ) if (t in e) return "array";
    for (var t of GJ) if (t in e) return "string";
    for (var t of JJ) if (t in e) return "number";
    return e.type;
  }
  function WJ(e, t, r) {
    let n = t.schema,
      s = Object.keys(n.properties || {}),
      i = `
    const propertiesKeys = ${JSON.stringify(s)}
    for (const [key, value] of Object.entries(obj)) {
      if (
        propertiesKeys.includes(key) ||
        value === undefined ||
        typeof value === 'function' ||
        typeof value === 'symbol'
      ) continue
  `,
      o = t.getPropertyLocation("patternProperties"),
      a = o.schema;
    if (a !== void 0)
      for (let c in a) {
        let f = o.getPropertyLocation(c);
        i += `
        if (/${c.replace(/\\*\//g, "\\/")}/.test(key)) {
          ${r}
          json += serializer.asString(key) + JSON_STR_COLONS
          ${Fr(e, f, "value")}
          continue
        }
      `;
      }
    let l = t.getPropertyLocation("additionalProperties").schema;
    if (l !== void 0)
      if (l === !0)
        i += `
        ${r}
        json += serializer.asString(key) + JSON_STR_COLONS + JSON.stringify(value)
      `;
      else {
        let c = t.getPropertyLocation("additionalProperties");
        i += `
        ${r}
        json += serializer.asString(key) + JSON_STR_COLONS
        ${Fr(e, c, "value")}
      `;
      }
    return (
      (i += `
    }
  `),
      i
    );
  }
  function YJ(e, t) {
    let r = t.schema,
      n = t.getPropertyLocation("properties"),
      s = r.required || [],
      i = Object.keys(r.properties || {}).sort((l, c) => {
        let f = s.includes(l),
          d = s.includes(c);
        return f === d ? 0 : f ? -1 : 1;
      }),
      o = s.includes(i[0]),
      a = `let value
`;
    for (let l of s)
      if (!i.includes(l)) {
        let c = JSON.stringify(l);
        a += `if (obj[${c}] === undefined) throw new Error('${c.replace(/'/g, "\\'")} is required!')
`;
      }
    a += `let json = JSON_STR_BEGIN_OBJECT
`;
    let u = "";
    o ||
      ((a += `let addComma = false
`),
      (u = "!addComma && (addComma = true) || (json += JSON_STR_COMMA)"));
    for (let l of i) {
      let c = n.getPropertyLocation(l);
      c.schema.$ref && (c = mu(e, c));
      let f = JSON.stringify(l),
        d = c.schema.default,
        h = s.includes(l);
      (a += `
      value = obj[${f}]
      if (value !== undefined) {
        ${u}
        json += ${JSON.stringify(f + ":")}
        ${Fr(e, c, "value")}
      }`),
        d !== void 0
          ? (a += ` else {
        ${u}
        json += ${JSON.stringify(f + ":" + JSON.stringify(d))}
      }
      `)
          : h
            ? (a += ` else {
        throw new Error('${f.replace(/'/g, "\\'")} is required!')
      }
      `)
            : (a += `
`),
        o && (u = "json += ','");
    }
    return (
      (r.patternProperties || r.additionalProperties) && (a += WJ(e, t, u)),
      (a += `
    return json + JSON_STR_END_OBJECT
  `),
      a
    );
  }
  function qf(e, t, r) {
    for (let o = 0; o < r.length; o++) {
      let a = r[o];
      a.schema.$ref && (r[o] = mu(e, a));
    }
    let n = [];
    for (let o of r) {
      let a = rN(e, o.schema, o.schemaId);
      delete a.$id, n.push(a);
    }
    let s = VJ(n),
      i = new Ni(s, t);
    return e.refResolver.addSchema(s, t), i;
  }
  function rN(e, t, r) {
    let n = Array.isArray(t) ? [] : {};
    t.$id !== void 0 && t.$id.charAt(0) !== "#" && (r = t.$id);
    let s = e.mergedSchemasIds.get(t);
    s && e.mergedSchemasIds.set(n, s);
    for (let i in t) {
      let o = t[i];
      i === "$ref" && typeof o == "string" && o.charAt(0) === "#" && (o = r + o),
        typeof o == "object" && o !== null && (o = rN(e, o, r)),
        (n[i] = o);
    }
    return n;
  }
  function XJ(e) {
    return `(${e} && typeof ${e}.toJSON === 'function')
    ? ${e}.toJSON()
    : ${e}
  `;
  }
  function ZJ(e, t) {
    let r = t.schema;
    if (e.functionsNamesBySchema.has(r)) return e.functionsNamesBySchema.get(r);
    let n = sN(e);
    e.functionsNamesBySchema.set(r, n);
    let s = t.getSchemaRef();
    s.startsWith(e.rootSchemaId) && (s = s.replace(e.rootSchemaId, ""));
    let i = `
  `,
      o = r.nullable === !0;
    return (
      (i += `
    // ${s}
    function ${n} (input) {
      const obj = ${XJ("input")}
      ${o ? "" : "if (obj === null) return JSON_STR_EMPTY_OBJECT"}

      ${YJ(e, t)}
    }
  `),
      e.functions.push(i),
      n
    );
  }
  function eQ(e, t) {
    let r = t.schema,
      n = t.getPropertyLocation("items");
    (n.schema = n.schema || {}), n.schema.$ref && (n = mu(e, n));
    let s = n.schema;
    if (e.functionsNamesBySchema.has(r)) return e.functionsNamesBySchema.get(r);
    let i = sN(e);
    e.functionsNamesBySchema.set(r, i);
    let o = t.getSchemaRef();
    o.startsWith(e.rootSchemaId) && (o = o.replace(e.rootSchemaId, ""));
    let a = `
    function ${i} (obj) {
      // ${o}
  `,
      u = r.nullable === !0;
    if (
      ((a += `
    ${u ? "" : "if (obj === null) return JSON_STR_EMPTY_ARRAY"}
    if (!Array.isArray(obj)) {
      throw new TypeError(\`The value of '${o}' does not match schema definition.\`)
    }
    const arrayLength = obj.length
  `),
      !r.additionalItems &&
        Array.isArray(s) &&
        (a += `
      if (arrayLength > ${s.length}) {
        throw new Error(\`Item at ${s.length} does not match schema definition.\`)
      }
    `),
      eN === "json-stringify" &&
        (a += `if (arrayLength >= ${kf}) return JSON.stringify(obj)
`),
      (a += `
    const arrayEnd = arrayLength - 1
    let value
    let json = ''
  `),
      Array.isArray(s))
    ) {
      for (let l = 0; l < s.length; l++) {
        let c = s[l];
        a += `value = obj[${l}]`;
        let f = Fr(e, n.getPropertyLocation(l), "value");
        a += `
        if (${l} < arrayLength) {
          if (${nN(c.type, `[${l}]`)}) {
            ${f}
            if (${l} < arrayEnd) {
              json += JSON_STR_COMMA
            }
          } else {
            throw new Error(\`Item at ${l} does not match schema definition.\`)
          }
        }
        `;
      }
      r.additionalItems &&
        (a += `
        for (let i = ${s.length}; i < arrayLength; i++) {
          json += JSON.stringify(obj[i])
          if (i < arrayEnd) {
            json += JSON_STR_COMMA
          }
        }`);
    } else {
      let l = Fr(e, n, "obj[i]");
      a += `
      for (let i = 0; i < arrayLength; i++) {
        ${l}
        if (i < arrayEnd) {
          json += JSON_STR_COMMA
        }
      }`;
    }
    return (
      (a += `
    return JSON_STR_BEGIN_ARRAY + json + JSON_STR_END_ARRAY
  }`),
      e.functions.push(a),
      i
    );
  }
  function nN(e, t) {
    let r;
    switch (e) {
      case "null":
        r = "value === null";
        break;
      case "string":
        r = `typeof value === 'string' ||
      value === null ||
      value instanceof Date ||
      value instanceof RegExp ||
      (
        typeof value === "object" &&
        typeof value.toString === "function" &&
        value.toString !== Object.prototype.toString
      )`;
        break;
      case "integer":
        r = "Number.isInteger(value)";
        break;
      case "number":
        r = "Number.isFinite(value)";
        break;
      case "boolean":
        r = "typeof value === 'boolean'";
        break;
      case "object":
        r = "value && typeof value === 'object' && value.constructor === Object";
        break;
      case "array":
        r = "Array.isArray(value)";
        break;
      default:
        Array.isArray(e) && (r = `(${e.map((s) => nN(s, t)).join(" || ")})`);
    }
    return r;
  }
  function sN(e) {
    return "anonymous" + e.functionsCounter++;
  }
  function tQ(e, t, r) {
    let s = t.schema.type.sort((a) => (a === "null" ? -1 : 1)),
      i = "";
    s.forEach((a, u) => {
      t.schema = { ...t.schema, type: a };
      let l = iN(e, t, r),
        c = u === 0 ? "if" : "else if";
      switch (a) {
        case "null":
          i += `
          ${c} (${r} === null)
            ${l}
          `;
          break;
        case "string": {
          i += `
          ${c}(
            typeof ${r} === "string" ||
            ${r} === null ||
            ${r} instanceof Date ||
            ${r} instanceof RegExp ||
            (
              typeof ${r} === "object" &&
              typeof ${r}.toString === "function" &&
              ${r}.toString !== Object.prototype.toString
            )
          )
            ${l}
        `;
          break;
        }
        case "array": {
          i += `
          ${c}(Array.isArray(${r}))
            ${l}
        `;
          break;
        }
        case "integer": {
          i += `
          ${c}(Number.isInteger(${r}) || ${r} === null)
            ${l}
        `;
          break;
        }
        default: {
          i += `
          ${c}(typeof ${r} === "${a}" || ${r} === null)
            ${l}
        `;
          break;
        }
      }
    });
    let o = t.getSchemaRef();
    return (
      o.startsWith(e.rootSchemaId) && (o = o.replace(e.rootSchemaId, "")),
      (i += `
    else throw new TypeError(\`The value of '${o}' does not match schema definition.\`)
  `),
      i
    );
  }
  function iN(e, t, r) {
    let n = t.schema;
    switch (n.type) {
      case "null":
        return "json += JSON_STR_NULL";
      case "string":
        return n.format === "date-time"
          ? `json += serializer.asDateTime(${r})`
          : n.format === "date"
            ? `json += serializer.asDate(${r})`
            : n.format === "time"
              ? `json += serializer.asTime(${r})`
              : n.format === "unsafe"
                ? `json += serializer.asUnsafeString(${r})`
                : `
        if (typeof ${r} !== 'string') {
          if (${r} === null) {
            json += JSON_STR_EMPTY_STRING
          } else if (${r} instanceof Date) {
            json += JSON_STR_QUOTE + ${r}.toISOString() + JSON_STR_QUOTE
          } else if (${r} instanceof RegExp) {
            json += serializer.asString(${r}.source)
          } else {
            json += serializer.asString(${r}.toString())
          }
        } else {
          json += serializer.asString(${r})
        }
        `;
      case "integer":
        return `json += serializer.asInteger(${r})`;
      case "number":
        return `json += serializer.asNumber(${r})`;
      case "boolean":
        return `json += serializer.asBoolean(${r})`;
      case "object":
        return `json += ${ZJ(e, t)}(${r})`;
      case "array":
        return `json += ${eQ(e, t)}(${r})`;
      case void 0:
        return `json += JSON.stringify(${r})`;
      default:
        throw new Error(`${n.type} unsupported`);
    }
  }
  function rQ(e, t) {
    let r = e.schema,
      n = r.type,
      s = Array.isArray(n) && n.includes("null"),
      i = "";
    return (
      s &&
        (i += `
      if (${t} === null) {
        json += JSON_STR_NULL
      } else {
    `),
      (i += `json += '${JSON.stringify(r.const).replace(UJ, "\\'")}'`),
      s &&
        (i += `
      }
    `),
      i
    );
  }
  function nQ(e, t, r) {
    let n = t.schema,
      s = e.mergedSchemasIds.get(n);
    if (s) {
      let c = Df(e, s);
      return Fr(e, c, r);
    }
    (s = `__fjs_merged_${pu++}`), e.mergedSchemasIds.set(n, s);
    let { allOf: i, ...o } = t.schema,
      a = [new Ni(o, t.schemaId, t.jsonPointer)],
      u = t.getPropertyLocation("allOf");
    for (let c = 0; c < i.length; c++) a.push(u.getPropertyLocation(c));
    let l = qf(e, s, a);
    return Fr(e, l, r);
  }
  function sQ(e, t, r) {
    e.validatorSchemasIds.add(t.schemaId);
    let s = t.schema.anyOf ? "anyOf" : "oneOf",
      { [s]: i, ...o } = t.schema,
      a = new Ni(o, t.schemaId, t.jsonPointer),
      u = t.getPropertyLocation(s),
      l = "";
    for (let f = 0; f < i.length; f++) {
      let d = u.getPropertyLocation(f),
        h = d.schema,
        p = e.mergedSchemasIds.get(h),
        y = null;
      p
        ? (y = Df(e, p))
        : ((p = `__fjs_merged_${pu++}`), e.mergedSchemasIds.set(h, p), (y = qf(e, p, [a, d])));
      let _ = Fr(e, y, r),
        S = d.getSchemaRef();
      l += `
      ${f === 0 ? "if" : "else if"}(validator.validate("${S}", ${r}))
        ${_}
    `;
    }
    let c = t.getSchemaRef();
    return (
      c.startsWith(e.rootSchemaId) && (c = c.replace(e.rootSchemaId, "")),
      (l += `
    else throw new TypeError(\`The value of '${c}' does not match schema definition.\`)
  `),
      l
    );
  }
  function iQ(e, t, r) {
    e.validatorSchemasIds.add(t.schemaId);
    let { if: n, then: s, else: i, ...o } = t.schema,
      a = new Ni(o, t.schemaId, t.jsonPointer),
      l = t.getPropertyLocation("if").getSchemaRef(),
      c = t.getPropertyLocation("then"),
      f = e.mergedSchemasIds.get(s),
      d = null;
    if (
      (f
        ? (d = Df(e, f))
        : ((f = `__fjs_merged_${pu++}`), e.mergedSchemasIds.set(s, f), (d = qf(e, f, [a, c]))),
      !i)
    )
      return `
      if (validator.validate("${l}", ${r})) {
        ${Fr(e, d, r)}
      } else {
        ${Fr(e, a, r)}
      }
    `;
    let h = t.getPropertyLocation("else"),
      p = e.mergedSchemasIds.get(i),
      y = null;
    return (
      p
        ? (y = Df(e, p))
        : ((p = `__fjs_merged_${pu++}`), e.mergedSchemasIds.set(i, p), (y = qf(e, p, [a, h]))),
      `
    if (validator.validate("${l}", ${r})) {
      ${Fr(e, d, r)}
    } else {
      ${Fr(e, y, r)}
    }
  `
    );
  }
  function Fr(e, t, r) {
    let n = t.schema;
    if (typeof n == "boolean") return `json += JSON.stringify(${r})`;
    if ((n.$ref && ((t = mu(e, t)), (n = t.schema)), n.allOf)) return nQ(e, t, r);
    if (n.anyOf || n.oneOf) return sQ(e, t, r);
    if (n.if && n.then) return iQ(e, t, r);
    if (n.type === void 0) {
      let a = QJ(n);
      a && (n.type = a);
    }
    let s = "",
      i = n.type,
      o = n.nullable === !0;
    return (
      o &&
        (s += `
      if (${r} === null) {
        json += JSON_STR_NULL
      } else {
    `),
      n.const !== void 0
        ? (s += rQ(t, r))
        : Array.isArray(i)
          ? (s += tQ(e, t, r))
          : (s += iN(e, t, r)),
      o &&
        (s += `
      }
    `),
      s
    );
  }
  Ao.exports = kg;
  Ao.exports.default = kg;
  Ao.exports.build = kg;
  Ao.exports.validLargeArrayMechanisms = tN;
  Ao.exports.restore = function ({ code: e, validator: t, serializer: r }) {
    return Function.apply(null, ["validator", "serializer", e]).apply(null, [t, r]);
  };
});
var uN = b((Woe, Dg) => {
  "use strict";
  var oQ = qg();
  function aN(e = { readMode: !0 }) {
    if (e.readMode === !0 && typeof e.restoreFunction != "function")
      throw new Error(
        "You must provide a function for the restoreFunction-option when readMode ON",
      );
    if (e.readMode !== !0 && typeof e.storeFunction != "function")
      throw new Error("You must provide a function for the storeFunction-option when readMode OFF");
    if (e.readMode === !0)
      return function () {
        return function (n) {
          return e.restoreFunction(n);
        };
      };
    let t = oQ();
    return function (n, s = {}) {
      s.mode = "standalone";
      let i = t(n, s);
      return function (o) {
        let a = i(o);
        return e.storeFunction(o, a), new Function(a);
      };
    };
  }
  Dg.exports = aN;
  Dg.exports.default = aN;
});
var qg = b((Yoe, yu) => {
  "use strict";
  var aQ = oN();
  function jg() {
    return function (t, r) {
      let n = Object.assign({}, r, { schema: t });
      return uQ.bind(null, n);
    };
  }
  function uQ(e, { schema: t }) {
    return (
      e.schema &&
        t.$id &&
        e.schema[t.$id] &&
        ((e.schema = { ...e.schema }), delete e.schema[t.$id]),
      aQ(t, e)
    );
  }
  yu.exports = jg;
  yu.exports.default = jg;
  yu.exports.SerializerSelector = jg;
  yu.exports.StandaloneSerializer = uN();
});
var fs = b((gu) => {
  "use strict";
  Object.defineProperty(gu, "__esModule", { value: !0 });
  gu.checkMetadata = void 0;
  var lQ = Ie(),
    cQ = {
      keyword: "metadata",
      schemaType: "object",
      code(e) {
        lN(e);
        let { gen: t, schema: r, it: n } = e;
        if ((0, lQ.alwaysValidSchema)(n, r)) return;
        let s = t.name("valid");
        e.subschema({ keyword: "metadata", jtdMetadata: !0 }, s), e.ok(s);
      },
    };
  function lN({ it: e, keyword: t }, r) {
    if (e.jtdMetadata !== r) throw new Error(`JTD: "${t}" cannot be used in this schema location`);
  }
  gu.checkMetadata = lN;
  gu.default = cQ;
});
var jf = b((Su) => {
  "use strict";
  Object.defineProperty(Su, "__esModule", { value: !0 });
  Su.hasRef = void 0;
  var cN = Ti(),
    _u = he(),
    fQ = ls(),
    fN = tn(),
    dN = vy(),
    dQ = fs(),
    hQ = {
      keyword: "ref",
      schemaType: "string",
      code(e) {
        (0, dQ.checkMetadata)(e);
        let { gen: t, data: r, schema: n, parentSchema: s, it: i } = e,
          {
            schemaEnv: { root: o },
          } = i,
          a = t.name("valid");
        s.nullable
          ? (t.var(a, (0, _u._)`${r} === null`), t.if((0, _u.not)(a), u))
          : (t.var(a, !1), u()),
          e.ok(a);
        function u() {
          var f;
          let d = (f = o.schema.definitions) === null || f === void 0 ? void 0 : f[n];
          if (!d) throw new fQ.default(i.opts.uriResolver, "", n, `No definition ${n}`);
          Lg(d) || !i.opts.inlineRefs ? l(d) : c(d);
        }
        function l(f) {
          let d = cN.compileSchema.call(
              i.self,
              new cN.SchemaEnv({ schema: f, root: o, schemaPath: `/definitions/${n}` }),
            ),
            h = (0, dN.getValidate)(e, d),
            p = t.const("_errs", fN.default.errors);
          (0, dN.callRef)(e, h, d, d.$async), t.assign(a, (0, _u._)`${p} === ${fN.default.errors}`);
        }
        function c(f) {
          let d = t.scopeValue(
            "schema",
            i.opts.code.source === !0 ? { ref: f, code: (0, _u.stringify)(f) } : { ref: f },
          );
          e.subschema(
            {
              schema: f,
              dataTypes: [],
              schemaPath: _u.nil,
              topSchemaRef: d,
              errSchemaPath: `/definitions/${n}`,
            },
            a,
          );
        }
      },
    };
  function Lg(e) {
    for (let t in e) {
      let r;
      if (t === "ref" || (typeof (r = e[t]) == "object" && Lg(r))) return !0;
    }
    return !1;
  }
  Su.hasRef = Lg;
  Su.default = hQ;
});
var Fg = b((xg) => {
  "use strict";
  Object.defineProperty(xg, "__esModule", { value: !0 });
  var pQ = /t|\s/i,
    mQ = /^(\d\d\d\d)-(\d\d)-(\d\d)$/,
    yQ = /^(\d\d):(\d\d):(\d\d)(?:\.\d+)?(?:z|([+-]\d\d)(?::?(\d\d))?)$/i,
    gQ = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
  function pN(e, t) {
    let r = e.split(pQ);
    return (r.length === 2 && hN(r[0]) && _Q(r[1])) || (t && r.length === 1 && hN(r[0]));
  }
  xg.default = pN;
  function hN(e) {
    let t = mQ.exec(e);
    if (!t) return !1;
    let r = +t[1],
      n = +t[2],
      s = +t[3];
    return (
      n >= 1 &&
      n <= 12 &&
      s >= 1 &&
      (s <= gQ[n] || (n === 2 && s === 29 && (r % 100 === 0 ? r % 400 === 0 : r % 4 === 0)))
    );
  }
  function _Q(e) {
    let t = yQ.exec(e);
    if (!t) return !1;
    let r = +t[1],
      n = +t[2],
      s = +t[3],
      i = +(t[4] || 0),
      o = +(t[5] || 0);
    return (r <= 23 && n <= 59 && s <= 59) || (r - i === 23 && n - o === 59 && s === 60);
  }
  pN.code = 'require("ajv/dist/runtime/timestamp").default';
});
var Io = b((Hs) => {
  "use strict";
  Object.defineProperty(Hs, "__esModule", { value: !0 });
  Hs.typeErrorParams = Hs.typeErrorMessage = Hs.typeError = void 0;
  var SQ = he();
  function vQ(e) {
    return { message: (t) => mN(t, e), params: (t) => yN(t, e) };
  }
  Hs.typeError = vQ;
  function mN({ parentSchema: e }, t) {
    return e?.nullable ? `must be ${t} or null` : `must be ${t}`;
  }
  Hs.typeErrorMessage = mN;
  function yN({ parentSchema: e }, t) {
    return (0, SQ._)`{type: ${t}, nullable: ${!!e?.nullable}}`;
  }
  Hs.typeErrorParams = yN;
});
var Mg = b((Co) => {
  "use strict";
  Object.defineProperty(Co, "__esModule", { value: !0 });
  Co.intRange = void 0;
  var Mr = he(),
    bQ = Fg(),
    wQ = Ie(),
    EQ = fs(),
    gN = Io();
  Co.intRange = {
    int8: [-128, 127, 3],
    uint8: [0, 255, 3],
    int16: [-32768, 32767, 5],
    uint16: [0, 65535, 5],
    int32: [-2147483648, 2147483647, 10],
    uint32: [0, 4294967295, 10],
  };
  var RQ = {
    message: (e) => (0, gN.typeErrorMessage)(e, e.schema),
    params: (e) => (0, gN.typeErrorParams)(e, e.schema),
  };
  function TQ(e) {
    let { gen: t, data: r, it: n } = e,
      { timestamp: s, allowDate: i } = n.opts;
    if (s === "date") return (0, Mr._)`${r} instanceof Date `;
    let o = (0, wQ.useFunc)(t, bQ.default),
      a = i ? (0, Mr._)`, true` : Mr.nil,
      u = (0, Mr._)`typeof ${r} == "string" && ${o}(${r}${a})`;
    return s === "string" ? u : (0, Mr.or)((0, Mr._)`${r} instanceof Date`, u);
  }
  var PQ = {
    keyword: "type",
    schemaType: "string",
    error: RQ,
    code(e) {
      (0, EQ.checkMetadata)(e);
      let { data: t, schema: r, parentSchema: n, it: s } = e,
        i;
      switch (r) {
        case "boolean":
        case "string":
          i = (0, Mr._)`typeof ${t} == ${r}`;
          break;
        case "timestamp": {
          i = TQ(e);
          break;
        }
        case "float32":
        case "float64":
          i = (0, Mr._)`typeof ${t} == "number"`;
          break;
        default: {
          let o = r;
          if (
            ((i = (0, Mr._)`typeof ${t} == "number" && isFinite(${t}) && !(${t} % 1)`),
            !s.opts.int32range && (o === "int32" || o === "uint32"))
          )
            o === "uint32" && (i = (0, Mr._)`${i} && ${t} >= 0`);
          else {
            let [a, u] = Co.intRange[o];
            i = (0, Mr._)`${i} && ${t} >= ${a} && ${t} <= ${u}`;
          }
        }
      }
      e.pass(n.nullable ? (0, Mr.or)((0, Mr._)`${t} === null`, i) : i);
    },
  };
  Co.default = PQ;
});
var Do = b((ko) => {
  "use strict";
  Object.defineProperty(ko, "__esModule", { value: !0 });
  ko.checkNullableObject = ko.checkNullable = void 0;
  var Lf = he();
  function _N({ gen: e, data: t, parentSchema: r }, n = Lf.nil) {
    let s = e.name("valid");
    return (
      r.nullable ? (e.let(s, (0, Lf._)`${t} === null`), (n = (0, Lf.not)(s))) : e.let(s, !1), [s, n]
    );
  }
  ko.checkNullable = _N;
  function $Q(e, t) {
    let [r, n] = _N(e, t);
    return [r, (0, Lf._)`${n} && typeof ${e.data} == "object" && !Array.isArray(${e.data})`];
  }
  ko.checkNullableObject = $Q;
});
var SN = b((zg) => {
  "use strict";
  Object.defineProperty(zg, "__esModule", { value: !0 });
  var Bs = he(),
    OQ = fs(),
    NQ = Do(),
    AQ = {
      message: "must be equal to one of the allowed values",
      params: ({ schemaCode: e }) => (0, Bs._)`{allowedValues: ${e}}`,
    },
    IQ = {
      keyword: "enum",
      schemaType: "array",
      error: AQ,
      code(e) {
        (0, OQ.checkMetadata)(e);
        let { gen: t, data: r, schema: n, schemaValue: s, parentSchema: i, it: o } = e;
        if (n.length === 0) throw new Error("enum must have non-empty array");
        if (n.length !== new Set(n).size) throw new Error("enum items must be unique");
        let a,
          u = (0, Bs._)`typeof ${r} == "string"`;
        if (n.length >= o.opts.loopEnum) {
          let c;
          ([a, c] = (0, NQ.checkNullable)(e, u)), t.if(c, l);
        } else {
          if (!Array.isArray(n)) throw new Error("ajv implementation error");
          (a = (0, Bs.and)(u, (0, Bs.or)(...n.map((c) => (0, Bs._)`${r} === ${c}`)))),
            i.nullable && (a = (0, Bs.or)((0, Bs._)`${r} === null`, a));
        }
        e.pass(a);
        function l() {
          t.forOf("v", s, (c) => t.if((0, Bs._)`${a} = ${r} === ${c}`, () => t.break()));
        }
      },
    };
  zg.default = IQ;
});
var bN = b((Vg) => {
  "use strict";
  Object.defineProperty(Vg, "__esModule", { value: !0 });
  var CQ = Ie(),
    kQ = Jt(),
    vN = he(),
    DQ = fs(),
    qQ = Do(),
    jQ = Io(),
    LQ = {
      keyword: "elements",
      schemaType: "object",
      error: (0, jQ.typeError)("array"),
      code(e) {
        (0, DQ.checkMetadata)(e);
        let { gen: t, data: r, schema: n, it: s } = e;
        if ((0, CQ.alwaysValidSchema)(s, n)) return;
        let [i] = (0, qQ.checkNullable)(e);
        t.if((0, vN.not)(i), () =>
          t.if(
            (0, vN._)`Array.isArray(${r})`,
            () => t.assign(i, (0, kQ.validateArray)(e)),
            () => e.error(),
          ),
        ),
          e.ok(i);
      },
    };
  Vg.default = LQ;
});
var Hg = b((Ks) => {
  "use strict";
  Object.defineProperty(Ks, "__esModule", { value: !0 });
  Ks.validateProperties = Ks.error = void 0;
  var Ug = Jt(),
    wN = Ie(),
    ds = he(),
    xQ = fs(),
    FQ = Do(),
    EN = Io(),
    qo;
  (function (e) {
    (e.Additional = "additional"), (e.Missing = "missing");
  })(qo || (qo = {}));
  Ks.error = {
    message: (e) => {
      let { params: t } = e;
      return t.propError
        ? t.propError === qo.Additional
          ? "must NOT have additional properties"
          : `must have property '${t.missingProperty}'`
        : (0, EN.typeErrorMessage)(e, "object");
    },
    params: (e) => {
      let { params: t } = e;
      return t.propError
        ? t.propError === qo.Additional
          ? (0, ds._)`{error: ${t.propError}, additionalProperty: ${t.additionalProperty}}`
          : (0, ds._)`{error: ${t.propError}, missingProperty: ${t.missingProperty}}`
        : (0, EN.typeErrorParams)(e, "object");
    },
  };
  var MQ = { keyword: "properties", schemaType: "object", error: Ks.error, code: RN };
  function RN(e) {
    (0, xQ.checkMetadata)(e);
    let { gen: t, data: r, parentSchema: n, it: s } = e,
      { additionalProperties: i, nullable: o } = n;
    if (s.jtdDiscriminator && o) throw new Error("JTD: nullable inside discriminator mapping");
    if (h()) throw new Error("JTD: properties and optionalProperties have common members");
    let [a, u] = p("properties"),
      [l, c] = p("optionalProperties");
    if (u.length === 0 && c.length === 0 && i) return;
    let [f, d] =
      s.jtdDiscriminator === void 0 ? (0, FQ.checkNullableObject)(e, r) : [t.let("valid", !1), !0];
    t.if(d, () =>
      t.assign(f, !0).block(() => {
        y(u, "properties", !0), y(c, "optionalProperties"), i || S();
      }),
    ),
      e.pass(f);
    function h() {
      let g = n.properties,
        m = n.optionalProperties;
      if (!(g && m)) return !1;
      for (let T in g) if (Object.prototype.hasOwnProperty.call(m, T)) return !0;
      return !1;
    }
    function p(g) {
      let m = n[g],
        T = m ? (0, Ug.allSchemaProperties)(m) : [];
      if (s.jtdDiscriminator && T.some((w) => w === s.jtdDiscriminator))
        throw new Error(`JTD: discriminator tag used in ${g}`);
      let N = T.filter((w) => !(0, wN.alwaysValidSchema)(s, m[w]));
      return [T, N];
    }
    function y(g, m, T) {
      let N = t.var("valid");
      for (let $ of g)
        t.if(
          (0, Ug.propertyInData)(t, r, $, s.opts.ownProperties),
          () => _($, m, N),
          () => w($),
        ),
          e.ok(N);
      function w($) {
        T
          ? (t.assign(N, !1),
            e.error(!1, { propError: qo.Missing, missingProperty: $ }, { schemaPath: $ }))
          : t.assign(N, !0);
      }
    }
    function _(g, m, T) {
      e.subschema({ keyword: m, schemaProp: g, dataProp: g }, T);
    }
    function S() {
      t.forIn("key", r, (g) => {
        let m = E(g, a, "properties", s.jtdDiscriminator),
          T = E(g, l, "optionalProperties"),
          N = m === !0 ? T : T === !0 ? m : (0, ds.and)(m, T);
        t.if(N, () => {
          s.opts.removeAdditional
            ? t.code((0, ds._)`delete ${r}[${g}]`)
            : (e.error(
                !1,
                { propError: qo.Additional, additionalProperty: g },
                { instancePath: g, parentSchema: !0 },
              ),
              s.opts.allErrors || t.break());
        });
      });
    }
    function E(g, m, T, N) {
      let w;
      if (m.length > 8) {
        let $ = (0, wN.schemaRefOrVal)(s, n[T], T);
        (w = (0, ds.not)((0, Ug.isOwnProperty)(t, $, g))),
          N !== void 0 && (w = (0, ds.and)(w, (0, ds._)`${g} !== ${N}`));
      } else if (m.length || N !== void 0) {
        let $ = N === void 0 ? m : [N].concat(m);
        w = (0, ds.and)(...$.map((D) => (0, ds._)`${g} !== ${D}`));
      } else w = !0;
      return w;
    }
  }
  Ks.validateProperties = RN;
  Ks.default = MQ;
});
var PN = b((Bg) => {
  "use strict";
  Object.defineProperty(Bg, "__esModule", { value: !0 });
  var TN = Hg(),
    zQ = {
      keyword: "optionalProperties",
      schemaType: "object",
      error: TN.error,
      code(e) {
        e.parentSchema.properties || (0, TN.validateProperties)(e);
      },
    };
  Bg.default = zQ;
});
var ON = b((Kg) => {
  "use strict";
  Object.defineProperty(Kg, "__esModule", { value: !0 });
  var Ai = he(),
    VQ = fs(),
    UQ = Do(),
    $N = Io(),
    xf = og(),
    HQ = {
      message: (e) => {
        let { schema: t, params: r } = e;
        return r.discrError
          ? r.discrError === xf.DiscrError.Tag
            ? `tag "${t}" must be string`
            : `value of tag "${t}" must be in mapping`
          : (0, $N.typeErrorMessage)(e, "object");
      },
      params: (e) => {
        let { schema: t, params: r } = e;
        return r.discrError
          ? (0, Ai._)`{error: ${r.discrError}, tag: ${t}, tagValue: ${r.tag}}`
          : (0, $N.typeErrorParams)(e, "object");
      },
    },
    BQ = {
      keyword: "discriminator",
      schemaType: "string",
      implements: ["mapping"],
      error: HQ,
      code(e) {
        (0, VQ.checkMetadata)(e);
        let { gen: t, data: r, schema: n, parentSchema: s } = e,
          [i, o] = (0, UQ.checkNullableObject)(e, r);
        t.if(o), a(), t.elseIf((0, Ai.not)(i)), e.error(), t.endIf(), e.ok(i);
        function a() {
          let c = t.const("tag", (0, Ai._)`${r}${(0, Ai.getProperty)(n)}`);
          t.if((0, Ai._)`${c} === undefined`),
            e.error(!1, { discrError: xf.DiscrError.Tag, tag: c }),
            t.elseIf((0, Ai._)`typeof ${c} == "string"`),
            u(c),
            t.else(),
            e.error(!1, { discrError: xf.DiscrError.Tag, tag: c }, { instancePath: n }),
            t.endIf();
        }
        function u(c) {
          t.if(!1);
          for (let f in s.mapping) t.elseIf((0, Ai._)`${c} === ${f}`), t.assign(i, l(f));
          t.else(),
            e.error(
              !1,
              { discrError: xf.DiscrError.Mapping, tag: c },
              { instancePath: n, schemaPath: "mapping", parentSchema: !0 },
            ),
            t.endIf();
        }
        function l(c) {
          let f = t.name("valid");
          return e.subschema({ keyword: "mapping", schemaProp: c, jtdDiscriminator: n }, f), f;
        }
      },
    };
  Kg.default = BQ;
});
var AN = b((Gg) => {
  "use strict";
  Object.defineProperty(Gg, "__esModule", { value: !0 });
  var NN = Ie(),
    Ff = he(),
    KQ = fs(),
    GQ = Do(),
    JQ = Io(),
    QQ = {
      keyword: "values",
      schemaType: "object",
      error: (0, JQ.typeError)("object"),
      code(e) {
        (0, KQ.checkMetadata)(e);
        let { gen: t, data: r, schema: n, it: s } = e,
          [i, o] = (0, GQ.checkNullableObject)(e, r);
        (0, NN.alwaysValidSchema)(s, n)
          ? t.if((0, Ff.not)((0, Ff.or)(o, i)), () => e.error())
          : (t.if(o), t.assign(i, a()), t.elseIf((0, Ff.not)(i)), e.error(), t.endIf()),
          e.ok(i);
        function a() {
          let u = t.name("valid");
          if (s.allErrors) {
            let c = t.let("valid", !0);
            return l(() => t.assign(c, !1)), c;
          }
          return t.var(u, !0), l(() => t.break()), u;
          function l(c) {
            t.forIn("key", r, (f) => {
              e.subschema({ keyword: "values", dataProp: f, dataPropType: NN.Type.Str }, u),
                t.if((0, Ff.not)(u), c);
            });
          }
        }
      },
    };
  Gg.default = QQ;
});
var IN = b((Jg) => {
  "use strict";
  Object.defineProperty(Jg, "__esModule", { value: !0 });
  var WQ = Jt(),
    YQ = {
      keyword: "union",
      schemaType: "array",
      trackErrors: !0,
      code: WQ.validateUnion,
      error: { message: "must match a schema in union" },
    };
  Jg.default = YQ;
});
var CN = b((Qg) => {
  "use strict";
  Object.defineProperty(Qg, "__esModule", { value: !0 });
  var XQ = jf(),
    ZQ = Mg(),
    e7 = SN(),
    t7 = bN(),
    r7 = Hg(),
    n7 = PN(),
    s7 = ON(),
    i7 = AN(),
    o7 = IN(),
    a7 = fs(),
    u7 = [
      "definitions",
      XQ.default,
      ZQ.default,
      e7.default,
      t7.default,
      r7.default,
      n7.default,
      s7.default,
      i7.default,
      o7.default,
      a7.default,
      { keyword: "additionalProperties", schemaType: "boolean" },
      { keyword: "nullable", schemaType: "boolean" },
    ];
  Qg.default = u7;
});
var jN = b((Wg) => {
  "use strict";
  Object.defineProperty(Wg, "__esModule", { value: !0 });
  var hs = (e) => {
      let t = {
        nullable: { type: "boolean" },
        metadata: {
          optionalProperties: { union: { elements: { ref: "schema" } } },
          additionalProperties: !0,
        },
      };
      return e && (t.definitions = { values: { ref: "schema" } }), t;
    },
    l7 = (e) => ({ optionalProperties: hs(e) }),
    c7 = (e) => ({ properties: { ref: { type: "string" } }, optionalProperties: hs(e) }),
    f7 = (e) => ({
      properties: {
        type: {
          enum: [
            "boolean",
            "timestamp",
            "string",
            "float32",
            "float64",
            "int8",
            "uint8",
            "int16",
            "uint16",
            "int32",
            "uint32",
          ],
        },
      },
      optionalProperties: hs(e),
    }),
    d7 = (e) => ({
      properties: { enum: { elements: { type: "string" } } },
      optionalProperties: hs(e),
    }),
    h7 = (e) => ({ properties: { elements: { ref: "schema" } }, optionalProperties: hs(e) }),
    DN = (e) => ({
      properties: { properties: { values: { ref: "schema" } } },
      optionalProperties: {
        optionalProperties: { values: { ref: "schema" } },
        additionalProperties: { type: "boolean" },
        ...hs(e),
      },
    }),
    qN = (e) => ({
      properties: { optionalProperties: { values: { ref: "schema" } } },
      optionalProperties: { additionalProperties: { type: "boolean" }, ...hs(e) },
    }),
    p7 = (e) => ({
      properties: {
        discriminator: { type: "string" },
        mapping: { values: { metadata: { union: [DN(!1), qN(!1)] } } },
      },
      optionalProperties: hs(e),
    }),
    m7 = (e) => ({ properties: { values: { ref: "schema" } }, optionalProperties: hs(e) }),
    kN = (e) => ({ metadata: { union: [l7, c7, f7, d7, h7, DN, qN, p7, m7].map((t) => t(e)) } }),
    y7 = { definitions: { schema: kN(!1) }, ...kN(!0) };
  Wg.default = y7;
});
var Yg = b((Mf) => {
  "use strict";
  Object.defineProperty(Mf, "__esModule", { value: !0 });
  Mf.jtdForms = void 0;
  Mf.jtdForms = [
    "elements",
    "values",
    "discriminator",
    "properties",
    "optionalProperties",
    "enum",
    "type",
    "ref",
  ];
});
var xN = b((Zg) => {
  "use strict";
  Object.defineProperty(Zg, "__esModule", { value: !0 });
  var Xg =
      /[\\"\u0000-\u001f\u007f-\u009f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
    g7 = {
      "\b": "\\b",
      "	": "\\t",
      "\n": "\\n",
      "\f": "\\f",
      "\r": "\\r",
      '"': '\\"',
      "\\": "\\\\",
    };
  function LN(e) {
    return (
      (Xg.lastIndex = 0),
      '"' +
        (Xg.test(e)
          ? e.replace(Xg, (t) => {
              let r = g7[t];
              return typeof r == "string"
                ? r
                : "\\u" + ("0000" + t.charCodeAt(0).toString(16)).slice(-4);
            })
          : e) +
        '"'
    );
  }
  Zg.default = LN;
  LN.code = 'require("ajv/dist/runtime/quote").default';
});
var HN = b((t0) => {
  "use strict";
  Object.defineProperty(t0, "__esModule", { value: !0 });
  var _7 = Yg(),
    MN = Ti(),
    Le = he(),
    S7 = ls(),
    ft = tn(),
    v7 = Jt(),
    b7 = jf(),
    w7 = Ie(),
    E7 = xN(),
    R7 = {
      elements: P7,
      values: $7,
      discriminator: O7,
      properties: FN,
      optionalProperties: FN,
      enum: vu,
      type: N7,
      ref: I7,
    };
  function zN(e, t) {
    let r = MN.getCompilingSchema.call(this, e);
    if (r) return r;
    let { es5: n, lines: s } = this.opts.code,
      { ownProperties: i } = this.opts,
      o = new Le.CodeGen(this.scope, { es5: n, lines: s, ownProperties: i }),
      a = o.scopeName("serialize"),
      u = {
        self: this,
        gen: o,
        schema: e.schema,
        schemaEnv: e,
        definitions: t,
        data: ft.default.data,
      },
      l;
    try {
      this._compilations.add(e),
        (e.serializeName = a),
        o.func(a, ft.default.data, !1, () => {
          o.let(ft.default.json, (0, Le.str)``), bu(u), o.return(ft.default.json);
        }),
        o.optimize(this.opts.code.optimize);
      let c = o.toString();
      l = `${o.scopeRefs(ft.default.scope)}return ${c}`;
      let d = new Function(`${ft.default.scope}`, l)(this.scope.get());
      this.scope.value(a, { ref: d }), (e.serialize = d);
    } catch (c) {
      throw (
        (l && this.logger.error("Error compiling serializer, function code:", l),
        delete e.serialize,
        delete e.serializeName,
        c)
      );
    } finally {
      this._compilations.delete(e);
    }
    return e;
  }
  t0.default = zN;
  function bu(e) {
    let t;
    for (let r of _7.jtdForms)
      if (r in e.schema) {
        t = r;
        break;
      }
    T7(e, t ? R7[t] : k7);
  }
  function T7(e, t) {
    let { gen: r, schema: n, data: s } = e;
    if (!n.nullable) return t(e);
    r.if(
      (0, Le._)`${s} === undefined || ${s} === null`,
      () => r.add(ft.default.json, (0, Le._)`"null"`),
      () => t(e),
    );
  }
  function P7(e) {
    let { gen: t, schema: r, data: n } = e;
    t.add(ft.default.json, (0, Le.str)`[`);
    let s = t.let("first", !0);
    t.forOf("el", n, (i) => {
      e0(e, s), bu({ ...e, schema: r.elements, data: i });
    }),
      t.add(ft.default.json, (0, Le.str)`]`);
  }
  function $7(e) {
    let { gen: t, schema: r, data: n } = e;
    t.add(ft.default.json, (0, Le.str)`{`);
    let s = t.let("first", !0);
    t.forIn("key", n, (i) => VN(e, i, r.values, s)), t.add(ft.default.json, (0, Le.str)`}`);
  }
  function VN(e, t, r, n) {
    let { gen: s, data: i } = e;
    e0(e, n), vu({ ...e, data: t }), s.add(ft.default.json, (0, Le.str)`:`);
    let o = s.const("value", (0, Le._)`${i}${(0, Le.getProperty)(t)}`);
    bu({ ...e, schema: r, data: o });
  }
  function O7(e) {
    let { gen: t, schema: r, data: n } = e,
      { discriminator: s } = r;
    t.add(ft.default.json, (0, Le.str)`{${JSON.stringify(s)}:`);
    let i = t.const("tag", (0, Le._)`${n}${(0, Le.getProperty)(s)}`);
    vu({ ...e, data: i }), t.if(!1);
    for (let o in r.mapping) {
      t.elseIf((0, Le._)`${i} === ${o}`);
      let a = r.mapping[o];
      UN({ ...e, schema: a }, s);
    }
    t.endIf(), t.add(ft.default.json, (0, Le.str)`}`);
  }
  function FN(e) {
    let { gen: t } = e;
    t.add(ft.default.json, (0, Le.str)`{`), UN(e), t.add(ft.default.json, (0, Le.str)`}`);
  }
  function UN(e, t) {
    let { gen: r, schema: n, data: s } = e,
      { properties: i, optionalProperties: o } = n,
      a = d(i),
      u = d(o),
      l = h(a.concat(u)),
      c = !t,
      f;
    for (let S of a) c ? (c = !1) : r.add(ft.default.json, (0, Le.str)`,`), y(S, i[S], p(S));
    c && (f = r.let("first", !0));
    for (let S of u) {
      let E = p(S);
      r.if((0, Le.and)((0, Le._)`${E} !== undefined`, (0, v7.isOwnProperty)(r, s, S)), () => {
        e0(e, f), y(S, o[S], E);
      });
    }
    n.additionalProperties && r.forIn("key", s, (S) => r.if(_(S, l), () => VN(e, S, {}, f)));
    function d(S) {
      return S ? Object.keys(S) : [];
    }
    function h(S) {
      if ((t && S.push(t), new Set(S).size !== S.length))
        throw new Error("JTD: properties/optionalProperties/disciminator overlap");
      return S;
    }
    function p(S) {
      return r.const("value", (0, Le._)`${s}${(0, Le.getProperty)(S)}`);
    }
    function y(S, E, g) {
      r.add(ft.default.json, (0, Le.str)`${JSON.stringify(S)}:`), bu({ ...e, schema: E, data: g });
    }
    function _(S, E) {
      return E.length ? (0, Le.and)(...E.map((g) => (0, Le._)`${S} !== ${g}`)) : !0;
    }
  }
  function N7(e) {
    let { gen: t, schema: r, data: n } = e;
    switch (r.type) {
      case "boolean":
        t.add(ft.default.json, (0, Le._)`${n} ? "true" : "false"`);
        break;
      case "string":
        vu(e);
        break;
      case "timestamp":
        t.if(
          (0, Le._)`${n} instanceof Date`,
          () => t.add(ft.default.json, (0, Le._)`'"' + ${n}.toISOString() + '"'`),
          () => vu(e),
        );
        break;
      default:
        A7(e);
    }
  }
  function vu({ gen: e, data: t }) {
    e.add(ft.default.json, (0, Le._)`${(0, w7.useFunc)(e, E7.default)}(${t})`);
  }
  function A7({ gen: e, data: t }) {
    e.add(ft.default.json, (0, Le._)`"" + ${t}`);
  }
  function I7(e) {
    let { gen: t, self: r, data: n, definitions: s, schema: i, schemaEnv: o } = e,
      { ref: a } = i,
      u = s[a];
    if (!u) throw new S7.default(r.opts.uriResolver, "", a, `No definition ${a}`);
    if (!(0, b7.hasRef)(u)) return bu({ ...e, schema: u });
    let { root: l } = o,
      c = zN.call(r, new MN.SchemaEnv({ schema: u, root: l }), s);
    t.add(ft.default.json, (0, Le._)`${C7(t, c)}(${n})`);
  }
  function C7(e, t) {
    return t.serialize
      ? e.scopeValue("serialize", { ref: t.serialize })
      : (0, Le._)`${e.scopeValue("wrapper", { ref: t })}.serialize`;
  }
  function k7({ gen: e, data: t }) {
    e.add(ft.default.json, (0, Le._)`JSON.stringify(${t})`);
  }
  function e0({ gen: e }, t) {
    t
      ? e.if(
          t,
          () => e.assign(t, !1),
          () => e.add(ft.default.json, (0, Le.str)`,`),
        )
      : e.add(ft.default.json, (0, Le.str)`,`);
  }
});
var KN = b((Js) => {
  "use strict";
  Object.defineProperty(Js, "__esModule", { value: !0 });
  Js.parseJsonString = Js.parseJsonNumber = Js.parseJson = void 0;
  var D7 = /position\s(\d+)(?: \(line \d+ column \d+\))?$/;
  function ps(e, t) {
    let r;
    ps.message = void 0;
    let n;
    t && (e = e.slice(t));
    try {
      return (ps.position = t + e.length), JSON.parse(e);
    } catch (s) {
      if (((n = D7.exec(s.message)), !n)) {
        ps.message = "unexpected end";
        return;
      }
      r = +n[1];
      let i = e[r];
      (e = e.slice(0, r)), (ps.position = t + r);
      try {
        return JSON.parse(e);
      } catch {
        ps.message = `unexpected token ${i}`;
        return;
      }
    }
  }
  Js.parseJson = ps;
  ps.message = void 0;
  ps.position = 0;
  ps.code = 'require("ajv/dist/runtime/parseJson").parseJson';
  function ms(e, t, r) {
    let n = "",
      s;
    if (((ms.message = void 0), e[t] === "-" && ((n += "-"), t++), e[t] === "0")) (n += "0"), t++;
    else if (!i(r)) {
      o();
      return;
    }
    if (r) return (ms.position = t), +n;
    if (e[t] === "." && ((n += "."), t++, !i())) {
      o();
      return;
    }
    if (
      ((s = e[t]),
      (s === "e" || s === "E") &&
        ((n += "e"), t++, (s = e[t]), (s === "+" || s === "-") && ((n += s), t++), !i()))
    ) {
      o();
      return;
    }
    return (ms.position = t), +n;
    function i(a) {
      let u = !1;
      for (; (s = e[t]), s >= "0" && s <= "9" && (a === void 0 || a-- > 0); )
        (u = !0), (n += s), t++;
      return u;
    }
    function o() {
      (ms.position = t),
        (ms.message = t < e.length ? `unexpected token ${e[t]}` : "unexpected end");
    }
  }
  Js.parseJsonNumber = ms;
  ms.message = void 0;
  ms.position = 0;
  ms.code = 'require("ajv/dist/runtime/parseJson").parseJsonNumber';
  var BN = {
      b: "\b",
      f: "\f",
      n: `
`,
      r: "\r",
      t: "	",
      '"': '"',
      "/": "/",
      "\\": "\\",
    },
    q7 = 97,
    j7 = 48;
  function Gs(e, t) {
    let r = "",
      n;
    for (Gs.message = void 0; (n = e[t++]), n !== '"'; )
      if (n === "\\")
        if (((n = e[t]), n in BN)) (r += BN[n]), t++;
        else if (n === "u") {
          t++;
          let i = 4,
            o = 0;
          for (; i--; ) {
            if (((o <<= 4), (n = e[t]), n === void 0)) {
              s("unexpected end");
              return;
            }
            if (((n = n.toLowerCase()), n >= "a" && n <= "f")) o += n.charCodeAt(0) - q7 + 10;
            else if (n >= "0" && n <= "9") o += n.charCodeAt(0) - j7;
            else {
              s(`unexpected token ${n}`);
              return;
            }
            t++;
          }
          r += String.fromCharCode(o);
        } else {
          s(`unexpected token ${n}`);
          return;
        }
      else if (n === void 0) {
        s("unexpected end");
        return;
      } else if (n.charCodeAt(0) >= 32) r += n;
      else {
        s(`unexpected token ${n}`);
        return;
      }
    return (Gs.position = t), r;
    function s(i) {
      (Gs.position = t), (Gs.message = i);
    }
  }
  Js.parseJsonString = Gs;
  Gs.message = void 0;
  Gs.position = 0;
  Gs.code = 'require("ajv/dist/runtime/parseJson").parseJsonString';
});
var nA = b((l0) => {
  "use strict";
  Object.defineProperty(l0, "__esModule", { value: !0 });
  var L7 = Yg(),
    WN = Ti(),
    le = he(),
    x7 = ls(),
    qe = tn(),
    F7 = Jt(),
    M7 = jf(),
    z7 = Mg(),
    s0 = KN(),
    YN = Ie(),
    V7 = Fg(),
    U7 = {
      elements: G7,
      values: J7,
      discriminator: W7,
      properties: GN,
      optionalProperties: GN,
      enum: X7,
      type: Y7,
      ref: Z7,
    };
  function XN(e, t) {
    let r = WN.getCompilingSchema.call(this, e);
    if (r) return r;
    let { es5: n, lines: s } = this.opts.code,
      { ownProperties: i } = this.opts,
      o = new le.CodeGen(this.scope, { es5: n, lines: s, ownProperties: i }),
      a = o.scopeName("parse"),
      u = {
        self: this,
        gen: o,
        schema: e.schema,
        schemaEnv: e,
        definitions: t,
        data: qe.default.data,
        parseName: a,
        char: o.name("c"),
      },
      l;
    try {
      this._compilations.add(e), (e.parseName = a), H7(u), o.optimize(this.opts.code.optimize);
      let c = o.toString();
      l = `${o.scopeRefs(qe.default.scope)}return ${c}`;
      let d = new Function(`${qe.default.scope}`, l)(this.scope.get());
      this.scope.value(a, { ref: d }), (e.parse = d);
    } catch (c) {
      throw (
        (l && this.logger.error("Error compiling parser, function code:", l),
        delete e.parse,
        delete e.parseName,
        c)
      );
    } finally {
      this._compilations.delete(e);
    }
    return e;
  }
  l0.default = XN;
  var n0 = (0, le._)`undefined`;
  function H7(e) {
    let { gen: t, parseName: r, char: n } = e;
    t.func(
      r,
      (0, le._)`${qe.default.json}, ${qe.default.jsonPos}, ${qe.default.jsonPart}`,
      !1,
      () => {
        t.let(qe.default.data),
          t.let(n),
          t.assign((0, le._)`${r}.message`, n0),
          t.assign((0, le._)`${r}.position`, n0),
          t.assign(qe.default.jsonPos, (0, le._)`${qe.default.jsonPos} || 0`),
          t.const(qe.default.jsonLen, (0, le._)`${qe.default.json}.length`),
          zf(e),
          u0(e),
          t.if(qe.default.jsonPart, () => {
            t.assign((0, le._)`${r}.position`, qe.default.jsonPos), t.return(qe.default.data);
          }),
          t.if((0, le._)`${qe.default.jsonPos} === ${qe.default.jsonLen}`, () =>
            t.return(qe.default.data),
          ),
          jo(e);
      },
    );
  }
  function zf(e) {
    let t;
    for (let r of L7.jtdForms)
      if (r in e.schema) {
        t = r;
        break;
      }
    t ? K7(e, U7[t]) : o0(e);
  }
  var B7 = QN(!0, QN(!1, jo));
  function K7(e, t) {
    let { gen: r, schema: n, data: s } = e;
    if (!n.nullable) return t(e);
    wu(e, "null", t, () => r.assign(s, null));
  }
  function G7(e) {
    let { gen: t, schema: r, data: n } = e;
    Mn(e, "[");
    let s = t.let("i", 0);
    t.assign(n, (0, le._)`[]`),
      i0(e, "]", () => {
        let i = t.let("el");
        zf({ ...e, schema: r.elements, data: i }), t.assign((0, le._)`${n}[${s}++]`, i);
      });
  }
  function J7(e) {
    let { gen: t, schema: r, data: n } = e;
    Mn(e, "{"), t.assign(n, (0, le._)`{}`), i0(e, "}", () => Q7(e, r.values));
  }
  function i0(e, t, r) {
    ZN(e, t, r), Mn(e, t);
  }
  function ZN(e, t, r) {
    let { gen: n } = e;
    n.for((0, le._)`;${qe.default.jsonPos}<${qe.default.jsonLen} && ${Vf(1)}!==${t};`, () => {
      r(), wu(e, ",", () => n.break(), s);
    });
    function s() {
      wu(e, t, () => {}, jo);
    }
  }
  function Q7(e, t) {
    let { gen: r } = e,
      n = r.let("key");
    Ii({ ...e, data: n }), Mn(e, ":"), tA(e, n, t);
  }
  function W7(e) {
    let { gen: t, data: r, schema: n } = e,
      { discriminator: s, mapping: i } = n;
    Mn(e, "{"), t.assign(r, (0, le._)`{}`);
    let o = t.const("pos", qe.default.jsonPos),
      a = t.let("value"),
      u = t.let("tag");
    ZN(e, "}", () => {
      let l = t.let("key");
      Ii({ ...e, data: l }),
        Mn(e, ":"),
        t.if(
          (0, le._)`${l} === ${s}`,
          () => {
            Ii({ ...e, data: u }), t.assign((0, le._)`${r}[${l}]`, u), t.break();
          },
          () => o0({ ...e, data: a }),
        );
    }),
      t.assign(qe.default.jsonPos, o),
      t.if((0, le._)`${u} === undefined`),
      ys(e, (0, le.str)`discriminator tag not found`);
    for (let l in i) t.elseIf((0, le._)`${u} === ${l}`), eA({ ...e, schema: i[l] }, s);
    t.else(), ys(e, (0, le.str)`discriminator value not in schema`), t.endIf();
  }
  function GN(e) {
    let { gen: t, data: r } = e;
    Mn(e, "{"), t.assign(r, (0, le._)`{}`), eA(e);
  }
  function eA(e, t) {
    let { gen: r, schema: n, data: s } = e,
      { properties: i, optionalProperties: o, additionalProperties: a } = n;
    if (
      (i0(e, "}", () => {
        let u = r.let("key");
        if ((Ii({ ...e, data: u }), Mn(e, ":"), r.if(!1), JN(e, u, i), JN(e, u, o), t)) {
          r.elseIf((0, le._)`${u} === ${t}`);
          let l = r.let("tag");
          Ii({ ...e, data: l });
        }
        r.else(),
          a
            ? o0({ ...e, data: (0, le._)`${s}[${u}]` })
            : ys(e, (0, le.str)`property ${u} not allowed`),
          r.endIf();
      }),
      i)
    ) {
      let u = (0, F7.hasPropFunc)(r),
        l = (0, le.and)(...Object.keys(i).map((c) => (0, le._)`${u}.call(${s}, ${c})`));
      r.if((0, le.not)(l), () => ys(e, (0, le.str)`missing required properties`));
    }
  }
  function JN(e, t, r = {}) {
    let { gen: n } = e;
    for (let s in r) n.elseIf((0, le._)`${t} === ${s}`), tA(e, t, r[s]);
  }
  function tA(e, t, r) {
    zf({ ...e, schema: r, data: (0, le._)`${e.data}[${t}]` });
  }
  function Y7(e) {
    let { gen: t, schema: r, data: n, self: s } = e;
    switch (r.type) {
      case "boolean":
        B7(e);
        break;
      case "string":
        Ii(e);
        break;
      case "timestamp": {
        Ii(e);
        let i = (0, YN.useFunc)(t, V7.default),
          { allowDate: o, parseDate: a } = s.opts,
          u = o ? (0, le._)`!${i}(${n}, true)` : (0, le._)`!${i}(${n})`,
          l = a
            ? (0, le.or)(
                u,
                (0, le._)`(${n} = new Date(${n}), false)`,
                (0, le._)`isNaN(${n}.valueOf())`,
              )
            : u;
        t.if(l, () => ys(e, (0, le.str)`invalid timestamp`));
        break;
      }
      case "float32":
      case "float64":
        r0(e);
        break;
      default: {
        let i = r.type;
        if (!s.opts.int32range && (i === "int32" || i === "uint32"))
          r0(e, 16),
            i === "uint32" &&
              t.if((0, le._)`${n} < 0`, () => ys(e, (0, le.str)`integer out of range`));
        else {
          let [o, a, u] = z7.intRange[i];
          r0(e, u),
            t.if((0, le._)`${n} < ${o} || ${n} > ${a}`, () =>
              ys(e, (0, le.str)`integer out of range`),
            );
        }
      }
    }
  }
  function Ii(e) {
    Mn(e, '"'), a0(e, s0.parseJsonString);
  }
  function X7(e) {
    let { gen: t, data: r, schema: n } = e,
      s = n.enum;
    Mn(e, '"'), t.if(!1);
    for (let i of s) {
      let o = JSON.stringify(i).slice(1);
      t.elseIf((0, le._)`${Vf(o.length)} === ${o}`),
        t.assign(r, (0, le.str)`${i}`),
        t.add(qe.default.jsonPos, o.length);
    }
    t.else(), jo(e), t.endIf();
  }
  function r0(e, t) {
    let { gen: r } = e;
    u0(e),
      r.if(
        (0, le._)`"-0123456789".indexOf(${Vf(1)}) < 0`,
        () => jo(e),
        () => a0(e, s0.parseJsonNumber, t),
      );
  }
  function QN(e, t) {
    return (r) => {
      let { gen: n, data: s } = r;
      wu(
        r,
        `${e}`,
        () => t(r),
        () => n.assign(s, e),
      );
    };
  }
  function Z7(e) {
    let { gen: t, self: r, definitions: n, schema: s, schemaEnv: i } = e,
      { ref: o } = s,
      a = n[o];
    if (!a) throw new x7.default(r.opts.uriResolver, "", o, `No definition ${o}`);
    if (!(0, M7.hasRef)(a)) return zf({ ...e, schema: a });
    let { root: u } = i,
      l = XN.call(r, new WN.SchemaEnv({ schema: a, root: u }), n);
    rA(e, eW(t, l), !0);
  }
  function eW(e, t) {
    return t.parse
      ? e.scopeValue("parse", { ref: t.parse })
      : (0, le._)`${e.scopeValue("wrapper", { ref: t })}.parse`;
  }
  function o0(e) {
    a0(e, s0.parseJson);
  }
  function a0(e, t, r) {
    rA(e, (0, YN.useFunc)(e.gen, t), r);
  }
  function rA(e, t, r) {
    let { gen: n, data: s } = e;
    n.assign(
      s,
      (0, le._)`${t}(${qe.default.json}, ${qe.default.jsonPos}${r ? (0, le._)`, ${r}` : le.nil})`,
    ),
      n.assign(qe.default.jsonPos, (0, le._)`${t}.position`),
      n.if((0, le._)`${s} === undefined`, () => ys(e, (0, le._)`${t}.message`));
  }
  function Mn(e, t) {
    wu(e, t, jo);
  }
  function wu(e, t, r, n) {
    let { gen: s } = e,
      i = t.length;
    u0(e),
      s.if(
        (0, le._)`${Vf(i)} === ${t}`,
        () => {
          s.add(qe.default.jsonPos, i), n?.(e);
        },
        () => r(e),
      );
  }
  function u0({ gen: e, char: t }) {
    e.code(
      (0,
      le._)`while((${t}=${qe.default.json}[${qe.default.jsonPos}],${t}===" "||${t}==="\\n"||${t}==="\\r"||${t}==="\\t"))${qe.default.jsonPos}++;`,
    );
  }
  function Vf(e) {
    return e === 1
      ? (0, le._)`${qe.default.json}[${qe.default.jsonPos}]`
      : (0, le._)`${qe.default.json}.slice(${qe.default.jsonPos}, ${qe.default.jsonPos}+${e})`;
  }
  function jo(e) {
    ys(e, (0, le._)`"unexpected token " + ${qe.default.json}[${qe.default.jsonPos}]`);
  }
  function ys({ gen: e, parseName: t }, r) {
    e.assign((0, le._)`${t}.message`, r),
      e.assign((0, le._)`${t}.position`, qe.default.jsonPos),
      e.return(n0);
  }
});
var d0 = b((St, f0) => {
  "use strict";
  Object.defineProperty(St, "__esModule", { value: !0 });
  St.MissingRefError =
    St.ValidationError =
    St.CodeGen =
    St.Name =
    St.nil =
    St.stringify =
    St.str =
    St._ =
    St.KeywordCxt =
    St.Ajv =
      void 0;
  var tW = _y(),
    rW = CN(),
    nW = jN(),
    sW = HN(),
    iW = nA(),
    c0 = "JTD-meta-schema",
    Lo = class extends tW.default {
      constructor(t = {}) {
        super({ ...t, jtd: !0 });
      }
      _addVocabularies() {
        super._addVocabularies(), this.addVocabulary(rW.default);
      }
      _addDefaultMetaSchema() {
        super._addDefaultMetaSchema(), this.opts.meta && this.addMetaSchema(nW.default, c0, !1);
      }
      defaultMeta() {
        return (this.opts.defaultMeta = super.defaultMeta() || (this.getSchema(c0) ? c0 : void 0));
      }
      compileSerializer(t) {
        let r = this._addSchema(t);
        return r.serialize || this._compileSerializer(r);
      }
      compileParser(t) {
        let r = this._addSchema(t);
        return r.parse || this._compileParser(r);
      }
      _compileSerializer(t) {
        if ((sW.default.call(this, t, t.schema.definitions || {}), !t.serialize))
          throw new Error("ajv implementation error");
        return t.serialize;
      }
      _compileParser(t) {
        if ((iW.default.call(this, t, t.schema.definitions || {}), !t.parse))
          throw new Error("ajv implementation error");
        return t.parse;
      }
    };
  St.Ajv = Lo;
  f0.exports = St = Lo;
  f0.exports.Ajv = Lo;
  Object.defineProperty(St, "__esModule", { value: !0 });
  St.default = Lo;
  var oW = vo();
  Object.defineProperty(St, "KeywordCxt", {
    enumerable: !0,
    get: function () {
      return oW.KeywordCxt;
    },
  });
  var xo = he();
  Object.defineProperty(St, "_", {
    enumerable: !0,
    get: function () {
      return xo._;
    },
  });
  Object.defineProperty(St, "str", {
    enumerable: !0,
    get: function () {
      return xo.str;
    },
  });
  Object.defineProperty(St, "stringify", {
    enumerable: !0,
    get: function () {
      return xo.stringify;
    },
  });
  Object.defineProperty(St, "nil", {
    enumerable: !0,
    get: function () {
      return xo.nil;
    },
  });
  Object.defineProperty(St, "Name", {
    enumerable: !0,
    get: function () {
      return xo.Name;
    },
  });
  Object.defineProperty(St, "CodeGen", {
    enumerable: !0,
    get: function () {
      return xo.CodeGen;
    },
  });
  var aW = Ya();
  Object.defineProperty(St, "ValidationError", {
    enumerable: !0,
    get: function () {
      return aW.default;
    },
  });
  var uW = ls();
  Object.defineProperty(St, "MissingRefError", {
    enumerable: !0,
    get: function () {
      return uW.default;
    },
  });
});
var h0 = b((_ae, sA) => {
  "use strict";
  var lW = hg();
  sA.exports = Object.freeze({
    coerceTypes: "array",
    useDefaults: !0,
    removeAdditional: !0,
    uriResolver: lW,
    addUsedSchema: !1,
    allErrors: !1,
  });
});
var cA = b((zn) => {
  "use strict";
  Object.defineProperty(zn, "__esModule", { value: !0 });
  zn.formatNames = zn.fastFormats = zn.fullFormats = void 0;
  function Fo(e, t) {
    return { validate: e, compare: t };
  }
  zn.fullFormats = {
    date: Fo(aA, y0),
    time: Fo(uA, g0),
    "date-time": Fo(hW, lA),
    duration: /^P(?!$)((\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+S)?)?|(\d+W)?)$/,
    uri: yW,
    "uri-reference":
      /^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i,
    "uri-template":
      /^(?:(?:[^\x00-\x20"'<>%\\^`{|}]|%[0-9a-f]{2})|\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?)*\})*$/i,
    url: /^(?:https?|ftp):\/\/(?:\S+(?::\S*)?@)?(?:(?!(?:10|127)(?:\.\d{1,3}){3})(?!(?:169\.254|192\.168)(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)(?:\.(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)*(?:\.(?:[a-z\u{00a1}-\u{ffff}]{2,})))(?::\d{2,5})?(?:\/[^\s]*)?$/iu,
    email:
      /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i,
    hostname:
      /^(?=.{1,253}\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\.?$/i,
    ipv4: /^(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/,
    ipv6: /^((([0-9a-f]{1,4}:){7}([0-9a-f]{1,4}|:))|(([0-9a-f]{1,4}:){6}(:[0-9a-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){5}(((:[0-9a-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){4}(((:[0-9a-f]{1,4}){1,3})|((:[0-9a-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){3}(((:[0-9a-f]{1,4}){1,4})|((:[0-9a-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){2}(((:[0-9a-f]{1,4}){1,5})|((:[0-9a-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){1}(((:[0-9a-f]{1,4}){1,6})|((:[0-9a-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9a-f]{1,4}){1,7})|((:[0-9a-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))$/i,
    regex: EW,
    uuid: /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i,
    "json-pointer": /^(?:\/(?:[^~/]|~0|~1)*)*$/,
    "json-pointer-uri-fragment": /^#(?:\/(?:[a-z0-9_\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i,
    "relative-json-pointer": /^(?:0|[1-9][0-9]*)(?:#|(?:\/(?:[^~/]|~0|~1)*)*)$/,
    byte: gW,
    int32: { type: "number", validate: vW },
    int64: { type: "number", validate: bW },
    float: { type: "number", validate: oA },
    double: { type: "number", validate: oA },
    password: !0,
    binary: !0,
  };
  zn.fastFormats = {
    ...zn.fullFormats,
    date: Fo(/^\d\d\d\d-[0-1]\d-[0-3]\d$/, y0),
    time: Fo(/^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)?$/i, g0),
    "date-time": Fo(
      /^\d\d\d\d-[0-1]\d-[0-3]\d[t\s](?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i,
      lA,
    ),
    uri: /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/)?[^\s]*$/i,
    "uri-reference": /^(?:(?:[a-z][a-z0-9+\-.]*:)?\/?\/)?(?:[^\\\s#][^\s#]*)?(?:#[^\\\s]*)?$/i,
    email:
      /^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$/i,
  };
  zn.formatNames = Object.keys(zn.fullFormats);
  function cW(e) {
    return e % 4 === 0 && (e % 100 !== 0 || e % 400 === 0);
  }
  var fW = /^(\d\d\d\d)-(\d\d)-(\d\d)$/,
    dW = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
  function aA(e) {
    let t = fW.exec(e);
    if (!t) return !1;
    let r = +t[1],
      n = +t[2],
      s = +t[3];
    return n >= 1 && n <= 12 && s >= 1 && s <= (n === 2 && cW(r) ? 29 : dW[n]);
  }
  function y0(e, t) {
    if (e && t) return e > t ? 1 : e < t ? -1 : 0;
  }
  var p0 = /^(\d\d):(\d\d):(\d\d)(\.\d+)?(z|[+-]\d\d(?::?\d\d)?)?$/i;
  function uA(e, t) {
    let r = p0.exec(e);
    if (!r) return !1;
    let n = +r[1],
      s = +r[2],
      i = +r[3],
      o = r[5];
    return (
      ((n <= 23 && s <= 59 && i <= 59) || (n === 23 && s === 59 && i === 60)) && (!t || o !== "")
    );
  }
  function g0(e, t) {
    if (!(e && t)) return;
    let r = p0.exec(e),
      n = p0.exec(t);
    if (r && n)
      return (
        (e = r[1] + r[2] + r[3] + (r[4] || "")),
        (t = n[1] + n[2] + n[3] + (n[4] || "")),
        e > t ? 1 : e < t ? -1 : 0
      );
  }
  var m0 = /t|\s/i;
  function hW(e) {
    let t = e.split(m0);
    return t.length === 2 && aA(t[0]) && uA(t[1], !0);
  }
  function lA(e, t) {
    if (!(e && t)) return;
    let [r, n] = e.split(m0),
      [s, i] = t.split(m0),
      o = y0(r, s);
    if (o !== void 0) return o || g0(n, i);
  }
  var pW = /\/|:/,
    mW =
      /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\?(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
  function yW(e) {
    return pW.test(e) && mW.test(e);
  }
  var iA = /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/gm;
  function gW(e) {
    return (iA.lastIndex = 0), iA.test(e);
  }
  var _W = -(2 ** 31),
    SW = 2 ** 31 - 1;
  function vW(e) {
    return Number.isInteger(e) && e <= SW && e >= _W;
  }
  function bW(e) {
    return Number.isInteger(e);
  }
  function oA() {
    return !0;
  }
  var wW = /[^\\]\\Z/;
  function EW(e) {
    if (wW.test(e)) return !1;
    try {
      return new RegExp(e), !0;
    } catch {
      return !1;
    }
  }
});
var fA = b((Mo) => {
  "use strict";
  Object.defineProperty(Mo, "__esModule", { value: !0 });
  Mo.formatLimitDefinition = void 0;
  var RW = fu(),
    wn = he(),
    Qs = wn.operators,
    Uf = {
      formatMaximum: { okStr: "<=", ok: Qs.LTE, fail: Qs.GT },
      formatMinimum: { okStr: ">=", ok: Qs.GTE, fail: Qs.LT },
      formatExclusiveMaximum: { okStr: "<", ok: Qs.LT, fail: Qs.GTE },
      formatExclusiveMinimum: { okStr: ">", ok: Qs.GT, fail: Qs.LTE },
    },
    TW = {
      message: ({ keyword: e, schemaCode: t }) => wn.str`should be ${Uf[e].okStr} ${t}`,
      params: ({ keyword: e, schemaCode: t }) => wn._`{comparison: ${Uf[e].okStr}, limit: ${t}}`,
    };
  Mo.formatLimitDefinition = {
    keyword: Object.keys(Uf),
    type: "string",
    schemaType: "string",
    $data: !0,
    error: TW,
    code(e) {
      let { gen: t, data: r, schemaCode: n, keyword: s, it: i } = e,
        { opts: o, self: a } = i;
      if (!o.validateFormats) return;
      let u = new RW.KeywordCxt(i, a.RULES.all.format.definition, "format");
      u.$data ? l() : c();
      function l() {
        let d = t.scopeValue("formats", { ref: a.formats, code: o.code.formats }),
          h = t.const("fmt", wn._`${d}[${u.schemaCode}]`);
        e.fail$data(
          wn.or(
            wn._`typeof ${h} != "object"`,
            wn._`${h} instanceof RegExp`,
            wn._`typeof ${h}.compare != "function"`,
            f(h),
          ),
        );
      }
      function c() {
        let d = u.schema,
          h = a.formats[d];
        if (!h || h === !0) return;
        if (typeof h != "object" || h instanceof RegExp || typeof h.compare != "function")
          throw new Error(`"${s}": format "${d}" does not define "compare" function`);
        let p = t.scopeValue("formats", {
          key: d,
          ref: h,
          code: o.code.formats ? wn._`${o.code.formats}${wn.getProperty(d)}` : void 0,
        });
        e.fail$data(f(p));
      }
      function f(d) {
        return wn._`${d}.compare(${r}, ${n}) ${Uf[s].fail} 0`;
      }
    },
    dependencies: ["format"],
  };
  var PW = (e) => (e.addKeyword(Mo.formatLimitDefinition), e);
  Mo.default = PW;
});
var mA = b((Eu, pA) => {
  "use strict";
  Object.defineProperty(Eu, "__esModule", { value: !0 });
  var zo = cA(),
    $W = fA(),
    _0 = he(),
    dA = new _0.Name("fullFormats"),
    OW = new _0.Name("fastFormats"),
    S0 = (e, t = { keywords: !0 }) => {
      if (Array.isArray(t)) return hA(e, t, zo.fullFormats, dA), e;
      let [r, n] = t.mode === "fast" ? [zo.fastFormats, OW] : [zo.fullFormats, dA],
        s = t.formats || zo.formatNames;
      return hA(e, s, r, n), t.keywords && $W.default(e), e;
    };
  S0.get = (e, t = "full") => {
    let n = (t === "fast" ? zo.fastFormats : zo.fullFormats)[e];
    if (!n) throw new Error(`Unknown format "${e}"`);
    return n;
  };
  function hA(e, t, r, n) {
    var s, i;
    ((s = (i = e.opts.code).formats) !== null && s !== void 0) ||
      (i.formats = _0._`require("ajv-formats/dist/formats").${n}`);
    for (let o of t) e.addFormat(o, r[o]);
  }
  pA.exports = Eu = S0;
  Object.defineProperty(Eu, "__esModule", { value: !0 });
  Eu.default = S0;
});
var _A = b((bae, gA) => {
  "use strict";
  var NW = fu().default,
    AW = d0(),
    yA = h0(),
    v0 = class {
      constructor(t, r) {
        r.mode === "JTD"
          ? (this.ajv = new AW(Object.assign({}, yA, r.customOptions)))
          : (this.ajv = new NW(Object.assign({}, yA, r.customOptions)));
        let n = !0;
        if (r.plugins && r.plugins.length > 0)
          for (let i of r.plugins)
            Array.isArray(i)
              ? ((n = n && i[0].name !== "formatsPlugin"), i[0](this.ajv, i[1]))
              : ((n = n && i.name !== "formatsPlugin"), i(this.ajv));
        n && mA()(this.ajv);
        let s = Object.values(t);
        for (let i of s) this.ajv.addSchema(i);
      }
      buildValidatorFunction({ schema: t }) {
        if (t.$id) {
          let r = this.ajv.getSchema(t.$id);
          if (r) return r;
        }
        return this.ajv.compile(t);
      }
    };
  gA.exports = v0;
});
var vA = b((wae, SA) => {
  "use strict";
  var IW = d0(),
    CW = h0(),
    b0 = class {
      constructor(t, r) {
        this.ajv = new IW(Object.assign({}, CW, r));
      }
      buildSerializerFunction({ schema: t }) {
        return this.ajv.compileSerializer(t);
      }
    };
  SA.exports = b0;
});
var EA = b((Tu, wA) => {
  "use strict";
  Object.defineProperty(Tu, "__esModule", { value: !0 });
  var Ru = Yc(),
    En = fo();
  function bA(e, t) {
    if (!e.opts.code.source)
      throw new Error("moduleCode: ajv instance must have code.source option");
    let { _n: r } = e.scope.opts;
    return typeof t == "function"
      ? s(t.source)
      : t !== void 0
        ? i(t, n)
        : i(e.schemas, (a) => (a.meta ? void 0 : e.compile(a.schema)));
    function n(a) {
      let u = e.getSchema(a);
      if (!u) throw new Error(`moduleCode: no schema with id ${a}`);
      return u;
    }
    function s(a) {
      let u = {},
        l = a?.validateName,
        c = o(u, a);
      return e.opts.code.esm
        ? `"use strict";${r}export const validate = ${l};${r}export default ${l};${r}${c}`
        : `"use strict";${r}module.exports = ${l};${r}module.exports.default = ${l};${r}${c}`;
    }
    function i(a, u) {
      var l;
      let c = {},
        f = (0, En._)`"use strict";`;
      for (let d in a) {
        let h = u(a[d]);
        if (h) {
          let p = o(c, h.source),
            y = e.opts.code.esm
              ? (0, En._)`export const ${(0, En.getEsmExportName)(d)}`
              : (0, En._)`exports${(0, En.getProperty)(d)}`;
          f = (0,
          En._)`${f}${r}${y} = ${(l = h.source) === null || l === void 0 ? void 0 : l.validateName};${r}${p}`;
        }
      }
      return `${f}`;
    }
    function o(a, u) {
      if (!u) throw new Error('moduleCode: function does not have "source" property');
      if (d(u.validateName) === Ru.UsedValueState.Completed) return En.nil;
      h(u.validateName, Ru.UsedValueState.Started);
      let l = e.scope.scopeCode(u.scopeValues, a, f),
        c = new En._Code(`${l}${r}${u.validateCode}`);
      return u.evaluated ? (0, En._)`${c}${u.validateName}.evaluated = ${u.evaluated};${r}` : c;
      function f(p) {
        var y;
        let _ = (y = p.value) === null || y === void 0 ? void 0 : y.ref;
        if (p.prefix === "validate" && typeof _ == "function") return o(a, _.source);
        if ((p.prefix === "root" || p.prefix === "wrapper") && typeof _ == "object") {
          let { validate: S, validateName: E } = _;
          if (!E) throw new Error("ajv internal error");
          let g = e.opts.code.es5 ? Ru.varKinds.var : Ru.varKinds.const,
            m = (0, En._)`${g} ${p} = {validate: ${E}};`;
          if (d(E) === Ru.UsedValueState.Started) return m;
          let T = o(a, S?.source);
          return (0, En._)`${m}${r}${T}`;
        }
      }
      function d(p) {
        var y;
        return (y = a[p.prefix]) === null || y === void 0 ? void 0 : y.get(p);
      }
      function h(p, y) {
        let { prefix: _ } = p;
        (a[_] = a[_] || new Map()).set(p, y);
      }
    }
  }
  wA.exports = Tu = bA;
  Object.defineProperty(Tu, "__esModule", { value: !0 });
  Tu.default = bA;
});
var PA = b((Eae, TA) => {
  "use strict";
  var RA = w0(),
    kW = EA().default;
  function DW(e = { readMode: !0 }) {
    if (e.readMode === !0 && !e.restoreFunction)
      throw new Error("You must provide a restoreFunction options when readMode ON");
    if (e.readMode !== !0 && !e.storeFunction)
      throw new Error("You must provide a storeFunction options when readMode OFF");
    if (e.readMode === !0)
      return function () {
        return function (n) {
          return e.restoreFunction(n);
        };
      };
    let t = RA();
    return function (n, s = {}) {
      (!s.customOptions || !s.customOptions.code) &&
        (s.customOptions = Object.assign({}, s.customOptions, { code: { source: !0 } }));
      let i = t(n, s);
      return function (o) {
        let a = i(o),
          u = kW(i[RA.AjvReference].ajv, a);
        return e.storeFunction(o, u), a;
      };
    };
  }
  TA.exports = DW;
});
var w0 = b((Rae, Vo) => {
  "use strict";
  var OA = Symbol.for("fastify.ajv-compiler.reference"),
    qW = _A(),
    jW = vA();
  function E0(e) {
    let t = new Map(),
      r = new Map();
    return e && e.jtdSerializer === !0
      ? function (s, i) {
          let o = $A({}, i);
          if (r.has(o)) return r.get(o);
          let a = new jW(s, i),
            u = a.buildSerializerFunction.bind(a);
          return r.set(o, u), u;
        }
      : function (s, i) {
          let o = $A(s, i.customOptions);
          if (t.has(o)) return t.get(o);
          let a = new qW(s, i),
            u = a.buildValidatorFunction.bind(a);
          return t.set(o, u), i.customOptions.code !== void 0 && (u[OA] = a), u;
        };
  }
  function $A(e, t) {
    let r = JSON.stringify(e),
      n = JSON.stringify(t);
    return `${r}${n}`;
  }
  Vo.exports = E0;
  Vo.exports.default = E0;
  Vo.exports.AjvCompiler = E0;
  Vo.exports.AjvReference = OA;
  Vo.exports.StandaloneValidator = PA();
});
var R0 = b((Tae, NA) => {
  "use strict";
  var { buildSchemas: LW } = wa(),
    xW = qg(),
    FW = w0();
  function MW(e, t) {
    if (e) return new Uo(e, t);
    let r = Object.assign({ buildValidator: null, buildSerializer: null }, t?.compilersFactory);
    r.buildValidator || (r.buildValidator = FW()), r.buildSerializer || (r.buildSerializer = xW());
    let n = {
      bucket: (t && t.bucket) || LW,
      compilersFactory: r,
      isCustomValidatorCompiler: typeof t?.compilersFactory?.buildValidator == "function",
      isCustomSerializerCompiler: typeof t?.compilersFactory?.buildValidator == "function",
    };
    return new Uo(void 0, n);
  }
  var Uo = class {
    constructor(t, r) {
      (this.opts = r || t?.opts),
        (this.addedSchemas = !1),
        (this.compilersFactory = this.opts.compilersFactory),
        t
          ? ((this.schemaBucket = this.opts.bucket(t.getSchemas())),
            (this.validatorCompiler = t.getValidatorCompiler()),
            (this.serializerCompiler = t.getSerializerCompiler()),
            (this.isCustomValidatorCompiler = t.isCustomValidatorCompiler),
            (this.isCustomSerializerCompiler = t.isCustomSerializerCompiler),
            (this.parent = t))
          : ((this.schemaBucket = this.opts.bucket()),
            (this.isCustomValidatorCompiler = this.opts.isCustomValidatorCompiler || !1),
            (this.isCustomSerializerCompiler = this.opts.isCustomSerializerCompiler || !1));
    }
    add(t) {
      return (this.addedSchemas = !0), this.schemaBucket.add(t);
    }
    getSchema(t) {
      return this.schemaBucket.getSchema(t);
    }
    getSchemas() {
      return this.schemaBucket.getSchemas();
    }
    setValidatorCompiler(t) {
      (this.compilersFactory = Object.assign({}, this.compilersFactory, {
        buildValidator: () => t,
      })),
        (this.validatorCompiler = t),
        (this.isCustomValidatorCompiler = !0);
    }
    setSerializerCompiler(t) {
      (this.compilersFactory = Object.assign({}, this.compilersFactory, {
        buildSerializer: () => t,
      })),
        (this.serializerCompiler = t),
        (this.isCustomSerializerCompiler = !0);
    }
    getValidatorCompiler() {
      return this.validatorCompiler || (this.parent && this.parent.getValidatorCompiler());
    }
    getSerializerCompiler() {
      return this.serializerCompiler || (this.parent && this.parent.getSerializerCompiler());
    }
    getSerializerBuilder() {
      return (
        this.compilersFactory.buildSerializer || (this.parent && this.parent.getSerializerBuilder())
      );
    }
    getValidatorBuilder() {
      return (
        this.compilersFactory.buildValidator || (this.parent && this.parent.getValidatorBuilder())
      );
    }
    setupValidator(t) {
      (this.validatorCompiler !== void 0 && !this.addedSchemas) ||
        (this.validatorCompiler = this.getValidatorBuilder()(
          this.schemaBucket.getSchemas(),
          t.ajv,
        ));
    }
    setupSerializer(t) {
      (this.serializerCompiler !== void 0 && !this.addedSchemas) ||
        (this.serializerCompiler = this.getSerializerBuilder()(
          this.schemaBucket.getSchemas(),
          t.serializerOpts,
        ));
    }
  };
  Uo.buildSchemaController = MW;
  NA.exports = Uo;
});
var A0 = b((Pae, N0) => {
  "use strict";
  var T0 = lm(),
    $0 = require("node:assert"),
    O0 = Symbol.for("registered-plugin"),
    { kTestInternals: zW } = Vt(),
    { exist: VW, existReply: UW, existRequest: HW } = Sm(),
    { FST_ERR_PLUGIN_VERSION_MISMATCH: BW, FST_ERR_PLUGIN_NOT_PRESENT_IN_INSTANCE: KW } = tr(),
    { FSTWRN002: GW } = ts();
  function Pu(e) {
    return e[Symbol.for("plugin-meta")];
  }
  function AA(e) {
    let t = IA(e);
    if (t) return t;
    let r = require.cache;
    if (r) {
      let n = Object.keys(r);
      for (let s = 0; s < n.length; s++) {
        let i = n[s];
        if (r[i].exports === e) return i;
      }
    }
    return e.name ? e.name : null;
  }
  function JW(e) {
    return e
      .toString()
      .split(
        `
`,
      )
      .slice(0, 2)
      .map((t) => t.trim())
      .join(" -- ");
  }
  function IA(e) {
    return e[Symbol.for("fastify.display-name")];
  }
  function CA(e) {
    return !!e[Symbol.for("skip-override")];
  }
  function kA(e) {
    let t = Pu(e);
    if (!t) return;
    let r = t.dependencies;
    r &&
      ($0(Array.isArray(r), "The dependencies should be an array of strings"),
      r.forEach((n) => {
        $0(
          this[O0].indexOf(n) > -1,
          `The dependency '${n}' of plugin '${t.name}' is not registered`,
        );
      }));
  }
  function DA(e) {
    let t = Pu(e);
    if (!t) return;
    let { decorators: r, name: n } = t;
    r &&
      (r.fastify && P0(this, "Fastify", r.fastify, n),
      r.reply && P0(this, "Reply", r.reply, n),
      r.request && P0(this, "Request", r.request, n));
  }
  var QW = { Fastify: VW, Request: HW, Reply: UW };
  function P0(e, t, r, n) {
    $0(Array.isArray(r), "The decorators should be an array of strings"),
      r.forEach((s) => {
        let i = typeof n == "string" ? ` required by '${n}'` : "";
        if (!QW[t].call(e, s)) throw new KW(s, i, t);
      });
  }
  function WW(e) {
    let t = Pu(e);
    if (!t) return;
    let r = t.fastify,
      n = /-rc.+$/.test(this.version);
    if (
      !(n === !0 && T0.gt(this.version, T0.coerce(r)) === !0) &&
      r &&
      T0.satisfies(this.version, r, { includePrerelease: n }) === !1
    )
      throw new BW(t.name, r, this.version);
  }
  function YW(e) {
    let t = Pu(e);
    if (!t) return;
    let r = t.name;
    if (r) return this[O0].push(r), r;
  }
  function XW(e, t) {
    e.constructor.name === "AsyncFunction" && e.length === 3 && GW(t || "anonymous");
  }
  function ZW(e) {
    let t = YW.call(this, e) || AA(e);
    return XW.call(this, e, t), WW.call(this, e), DA.call(this, e), kA.call(this, e), CA(e);
  }
  N0.exports = {
    getPluginName: AA,
    getFuncPreview: JW,
    kRegisteredPlugins: O0,
    getDisplayName: IA,
    registerPlugin: ZW,
  };
  N0.exports[zW] = {
    shouldSkipOverride: CA,
    getMeta: Pu,
    checkDecorators: DA,
    checkDependencies: kA,
  };
});
var Hf = b(($ae, qA) => {
  "use strict";
  function eY(e, t) {
    let r = t || rY();
    return e ? nY(e, r) : r;
  }
  function tY(e, t) {
    return e.genReqId(t);
  }
  function rY() {
    let t = 0;
    return function () {
      return (t = (t + 1) & 2147483647), `req-${t.toString(36)}`;
    };
  }
  function nY(e, t) {
    return function (r) {
      return r.headers[e] || t(r);
    };
  }
  qA.exports = { getGenReqId: tY, reqIdGenFactory: eY };
});
var FA = b((Oae, xA) => {
  "use strict";
  var jA = 12,
    sY = 0,
    I0 = [
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
      2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
      3, 3, 3, 3, 3, 3, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
      5, 5, 5, 5, 5, 5, 5, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 8, 7, 7, 10, 9, 9, 9, 11, 4, 4, 4,
      4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 0, 0, 0, 0, 24, 36, 48, 60,
      72, 84, 96, 0, 12, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24,
      24, 24, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 24, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 48, 48, 48, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 48, 48, 0, 0, 0, 0, 0, 0, 0, 0, 0, 48, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 127,
      63, 63, 63, 0, 31, 15, 15, 15, 7, 7, 7,
    ];
  function iY(e) {
    var t = e.indexOf("%");
    if (t === -1) return e;
    for (var r = e.length, n = "", s = 0, i = 0, o = t, a = jA; t > -1 && t < r; ) {
      var u = LA(e[t + 1], 4),
        l = LA(e[t + 2], 0),
        c = u | l,
        f = I0[c];
      if (((a = I0[256 + a + f]), (i = (i << 6) | (c & I0[364 + f])), a === jA))
        (n += e.slice(s, o)),
          (n +=
            i <= 65535
              ? String.fromCharCode(i)
              : String.fromCharCode(55232 + (i >> 10), 56320 + (i & 1023))),
          (i = 0),
          (s = t + 3),
          (t = o = e.indexOf("%", s));
      else {
        if (a === sY) return null;
        if (((t += 3), t < r && e.charCodeAt(t) === 37)) continue;
        return null;
      }
    }
    return n + e.slice(s);
  }
  var oY = {
    0: 0,
    1: 1,
    2: 2,
    3: 3,
    4: 4,
    5: 5,
    6: 6,
    7: 7,
    8: 8,
    9: 9,
    a: 10,
    A: 10,
    b: 11,
    B: 11,
    c: 12,
    C: 12,
    d: 13,
    D: 13,
    e: 14,
    E: 14,
    f: 15,
    F: 15,
  };
  function LA(e, t) {
    var r = oY[e];
    return r === void 0 ? 255 : r << t;
  }
  xA.exports = iY;
});
var HA = b((Nae, UA) => {
  "use strict";
  var MA = FA(),
    zA = /\+/g,
    VA = function () {};
  VA.prototype = Object.create(null);
  function aY(e) {
    let t = new VA();
    if (typeof e != "string") return t;
    let r = e.length,
      n = "",
      s = "",
      i = -1,
      o = -1,
      a = !1,
      u = !1,
      l = !1,
      c = !1,
      f = !1,
      d = 0;
    for (let h = 0; h < r + 1; h++)
      if (((d = h !== r ? e.charCodeAt(h) : 38), d === 38)) {
        if (((f = o > i), f || (o = h), (n = e.slice(i + 1, o)), f || n.length > 0)) {
          l && (n = n.replace(zA, " ")),
            a && (n = MA(n) || n),
            f && ((s = e.slice(o + 1, h)), c && (s = s.replace(zA, " ")), u && (s = MA(s) || s));
          let p = t[n];
          p === void 0 ? (t[n] = s) : p.pop ? p.push(s) : (t[n] = [p, s]);
        }
        (s = ""), (i = h), (o = h), (a = !1), (u = !1), (l = !1), (c = !1);
      } else
        d === 61
          ? o <= i
            ? (o = h)
            : (u = !0)
          : d === 43
            ? o > i
              ? (c = !0)
              : (l = !0)
            : d === 37 && (o > i ? (u = !0) : (a = !0));
    return t;
  }
  UA.exports = aY;
});
var KA = b((Aae, BA) => {
  var Vn = Array.from(
      { length: 256 },
      (e, t) => "%" + ((t < 16 ? "0" : "") + t.toString(16)).toUpperCase(),
    ),
    uY = new Int8Array([
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0,
      0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0,
      0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0,
      0, 0, 1, 0,
    ]);
  function lY(e) {
    let t = e.length;
    if (t === 0) return "";
    let r = "",
      n = 0,
      s = 0;
    e: for (; s < t; s++) {
      let i = e.charCodeAt(s);
      for (; i < 128; ) {
        if ((uY[i] !== 1 && (n < s && (r += e.slice(n, s)), (n = s + 1), (r += Vn[i])), ++s === t))
          break e;
        i = e.charCodeAt(s);
      }
      if ((n < s && (r += e.slice(n, s)), i < 2048)) {
        (n = s + 1), (r += Vn[192 | (i >> 6)] + Vn[128 | (i & 63)]);
        continue;
      }
      if (i < 55296 || i >= 57344) {
        (n = s + 1), (r += Vn[224 | (i >> 12)] + Vn[128 | ((i >> 6) & 63)] + Vn[128 | (i & 63)]);
        continue;
      }
      if ((++s, s >= t)) throw new Error("URI malformed");
      let o = e.charCodeAt(s) & 1023;
      (n = s + 1),
        (i = 65536 + (((i & 1023) << 10) | o)),
        (r +=
          Vn[240 | (i >> 18)] +
          Vn[128 | ((i >> 12) & 63)] +
          Vn[128 | ((i >> 6) & 63)] +
          Vn[128 | (i & 63)]);
    }
    return n === 0 ? e : n < t ? r + e.slice(n) : r;
  }
  BA.exports = { encodeString: lY };
});
var QA = b((Iae, JA) => {
  "use strict";
  var { encodeString: C0 } = KA();
  function GA(e) {
    let t = typeof e;
    return t === "string"
      ? C0(e)
      : t === "bigint"
        ? e.toString()
        : t === "boolean"
          ? e
            ? "true"
            : "false"
          : t === "number" && Number.isFinite(e)
            ? e < 1e21
              ? "" + e
              : C0("" + e)
            : "";
  }
  function cY(e) {
    let t = "";
    if (e === null || typeof e != "object") return t;
    let r = "&",
      n = Object.keys(e),
      s = n.length,
      i = 0;
    for (let o = 0; o < s; o++) {
      let a = n[o],
        u = e[a],
        l = C0(a) + "=";
      if ((o && (t += r), Array.isArray(u))) {
        i = u.length;
        for (let c = 0; c < i; c++) c && (t += r), (t += l), (t += GA(u[c]));
      } else (t += l), (t += GA(u));
    }
    return t;
  }
  JA.exports = cY;
});
var ZA = b((Cae, $u) => {
  "use strict";
  var WA = HA(),
    YA = QA(),
    XA = { parse: WA, stringify: YA };
  $u.exports = XA;
  $u.exports.default = XA;
  $u.exports.parse = WA;
  $u.exports.stringify = YA;
});
var tI = b((eI) => {
  "use strict";
  Object.defineProperty(eI, "__esModule", { value: !0 });
});
var rI = b((Ou) => {
  "use strict";
  Object.defineProperty(Ou, "__esModule", { value: !0 });
  Ou.types = void 0;
  var fY;
  (function (e) {
    (e[(e.ROOT = 0)] = "ROOT"),
      (e[(e.GROUP = 1)] = "GROUP"),
      (e[(e.POSITION = 2)] = "POSITION"),
      (e[(e.SET = 3)] = "SET"),
      (e[(e.RANGE = 4)] = "RANGE"),
      (e[(e.REPETITION = 5)] = "REPETITION"),
      (e[(e.REFERENCE = 6)] = "REFERENCE"),
      (e[(e.CHAR = 7)] = "CHAR");
  })((fY = Ou.types || (Ou.types = {})));
});
var sI = b((nI) => {
  "use strict";
  Object.defineProperty(nI, "__esModule", { value: !0 });
});
var _s = b((gs) => {
  "use strict";
  var dY =
      (gs && gs.__createBinding) ||
      (Object.create
        ? function (e, t, r, n) {
            n === void 0 && (n = r),
              Object.defineProperty(e, n, {
                enumerable: !0,
                get: function () {
                  return t[r];
                },
              });
          }
        : function (e, t, r, n) {
            n === void 0 && (n = r), (e[n] = t[r]);
          }),
    k0 =
      (gs && gs.__exportStar) ||
      function (e, t) {
        for (var r in e)
          r !== "default" && !Object.prototype.hasOwnProperty.call(t, r) && dY(t, e, r);
      };
  Object.defineProperty(gs, "__esModule", { value: !0 });
  k0(tI(), gs);
  k0(rI(), gs);
  k0(sI(), gs);
});
var Bf = b((ar) => {
  "use strict";
  Object.defineProperty(ar, "__esModule", { value: !0 });
  ar.anyChar =
    ar.notWhitespace =
    ar.whitespace =
    ar.notInts =
    ar.ints =
    ar.notWords =
    ar.words =
      void 0;
  var Ge = _s(),
    iI = () => [{ type: Ge.types.RANGE, from: 48, to: 57 }],
    oI = () => [
      { type: Ge.types.CHAR, value: 95 },
      { type: Ge.types.RANGE, from: 97, to: 122 },
      { type: Ge.types.RANGE, from: 65, to: 90 },
      { type: Ge.types.RANGE, from: 48, to: 57 },
    ],
    aI = () => [
      { type: Ge.types.CHAR, value: 9 },
      { type: Ge.types.CHAR, value: 10 },
      { type: Ge.types.CHAR, value: 11 },
      { type: Ge.types.CHAR, value: 12 },
      { type: Ge.types.CHAR, value: 13 },
      { type: Ge.types.CHAR, value: 32 },
      { type: Ge.types.CHAR, value: 160 },
      { type: Ge.types.CHAR, value: 5760 },
      { type: Ge.types.RANGE, from: 8192, to: 8202 },
      { type: Ge.types.CHAR, value: 8232 },
      { type: Ge.types.CHAR, value: 8233 },
      { type: Ge.types.CHAR, value: 8239 },
      { type: Ge.types.CHAR, value: 8287 },
      { type: Ge.types.CHAR, value: 12288 },
      { type: Ge.types.CHAR, value: 65279 },
    ],
    hY = () => [
      { type: Ge.types.CHAR, value: 10 },
      { type: Ge.types.CHAR, value: 13 },
      { type: Ge.types.CHAR, value: 8232 },
      { type: Ge.types.CHAR, value: 8233 },
    ];
  ar.words = () => ({ type: Ge.types.SET, set: oI(), not: !1 });
  ar.notWords = () => ({ type: Ge.types.SET, set: oI(), not: !0 });
  ar.ints = () => ({ type: Ge.types.SET, set: iI(), not: !1 });
  ar.notInts = () => ({ type: Ge.types.SET, set: iI(), not: !0 });
  ar.whitespace = () => ({ type: Ge.types.SET, set: aI(), not: !1 });
  ar.notWhitespace = () => ({ type: Ge.types.SET, set: aI(), not: !0 });
  ar.anyChar = () => ({ type: Ge.types.SET, set: hY(), not: !0 });
});
var lI = b((on) => {
  "use strict";
  var pY =
      (on && on.__createBinding) ||
      (Object.create
        ? function (e, t, r, n) {
            n === void 0 && (n = r),
              Object.defineProperty(e, n, {
                enumerable: !0,
                get: function () {
                  return t[r];
                },
              });
          }
        : function (e, t, r, n) {
            n === void 0 && (n = r), (e[n] = t[r]);
          }),
    mY =
      (on && on.__setModuleDefault) ||
      (Object.create
        ? function (e, t) {
            Object.defineProperty(e, "default", { enumerable: !0, value: t });
          }
        : function (e, t) {
            e.default = t;
          }),
    yY =
      (on && on.__importStar) ||
      function (e) {
        if (e && e.__esModule) return e;
        var t = {};
        if (e != null)
          for (var r in e)
            r !== "default" && Object.prototype.hasOwnProperty.call(e, r) && pY(t, e, r);
        return mY(t, e), t;
      };
  Object.defineProperty(on, "__esModule", { value: !0 });
  on.tokenizeClass = on.strToChars = void 0;
  var uI = _s(),
    Ho = yY(Bf()),
    gY = "@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^ ?";
  on.strToChars = (e) => {
    let t = /(\[\\b\])|(\\)?\\(?:u([A-F0-9]{4})|x([A-F0-9]{2})|c([@A-Z[\\\]^?])|([0tnvfr]))/g;
    return e.replace(t, (r, n, s, i, o, a, u) => {
      if (s) return r;
      let l = n
          ? 8
          : i
            ? parseInt(i, 16)
            : o
              ? parseInt(o, 16)
              : a
                ? gY.indexOf(a)
                : { 0: 0, t: 9, n: 10, v: 11, f: 12, r: 13 }[u],
        c = String.fromCharCode(l);
      return /[[\]{}^$.|?*+()]/.test(c) ? `\\${c}` : c;
    });
  };
  on.tokenizeClass = (e, t) => {
    var r, n, s, i, o, a, u;
    let l = [],
      c,
      f,
      d =
        /\\(?:(w)|(d)|(s)|(W)|(D)|(S))|((?:(?:\\)(.)|([^\]\\]))-(((?:\\)])|(((?:\\)?([^\]])))))|(\])|(?:\\)?([^])/g;
    for (; (c = d.exec(e)) !== null; ) {
      let h =
        (u =
          (a =
            (o =
              (i =
                (s =
                  (n =
                    (r = c[1] && Ho.words()) !== null && r !== void 0 ? r : c[2] && Ho.ints()) !==
                    null && n !== void 0
                    ? n
                    : c[3] && Ho.whitespace()) !== null && s !== void 0
                  ? s
                  : c[4] && Ho.notWords()) !== null && i !== void 0
                ? i
                : c[5] && Ho.notInts()) !== null && o !== void 0
              ? o
              : c[6] && Ho.notWhitespace()) !== null && a !== void 0
            ? a
            : c[7] && {
                type: uI.types.RANGE,
                from: (c[8] || c[9]).charCodeAt(0),
                to: (f = c[10]).charCodeAt(f.length - 1),
              }) !== null && u !== void 0
          ? u
          : (f = c[16]) && { type: uI.types.CHAR, value: f.charCodeAt(0) };
      if (h) l.push(h);
      else return [l, d.lastIndex];
    }
    throw new SyntaxError(`Invalid regular expression: /${t}/: Unterminated character class`);
  };
});
var D0 = b((Un) => {
  "use strict";
  var _Y =
      (Un && Un.__createBinding) ||
      (Object.create
        ? function (e, t, r, n) {
            n === void 0 && (n = r),
              Object.defineProperty(e, n, {
                enumerable: !0,
                get: function () {
                  return t[r];
                },
              });
          }
        : function (e, t, r, n) {
            n === void 0 && (n = r), (e[n] = t[r]);
          }),
    SY =
      (Un && Un.__setModuleDefault) ||
      (Object.create
        ? function (e, t) {
            Object.defineProperty(e, "default", { enumerable: !0, value: t });
          }
        : function (e, t) {
            e.default = t;
          }),
    fI =
      (Un && Un.__importStar) ||
      function (e) {
        if (e && e.__esModule) return e;
        var t = {};
        if (e != null)
          for (var r in e)
            r !== "default" && Object.prototype.hasOwnProperty.call(e, r) && _Y(t, e, r);
        return SY(t, e), t;
      };
  Object.defineProperty(Un, "__esModule", { value: !0 });
  Un.tokenizer = void 0;
  var cI = fI(lI()),
    Yt = _s(),
    Ci = fI(Bf());
  Un.tokenizer = (e) => {
    let t = 0,
      r,
      n = { type: Yt.types.ROOT, stack: [] },
      s = n,
      i = n.stack,
      o = [],
      a = [],
      u = 0,
      l = (f) => {
        throw new SyntaxError(
          `Invalid regular expression: /${e}/: Nothing to repeat at column ${f - 1}`,
        );
      },
      c = cI.strToChars(e);
    for (; t < c.length; )
      switch ((r = c[t++])) {
        case "\\":
          if (t === c.length)
            throw new SyntaxError(`Invalid regular expression: /${e}/: \\ at end of pattern`);
          switch ((r = c[t++])) {
            case "b":
              i.push({ type: Yt.types.POSITION, value: "b" });
              break;
            case "B":
              i.push({ type: Yt.types.POSITION, value: "B" });
              break;
            case "w":
              i.push(Ci.words());
              break;
            case "W":
              i.push(Ci.notWords());
              break;
            case "d":
              i.push(Ci.ints());
              break;
            case "D":
              i.push(Ci.notInts());
              break;
            case "s":
              i.push(Ci.whitespace());
              break;
            case "S":
              i.push(Ci.notWhitespace());
              break;
            default:
              if (/\d/.test(r)) {
                let f = r;
                for (; t < c.length && /\d/.test(c[t]); ) f += c[t++];
                let d = parseInt(f, 10),
                  h = { type: Yt.types.REFERENCE, value: d };
                i.push(h), a.push({ reference: h, stack: i, index: i.length - 1 });
              } else i.push({ type: Yt.types.CHAR, value: r.charCodeAt(0) });
          }
          break;
        case "^":
          i.push({ type: Yt.types.POSITION, value: "^" });
          break;
        case "$":
          i.push({ type: Yt.types.POSITION, value: "$" });
          break;
        case "[": {
          let f;
          c[t] === "^" ? ((f = !0), t++) : (f = !1);
          let d = cI.tokenizeClass(c.slice(t), e);
          (t += d[1]), i.push({ type: Yt.types.SET, set: d[0], not: f });
          break;
        }
        case ".":
          i.push(Ci.anyChar());
          break;
        case "(": {
          let f = { type: Yt.types.GROUP, stack: [], remember: !0 };
          if (c[t] === "?") {
            if (((r = c[t + 1]), (t += 2), r === "=")) f.followedBy = !0;
            else if (r === "!") f.notFollowedBy = !0;
            else if (r !== ":")
              throw new SyntaxError(
                `Invalid regular expression: /${e}/: Invalid group, character '${r}' after '?' at column ${t - 1}`,
              );
            f.remember = !1;
          } else u += 1;
          i.push(f), o.push(s), (s = f), (i = f.stack);
          break;
        }
        case ")":
          if (o.length === 0)
            throw new SyntaxError(
              `Invalid regular expression: /${e}/: Unmatched ) at column ${t - 1}`,
            );
          (s = o.pop()), (i = s.options ? s.options[s.options.length - 1] : s.stack);
          break;
        case "|": {
          s.options || ((s.options = [s.stack]), delete s.stack);
          let f = [];
          s.options.push(f), (i = f);
          break;
        }
        case "{": {
          let f = /^(\d+)(,(\d+)?)?\}/.exec(c.slice(t)),
            d,
            h;
          f !== null
            ? (i.length === 0 && l(t),
              (d = parseInt(f[1], 10)),
              (h = f[2] ? (f[3] ? parseInt(f[3], 10) : 1 / 0) : d),
              (t += f[0].length),
              i.push({ type: Yt.types.REPETITION, min: d, max: h, value: i.pop() }))
            : i.push({ type: Yt.types.CHAR, value: 123 });
          break;
        }
        case "?":
          i.length === 0 && l(t),
            i.push({ type: Yt.types.REPETITION, min: 0, max: 1, value: i.pop() });
          break;
        case "+":
          i.length === 0 && l(t),
            i.push({ type: Yt.types.REPETITION, min: 1, max: 1 / 0, value: i.pop() });
          break;
        case "*":
          i.length === 0 && l(t),
            i.push({ type: Yt.types.REPETITION, min: 0, max: 1 / 0, value: i.pop() });
          break;
        default:
          i.push({ type: Yt.types.CHAR, value: r.charCodeAt(0) });
      }
    if (o.length !== 0)
      throw new SyntaxError(`Invalid regular expression: /${e}/: Unterminated group`);
    return vY(a, u), n;
  };
  function vY(e, t) {
    for (let r of e.reverse())
      if (t < r.reference.value) {
        r.reference.type = Yt.types.CHAR;
        let n = r.reference.value.toString();
        if (((r.reference.value = parseInt(n, 8)), !/^[0-7]+$/.test(n))) {
          let s = 0;
          for (; n[s] !== "8" && n[s] !== "9"; ) s += 1;
          if (
            (s === 0
              ? ((r.reference.value = n.charCodeAt(0)), (s += 1))
              : (r.reference.value = parseInt(n.slice(0, s), 8)),
            n.length > s)
          ) {
            let i = r.stack.splice(r.index + 1);
            for (let o of n.slice(s)) r.stack.push({ type: Yt.types.CHAR, value: o.charCodeAt(0) });
            r.stack.push(...i);
          }
        }
      }
  }
});
var hI = b((ur) => {
  "use strict";
  var bY =
      (ur && ur.__createBinding) ||
      (Object.create
        ? function (e, t, r, n) {
            n === void 0 && (n = r),
              Object.defineProperty(e, n, {
                enumerable: !0,
                get: function () {
                  return t[r];
                },
              });
          }
        : function (e, t, r, n) {
            n === void 0 && (n = r), (e[n] = t[r]);
          }),
    wY =
      (ur && ur.__setModuleDefault) ||
      (Object.create
        ? function (e, t) {
            Object.defineProperty(e, "default", { enumerable: !0, value: t });
          }
        : function (e, t) {
            e.default = t;
          }),
    EY =
      (ur && ur.__importStar) ||
      function (e) {
        if (e && e.__esModule) return e;
        var t = {};
        if (e != null)
          for (var r in e)
            r !== "default" && Object.prototype.hasOwnProperty.call(e, r) && bY(t, e, r);
        return wY(t, e), t;
      };
  Object.defineProperty(ur, "__esModule", { value: !0 });
  ur.NOTANYCHAR = ur.WHITESPACE = ur.WORDS = ur.INTS = void 0;
  var Kf = EY(Bf()),
    dI = _s();
  function Gf(e) {
    let t = {},
      r = 0;
    for (let n of e)
      n.type === dI.types.CHAR && (t[n.value] = !0),
        n.type === dI.types.RANGE && (t[`${n.from}-${n.to}`] = !0),
        (r += 1);
    return { lookup: () => Object.assign({}, t), len: r };
  }
  ur.INTS = Gf(Kf.ints().set);
  ur.WORDS = Gf(Kf.words().set);
  ur.WHITESPACE = Gf(Kf.whitespace().set);
  ur.NOTANYCHAR = Gf(Kf.anyChar().set);
});
var mI = b((an) => {
  "use strict";
  var RY =
      (an && an.__createBinding) ||
      (Object.create
        ? function (e, t, r, n) {
            n === void 0 && (n = r),
              Object.defineProperty(e, n, {
                enumerable: !0,
                get: function () {
                  return t[r];
                },
              });
          }
        : function (e, t, r, n) {
            n === void 0 && (n = r), (e[n] = t[r]);
          }),
    TY =
      (an && an.__setModuleDefault) ||
      (Object.create
        ? function (e, t) {
            Object.defineProperty(e, "default", { enumerable: !0, value: t });
          }
        : function (e, t) {
            e.default = t;
          }),
    PY =
      (an && an.__importStar) ||
      function (e) {
        if (e && e.__esModule) return e;
        var t = {};
        if (e != null)
          for (var r in e)
            r !== "default" && Object.prototype.hasOwnProperty.call(e, r) && RY(t, e, r);
        return TY(t, e), t;
      };
  Object.defineProperty(an, "__esModule", { value: !0 });
  an.writeSetTokens = an.setChar = void 0;
  var Yf = _s(),
    Jf = PY(hI());
  function Wf(e) {
    return e === 94
      ? "\\^"
      : e === 92
        ? "\\\\"
        : e === 93
          ? "\\]"
          : e === 45
            ? "\\-"
            : String.fromCharCode(e);
  }
  an.setChar = Wf;
  function Qf(e, { lookup: t, len: r }) {
    if (r !== e.length) return !1;
    let n = t();
    for (let s of e) {
      if (s.type === Yf.types.SET) return !1;
      let i = s.type === Yf.types.CHAR ? s.value : `${s.from}-${s.to}`;
      if (n[i]) n[i] = !1;
      else return !1;
    }
    return !0;
  }
  function pI(e, t = !1) {
    if (Qf(e.set, Jf.INTS)) return e.not ? "\\D" : "\\d";
    if (Qf(e.set, Jf.WORDS)) return e.not ? "\\W" : "\\w";
    if (e.not && Qf(e.set, Jf.NOTANYCHAR)) return ".";
    if (Qf(e.set, Jf.WHITESPACE)) return e.not ? "\\S" : "\\s";
    let r = "";
    for (let s = 0; s < e.set.length; s++) {
      let i = e.set[s];
      r += $Y(i);
    }
    let n = `${e.not ? "^" : ""}${r}`;
    return t ? n : `[${n}]`;
  }
  an.writeSetTokens = pI;
  function $Y(e) {
    return e.type === Yf.types.CHAR
      ? Wf(e.value)
      : e.type === Yf.types.RANGE
        ? `${Wf(e.from)}-${Wf(e.to)}`
        : pI(e, !0);
  }
});
var j0 = b((Bo) => {
  "use strict";
  Object.defineProperty(Bo, "__esModule", { value: !0 });
  Bo.reconstruct = void 0;
  var Ws = _s(),
    q0 = mI(),
    yI = (e) => e.map(Bo.reconstruct).join(""),
    gI = (e) => {
      if ("options" in e) return e.options.map(yI).join("|");
      if ("stack" in e) return yI(e.stack);
      throw new Error("options or stack must be Root or Group token");
    };
  Bo.reconstruct = (e) => {
    switch (e.type) {
      case Ws.types.ROOT:
        return gI(e);
      case Ws.types.CHAR: {
        let t = String.fromCharCode(e.value);
        return (/[[\\{}$^.|?*+()]/.test(t) ? "\\" : "") + t;
      }
      case Ws.types.POSITION:
        return e.value === "^" || e.value === "$" ? e.value : `\\${e.value}`;
      case Ws.types.REFERENCE:
        return `\\${e.value}`;
      case Ws.types.SET:
        return q0.writeSetTokens(e);
      case Ws.types.GROUP:
        return `(${e.remember ? "" : e.followedBy ? "?=" : e.notFollowedBy ? "?!" : "?:"}${gI(e)})`;
      case Ws.types.REPETITION: {
        let { min: t, max: r } = e,
          n;
        return (
          t === 0 && r === 1
            ? (n = "?")
            : t === 1 && r === 1 / 0
              ? (n = "+")
              : t === 0 && r === 1 / 0
                ? (n = "*")
                : r === 1 / 0
                  ? (n = `{${t},}`)
                  : t === r
                    ? (n = `{${t}}`)
                    : (n = `{${t},${r}}`),
          `${Bo.reconstruct(e.value)}${n}`
        );
      }
      case Ws.types.RANGE:
        return `${q0.setChar(e.from)}-${q0.setChar(e.to)}`;
      default:
        throw new Error(`Invalid token type ${e}`);
    }
  };
});
var vI = b((un, Xf) => {
  "use strict";
  var OY =
      (un && un.__createBinding) ||
      (Object.create
        ? function (e, t, r, n) {
            n === void 0 && (n = r),
              Object.defineProperty(e, n, {
                enumerable: !0,
                get: function () {
                  return t[r];
                },
              });
          }
        : function (e, t, r, n) {
            n === void 0 && (n = r), (e[n] = t[r]);
          }),
    L0 =
      (un && un.__exportStar) ||
      function (e, t) {
        for (var r in e)
          r !== "default" && !Object.prototype.hasOwnProperty.call(t, r) && OY(t, e, r);
      };
  Object.defineProperty(un, "__esModule", { value: !0 });
  un.types = void 0;
  var _I = _s();
  Object.defineProperty(un, "types", {
    enumerable: !0,
    get: function () {
      return _I.types;
    },
  });
  L0(D0(), un);
  L0(j0(), un);
  var SI = D0(),
    NY = j0();
  L0(_s(), un);
  un.default = SI.tokenizer;
  Xf.exports = SI.tokenizer;
  Xf.exports.types = _I.types;
  Xf.exports.reconstruct = NY.reconstruct;
});
var wI = b((Uae, Zf) => {
  "use strict";
  var bI = vI(),
    AY = bI.types;
  function x0(e, t) {
    t || (t = {});
    let r = t.limit === void 0 ? 25 : t.limit;
    IY(e) ? (e = e.source) : typeof e != "string" && (e = String(e));
    try {
      e = bI(e);
    } catch {
      return !1;
    }
    let n = 0;
    return (function s(i, o) {
      let a, u, l;
      if (i.type === AY.REPETITION && (o++, n++, o > 1 || n > r)) return !1;
      if (i.options) {
        for (a = 0, l = i.options.length; a < l; a++)
          if (((u = s({ stack: i.options[a] }, o)), !u)) return !1;
      }
      let c = i.stack || (i.value && i.value.stack);
      if (!c) return !0;
      for (a = 0; a < c.length; a++) if (((u = s(c[a], o)), !u)) return !1;
      return !0;
    })(e, 0);
  }
  function IY(e) {
    return {}.toString.call(e) === "[object RegExp]";
  }
  Zf.exports = x0;
  Zf.exports.default = x0;
  Zf.exports.safeRegex = x0;
});
var ed = b((Hae, EI) => {
  "use strict";
  EI.exports = {
    name: "__fmw_internal_strategy_merged_tree_http_method__",
    storage: function () {
      let e = {};
      return {
        get: (t) => e[t] || null,
        set: (t, r) => {
          e[t] = r;
        },
      };
    },
    deriveConstraint: (e) => e.method,
    mustMatchWhenDerived: !0,
  };
});
var AI = b((Bae, NI) => {
  "use strict";
  var RI = qs(),
    TI = ed(),
    PI = Symbol("treeData");
  function $I(e, t = "") {
    let r = "",
      n = Object.keys(e);
    for (let s = 0; s < n.length; s++) {
      let i = n[s],
        o = e[i],
        a = s === n.length - 1,
        u = a ? "\u2514\u2500\u2500 " : "\u251C\u2500\u2500 ",
        l = a ? "    " : "\u2502   ",
        f = (o[PI] || "")
          .split(
            `
`,
          )
          .join(
            `
` +
              t +
              l,
          );
      (r +=
        t +
        u +
        i +
        f +
        `
`),
        (r += $I(o, t + l));
    }
    return r;
  }
  function CY(e) {
    let t = e.name || "";
    return (t = t.replace("bound", "").trim()), (t = (t || "anonymous") + "()"), t;
  }
  function OI(e) {
    return Array.isArray(e)
      ? e.map((t) => OI(t))
      : typeof e == "symbol"
        ? e.toString()
        : typeof e == "function"
          ? CY(e)
          : e;
  }
  function kY(e, t) {
    if (!t.includeMeta) return {};
    let r = t.buildPrettyMeta(e),
      n = {},
      s = t.includeMeta;
    Array.isArray(s) || (s = Reflect.ownKeys(r));
    for (let i of s) {
      if (!Object.prototype.hasOwnProperty.call(r, i)) continue;
      let o = i.toString(),
        a = r[i];
      if (a != null) {
        let u = JSON.stringify(OI(a));
        n[o] = u;
      }
    }
    return n;
  }
  function DY(e) {
    let t = "";
    for (let [r, n] of Object.entries(e))
      t += `
\u2022 (${r}) ${n}`;
    return t;
  }
  function qY(e) {
    let t = { ...e.opts.constraints },
      r = t[TI.name];
    return delete t[TI.name], { ...e, method: r, opts: { constraints: t } };
  }
  function jY(e) {
    let t = ` (${e.method})`,
      r = e.opts.constraints || {};
    return Object.keys(r).length !== 0 && (t += " " + JSON.stringify(r)), (t += DY(e.metaData)), t;
  }
  function LY(e) {
    return e.reduce((t, r) => {
      for (let n of t)
        if (RI(r.opts.constraints, n.opts.constraints) && RI(r.metaData, n.metaData))
          return (n.method += ", " + r.method), t;
      return t.push(r), t;
    }, []);
  }
  function xY(e, t, r) {
    let n = e.routes;
    return (
      r.method === void 0 && (n = n.map(qY)),
      (n = n.map((s) => ((s.metaData = kY(s, r)), s))),
      r.method === void 0 && (n = LY(n)),
      n.map(jY).join(`
${t}`)
    );
  }
  function td(e, t, r, n) {
    if (
      ((e.isLeafNode || n.commonPrefix !== !1) &&
        ((r = r || "(empty root node)"),
        (t = t[r] = {}),
        e.isLeafNode && (t[PI] = xY(e, r, n)),
        (r = "")),
      e.staticChildren)
    )
      for (let s of Object.values(e.staticChildren)) td(s, t, r + s.prefix, n);
    if (e.parametricChildren)
      for (let s of Object.values(e.parametricChildren)) {
        let i = Array.from(s.nodePaths).join("|");
        td(s, t, r + i, n);
      }
    e.wildcardChild && td(e.wildcardChild, t, "*", n);
  }
  function FY(e, t) {
    let r = {};
    return td(e, r, e.prefix, t), $I(r);
  }
  NI.exports = { prettyPrintTree: FY };
});
var CI = b((Kae, II) => {
  "use strict";
  var MY = ed(),
    F0 = class {
      constructor() {
        (this.unconstrainedHandler = null),
          (this.constraints = []),
          (this.handlers = []),
          (this.constrainedHandlerStores = null);
      }
      getMatchingHandler(t) {
        return t === void 0 ? this.unconstrainedHandler : this._getHandlerMatchingConstraints(t);
      }
      addHandler(t, r) {
        let n = r.params,
          s = r.opts.constraints || {},
          i = {
            params: n,
            constraints: s,
            handler: r.handler,
            store: r.store || null,
            _createParamsObject: this._compileCreateParamsObject(n),
          },
          o = Object.keys(s);
        o.length === 0 && (this.unconstrainedHandler = i);
        for (let u of o)
          this.constraints.includes(u) ||
            (u === "version" ? this.constraints.unshift(u) : this.constraints.push(u));
        let a = o.includes(MY.name);
        if (!a && this.handlers.length >= 31)
          throw new Error(
            "find-my-way supports a maximum of 31 route handlers per node when there are constraints, limit reached",
          );
        this.handlers.push(i),
          this.handlers.sort(
            (u, l) => Object.keys(u.constraints).length - Object.keys(l.constraints).length,
          ),
          a || this._compileGetHandlerMatchingConstraints(t, s);
      }
      _compileCreateParamsObject(t) {
        let r = [];
        for (let n = 0; n < t.length; n++) r.push(`'${t[n]}': paramsArray[${n}]`);
        return new Function("paramsArray", `return {${r.join(",")}}`);
      }
      _getHandlerMatchingConstraints() {
        return null;
      }
      _buildConstraintStore(t, r) {
        for (let n = 0; n < this.handlers.length; n++) {
          let i = this.handlers[n].constraints[r];
          if (i !== void 0) {
            let o = t.get(i) || 0;
            (o |= 1 << n), t.set(i, o);
          }
        }
      }
      _constrainedIndexBitmask(t) {
        let r = 0;
        for (let n = 0; n < this.handlers.length; n++)
          this.handlers[n].constraints[t] !== void 0 && (r |= 1 << n);
        return ~r;
      }
      _compileGetHandlerMatchingConstraints(t) {
        this.constrainedHandlerStores = {};
        for (let n of this.constraints) {
          let s = t.newStoreForConstraint(n);
          (this.constrainedHandlerStores[n] = s), this._buildConstraintStore(s, n);
        }
        let r = [];
        r.push(`
    let candidates = ${(1 << this.handlers.length) - 1}
    let mask, matches
    `);
        for (let n of this.constraints) {
          r.push(`
      mask = ${this._constrainedIndexBitmask(n)}
      value = derivedConstraints.${n}
      `);
          let i = t.strategies[n].mustMatchWhenDerived ? "matches" : "(matches | mask)";
          r.push(`
      if (value === undefined) {
        candidates &= mask
      } else {
        matches = this.constrainedHandlerStores.${n}.get(value) || 0
        candidates &= ${i}
      }
      if (candidates === 0) return null;
      `);
        }
        for (let n in t.strategies)
          t.strategies[n].mustMatchWhenDerived &&
            !this.constraints.includes(n) &&
            r.push(`if (derivedConstraints.${n} !== undefined) return null`);
        r.push("return this.handlers[Math.floor(Math.log2(candidates))]"),
          (this._getHandlerMatchingConstraints = new Function(
            "derivedConstraints",
            r.join(`
`),
          ));
      }
    };
  II.exports = F0;
});
var DI = b((Gae, kI) => {
  "use strict";
  var zY = CI(),
    ad = { STATIC: 0, PARAMETRIC: 1, WILDCARD: 2 },
    rd = class {
      constructor() {
        (this.isLeafNode = !1), (this.routes = null), (this.handlerStorage = null);
      }
      addRoute(t, r) {
        this.routes === null && (this.routes = []),
          this.handlerStorage === null && (this.handlerStorage = new zY()),
          (this.isLeafNode = !0),
          this.routes.push(t),
          this.handlerStorage.addHandler(r, t);
      }
    },
    nd = class extends rd {
      constructor() {
        super(), (this.staticChildren = {});
      }
      findStaticMatchingChild(t, r) {
        let n = this.staticChildren[t.charAt(r)];
        return n === void 0 || !n.matchPrefix(t, r) ? null : n;
      }
      getStaticChild(t, r = 0) {
        if (t.length === r) return this;
        let n = this.findStaticMatchingChild(t, r);
        return n ? n.getStaticChild(t, r + n.prefix.length) : null;
      }
      createStaticChild(t) {
        if (t.length === 0) return this;
        let r = this.staticChildren[t.charAt(0)];
        if (r) {
          let s = 1;
          for (; s < r.prefix.length; s++)
            if (t.charCodeAt(s) !== r.prefix.charCodeAt(s)) {
              r = r.split(this, s);
              break;
            }
          return r.createStaticChild(t.slice(s));
        }
        let n = t.charAt(0);
        return (this.staticChildren[n] = new sd(t)), this.staticChildren[n];
      }
    },
    sd = class e extends nd {
      constructor(t) {
        super(),
          (this.prefix = t),
          (this.wildcardChild = null),
          (this.parametricChildren = []),
          (this.kind = ad.STATIC),
          this._compilePrefixMatch();
      }
      getParametricChild(t) {
        let r = t && t.source,
          n = this.parametricChildren.find((s) => (s.regex && s.regex.source) === r);
        return n || null;
      }
      createParametricChild(t, r, n) {
        let s = this.getParametricChild(t);
        return s
          ? (s.nodePaths.add(n), s)
          : ((s = new id(t, r, n)),
            this.parametricChildren.push(s),
            this.parametricChildren.sort((i, o) =>
              i.isRegex
                ? o.isRegex
                  ? i.staticSuffix === null
                    ? 1
                    : o.staticSuffix === null
                      ? -1
                      : o.staticSuffix.endsWith(i.staticSuffix)
                        ? 1
                        : i.staticSuffix.endsWith(o.staticSuffix)
                          ? -1
                          : 0
                  : -1
                : 1,
            ),
            s);
      }
      getWildcardChild() {
        return this.wildcardChild;
      }
      createWildcardChild() {
        return (this.wildcardChild = this.getWildcardChild() || new od()), this.wildcardChild;
      }
      split(t, r) {
        let n = this.prefix.slice(0, r),
          s = this.prefix.slice(r);
        (this.prefix = s), this._compilePrefixMatch();
        let i = new e(n);
        return (i.staticChildren[s.charAt(0)] = this), (t.staticChildren[n.charAt(0)] = i), i;
      }
      getNextNode(t, r, n, s) {
        let i = this.findStaticMatchingChild(t, r),
          o = 0;
        if (i === null) {
          if (this.parametricChildren.length === 0) return this.wildcardChild;
          (i = this.parametricChildren[0]), (o = 1);
        }
        this.wildcardChild !== null &&
          n.push({ paramsCount: s, brotherPathIndex: r, brotherNode: this.wildcardChild });
        for (let a = this.parametricChildren.length - 1; a >= o; a--)
          n.push({ paramsCount: s, brotherPathIndex: r, brotherNode: this.parametricChildren[a] });
        return i;
      }
      _compilePrefixMatch() {
        if (this.prefix.length === 1) {
          this.matchPrefix = () => !0;
          return;
        }
        let t = [];
        for (let r = 1; r < this.prefix.length; r++) {
          let n = this.prefix.charCodeAt(r);
          t.push(`path.charCodeAt(i + ${r}) === ${n}`);
        }
        this.matchPrefix = new Function("path", "i", `return ${t.join(" && ")}`);
      }
    },
    id = class extends nd {
      constructor(t, r, n) {
        super(),
          (this.isRegex = !!t),
          (this.regex = t || null),
          (this.staticSuffix = r || null),
          (this.kind = ad.PARAMETRIC),
          (this.nodePaths = new Set([n]));
      }
      getNextNode(t, r) {
        return this.findStaticMatchingChild(t, r);
      }
    },
    od = class extends rd {
      constructor() {
        super(), (this.kind = ad.WILDCARD);
      }
      getNextNode() {
        return null;
      }
    };
  kI.exports = { StaticNode: sd, ParametricNode: id, WildcardNode: od, NODE_TYPES: ad };
});
var jI = b((Jae, qI) => {
  "use strict";
  var VY = require("node:assert");
  function Nu() {
    if (!(this instanceof Nu)) return new Nu();
    (this.store = {}), (this.maxMajor = 0), (this.maxMinors = {}), (this.maxPatches = {});
  }
  Nu.prototype.set = function (e, t) {
    if (typeof e != "string") throw new TypeError("Version should be a string");
    let [r, n, s] = e.split(".");
    if (isNaN(r)) throw new TypeError("Major version must be a numeric value");
    return (
      (r = Number(r)),
      (n = Number(n) || 0),
      (s = Number(s) || 0),
      r >= this.maxMajor &&
        ((this.maxMajor = r),
        (this.store.x = t),
        (this.store["*"] = t),
        (this.store["x.x"] = t),
        (this.store["x.x.x"] = t)),
      n >= (this.maxMinors[r] || 0) &&
        ((this.maxMinors[r] = n), (this.store[`${r}.x`] = t), (this.store[`${r}.x.x`] = t)),
      s >= (this.maxPatches[`${r}.${n}`] || 0) &&
        ((this.maxPatches[`${r}.${n}`] = s), (this.store[`${r}.${n}.x`] = t)),
      (this.store[`${r}.${n}.${s}`] = t),
      this
    );
  };
  Nu.prototype.get = function (e) {
    return this.store[e];
  };
  qI.exports = {
    name: "version",
    mustMatchWhenDerived: !0,
    storage: Nu,
    validate(e) {
      VY(typeof e == "string", "Version should be a string");
    },
  };
});
var xI = b((Qae, LI) => {
  "use strict";
  var UY = require("node:assert");
  function HY() {
    let e = {},
      t = [];
    return {
      get: (r) => {
        let n = e[r];
        if (n) return n;
        for (let s of t) if (s.host.test(r)) return s.value;
      },
      set: (r, n) => {
        r instanceof RegExp ? t.push({ host: r, value: n }) : (e[r] = n);
      },
    };
  }
  LI.exports = {
    name: "host",
    mustMatchWhenDerived: !1,
    storage: HY,
    validate(e) {
      UY(
        typeof e == "string" || Object.prototype.toString.call(e) === "[object RegExp]",
        "Host should be a string or a RegExp",
      );
    },
  };
});
var MI = b((Wae, FI) => {
  "use strict";
  var BY = jI(),
    KY = xI(),
    M0 = require("node:assert"),
    z0 = class {
      constructor(t) {
        if (
          ((this.strategies = { version: BY, host: KY }),
          (this.strategiesInUse = new Set()),
          (this.asyncStrategiesInUse = new Set()),
          t)
        )
          for (let r of Object.values(t)) this.addConstraintStrategy(r);
      }
      isStrategyUsed(t) {
        return this.strategiesInUse.has(t) || this.asyncStrategiesInUse.has(t);
      }
      hasConstraintStrategy(t) {
        let r = this.strategies[t];
        return r !== void 0 ? r.isCustom || this.isStrategyUsed(t) : !1;
      }
      addConstraintStrategy(t) {
        if (
          (M0(typeof t.name == "string" && t.name !== "", "strategy.name is required."),
          M0(t.storage && typeof t.storage == "function", "strategy.storage function is required."),
          M0(
            t.deriveConstraint && typeof t.deriveConstraint == "function",
            "strategy.deriveConstraint function is required.",
          ),
          this.strategies[t.name] && this.strategies[t.name].isCustom)
        )
          throw new Error(`There already exists a custom constraint with the name ${t.name}.`);
        if (this.isStrategyUsed(t.name))
          throw new Error(`There already exists a route with ${t.name} constraint.`);
        (t.isCustom = !0),
          (t.isAsync = t.deriveConstraint.length === 3),
          (this.strategies[t.name] = t),
          t.mustMatchWhenDerived && this.noteUsage({ [t.name]: t });
      }
      deriveConstraints(t, r, n) {
        let s = this.deriveSyncConstraints(t, r);
        if (n === void 0) return s;
        this.deriveAsyncConstraints(s, t, r, n);
      }
      deriveSyncConstraints(t, r) {}
      noteUsage(t) {
        if (t) {
          let r = this.strategiesInUse.size;
          for (let n in t)
            this.strategies[n].isAsync
              ? this.asyncStrategiesInUse.add(n)
              : this.strategiesInUse.add(n);
          r !== this.strategiesInUse.size && this._buildDeriveConstraints();
        }
      }
      newStoreForConstraint(t) {
        if (!this.strategies[t]) throw new Error(`No strategy registered for constraint key ${t}`);
        return this.strategies[t].storage();
      }
      validateConstraints(t) {
        for (let r in t) {
          let n = t[r];
          if (typeof n > "u")
            throw new Error(
              "Can't pass an undefined constraint value, must pass null or no key at all",
            );
          let s = this.strategies[r];
          if (!s) throw new Error(`No strategy registered for constraint key ${r}`);
          s.validate && s.validate(n);
        }
      }
      deriveAsyncConstraints(t, r, n, s) {
        let i = this.asyncStrategiesInUse.size;
        if (i === 0) {
          s(null, t);
          return;
        }
        t = t || {};
        for (let o of this.asyncStrategiesInUse)
          this.strategies[o].deriveConstraint(r, n, (u, l) => {
            if (u !== null) {
              s(u);
              return;
            }
            (t[o] = l), --i === 0 && s(null, t);
          });
      }
      _buildDeriveConstraints() {
        if (this.strategiesInUse.size === 0) return;
        let t = ["return {"];
        for (let r of this.strategiesInUse) {
          let n = this.strategies[r];
          n.isCustom
            ? t.push(`  ${n.name}: this.strategies.${r}.deriveConstraint(req, ctx),`)
            : r === "version"
              ? t.push("   version: req.headers['accept-version'],")
              : t.push("   host: req.headers.host || req.headers[':authority'],");
        }
        t.push("}"),
          (this.deriveSyncConstraints = new Function(
            "req",
            "ctx",
            t.join(`
`),
          ).bind(this));
      }
    };
  FI.exports = z0;
});
var VI = b((Yae, zI) => {
  "use strict";
  var GY = [
    "ACL",
    "BIND",
    "CHECKOUT",
    "CONNECT",
    "COPY",
    "DELETE",
    "GET",
    "HEAD",
    "LINK",
    "LOCK",
    "M-SEARCH",
    "MERGE",
    "MKACTIVITY",
    "MKCALENDAR",
    "MKCOL",
    "MOVE",
    "NOTIFY",
    "OPTIONS",
    "PATCH",
    "POST",
    "PROPFIND",
    "PROPPATCH",
    "PURGE",
    "PUT",
    "REBIND",
    "REPORT",
    "SEARCH",
    "SOURCE",
    "SUBSCRIBE",
    "TRACE",
    "UNBIND",
    "UNLINK",
    "UNLOCK",
    "UNSUBSCRIBE",
  ];
  zI.exports = GY;
});
var BI = b((Xae, HI) => {
  "use strict";
  function UI(e, t) {
    return e === 50
      ? t === 53
        ? "%"
        : t === 51
          ? "#"
          : t === 52
            ? "$"
            : t === 54
              ? "&"
              : t === 66 || t === 98
                ? "+"
                : t === 67 || t === 99
                  ? ","
                  : t === 70 || t === 102
                    ? "/"
                    : null
      : e === 51
        ? t === 65 || t === 97
          ? ":"
          : t === 66 || t === 98
            ? ";"
            : t === 68 || t === 100
              ? "="
              : t === 70 || t === 102
                ? "?"
                : null
        : e === 52 && t === 48
          ? "@"
          : null;
  }
  function JY(e, t) {
    let r = !1,
      n = !1,
      s = "";
    for (let o = 1; o < e.length; o++) {
      let a = e.charCodeAt(o);
      if (a === 37) {
        let u = e.charCodeAt(o + 1),
          l = e.charCodeAt(o + 2);
        UI(u, l) === null
          ? (r = !0)
          : ((n = !0),
            u === 50 &&
              l === 53 &&
              ((r = !0), (e = e.slice(0, o + 1) + "25" + e.slice(o + 1)), (o += 2)),
            (o += 2));
      } else if (a === 63 || a === 35 || (a === 59 && t)) {
        (s = e.slice(o + 1)), (e = e.slice(0, o));
        break;
      }
    }
    return { path: r ? decodeURI(e) : e, querystring: s, shouldDecodeParam: n };
  }
  function QY(e) {
    let t = e.indexOf("%");
    if (t === -1) return e;
    let r = "",
      n = t;
    for (let s = t; s < e.length; s++)
      if (e.charCodeAt(s) === 37) {
        let i = e.charCodeAt(s + 1),
          o = e.charCodeAt(s + 2),
          a = UI(i, o);
        (r += e.slice(n, s) + a), (n = s + 3);
      }
    return e.slice(0, t) + r + e.slice(n);
  }
  HI.exports = { safeDecodeURI: JY, safeDecodeURIComponent: QY };
});
var K0 = b((Zae, ZI) => {
  "use strict";
  var Dt = require("node:assert"),
    WY = ZA(),
    ud = wI(),
    U0 = qs(),
    { prettyPrintTree: YY } = AI(),
    { StaticNode: KI, NODE_TYPES: GI } = DI(),
    XY = MI(),
    Ko = VI(),
    V0 = ed(),
    { safeDecodeURI: ZY, safeDecodeURIComponent: JI } = BI(),
    QI = /^https?:\/\/.*?\//,
    ki = /(\/:[^/()]*?)\?(\/?)/;
  if (!ud(QI)) throw new Error("the FULL_PATH_REGEXP is not safe, update this module");
  if (!ud(ki)) throw new Error("the OPTIONAL_PARAM_REGEXP is not safe, update this module");
  function Nt(e) {
    if (!(this instanceof Nt)) return new Nt(e);
    (e = e || {}),
      (this._opts = e),
      e.defaultRoute
        ? (Dt(typeof e.defaultRoute == "function", "The default route must be a function"),
          (this.defaultRoute = e.defaultRoute))
        : (this.defaultRoute = null),
      e.onBadUrl
        ? (Dt(typeof e.onBadUrl == "function", "The bad url handler must be a function"),
          (this.onBadUrl = e.onBadUrl))
        : (this.onBadUrl = null),
      e.buildPrettyMeta
        ? (Dt(typeof e.buildPrettyMeta == "function", "buildPrettyMeta must be a function"),
          (this.buildPrettyMeta = e.buildPrettyMeta))
        : (this.buildPrettyMeta = eX),
      e.querystringParser
        ? (Dt(typeof e.querystringParser == "function", "querystringParser must be a function"),
          (this.querystringParser = e.querystringParser))
        : (this.querystringParser = (t) => (t === "" ? {} : WY.parse(t))),
      (this.caseSensitive = e.caseSensitive === void 0 ? !0 : e.caseSensitive),
      (this.ignoreTrailingSlash = e.ignoreTrailingSlash || !1),
      (this.ignoreDuplicateSlashes = e.ignoreDuplicateSlashes || !1),
      (this.maxParamLength = e.maxParamLength || 100),
      (this.allowUnsafeRegex = e.allowUnsafeRegex || !1),
      (this.constrainer = new XY(e.constraints)),
      (this.useSemicolonDelimiter = e.useSemicolonDelimiter || !1),
      (this.routes = []),
      (this.trees = {});
  }
  Nt.prototype.on = function (t, r, n, s, i) {
    typeof n == "function" && (s !== void 0 && (i = s), (s = n), (n = {})),
      Dt(typeof r == "string", "Path should be a string"),
      Dt(r.length > 0, "The path could not be empty"),
      Dt(r[0] === "/" || r[0] === "*", "The first character of a path should be `/` or `*`"),
      Dt(typeof s == "function", "Handler should be a function");
    let o = r.match(ki);
    if (o) {
      Dt(
        r.length === o.index + o[0].length,
        "Optional Parameter needs to be the last parameter of the path",
      );
      let l = r.replace(ki, "$1$2"),
        c = r.replace(ki, "$2") || "/";
      this.on(t, l, n, s, i), this.on(t, c, n, s, i);
      return;
    }
    let a = r;
    this.ignoreDuplicateSlashes && (r = H0(r)), this.ignoreTrailingSlash && (r = B0(r));
    let u = Array.isArray(t) ? t : [t];
    for (let l of u)
      Dt(typeof l == "string", "Method should be a string"),
        Dt(Ko.includes(l), `Method '${l}' is not an http method.`),
        this._on(l, r, n, s, i, a);
  };
  Nt.prototype._on = function (t, r, n, s, i) {
    let o = {};
    n.constraints !== void 0 &&
      (Dt(
        typeof n.constraints == "object" && n.constraints !== null,
        "Constraints should be an object",
      ),
      Object.keys(n.constraints).length !== 0 && (o = n.constraints)),
      this.constrainer.validateConstraints(o),
      this.constrainer.noteUsage(o),
      this.trees[t] === void 0 && (this.trees[t] = new KI("/"));
    let a = r;
    if (a === "*" && this.trees[t].prefix.length !== 0) {
      let d = this.trees[t];
      (this.trees[t] = new KI("")), (this.trees[t].staticChildren["/"] = d);
    }
    let u = this.trees[t],
      l = u.prefix.length,
      c = [];
    for (let d = 0; d <= a.length; d++) {
      if (a.charCodeAt(d) === 58 && a.charCodeAt(d + 1) === 58) {
        d++;
        continue;
      }
      let h = a.charCodeAt(d) === 58 && a.charCodeAt(d + 1) !== 58,
        p = a.charCodeAt(d) === 42;
      if (h || p || (d === a.length && d !== l)) {
        let y = a.slice(l, d);
        this.caseSensitive || (y = y.toLowerCase()),
          (y = y.split("::").join(":")),
          (y = y.split("%").join("%25")),
          (u = u.createStaticChild(y));
      }
      if (h) {
        let y = !1,
          _ = [],
          S = d + 1;
        for (let E = S; ; E++) {
          let g = a.charCodeAt(E),
            m = g === 40,
            T = g === 45 || g === 46,
            N = g === 47 || E === a.length;
          if (m || T || N) {
            let w = a.slice(S, E);
            if ((c.push(w), (y = y || m || T), m)) {
              let v = XI(a, E),
                M = a.slice(E, v + 1);
              this.allowUnsafeRegex || Dt(ud(new RegExp(M)), `The regex '${M}' is not safe!`),
                _.push(YI(M)),
                (E = v + 1);
            } else _.push("(.*?)");
            let $ = E;
            for (; E < a.length; E++) {
              let v = a.charCodeAt(E);
              if (v === 47) break;
              if (v === 58)
                if (a.charCodeAt(E + 1) === 58) E++;
                else break;
            }
            let D = a.slice($, E);
            if (
              (D && ((D = D.split("::").join(":")), (D = D.split("%").join("%25")), _.push(WI(D))),
              (S = E + 1),
              N || a.charCodeAt(E) === 47 || E === a.length)
            ) {
              let v = y ? "()" + D : D,
                M = a.slice(d, E);
              (a = a.slice(0, d + 1) + v + a.slice(E)), (d += v.length);
              let k = y ? new RegExp("^" + _.join("") + "$") : null;
              (u = u.createParametricChild(k, D || null, M)), (l = d + 1);
              break;
            }
          }
        }
      } else if (p && (c.push("*"), (u = u.createWildcardChild()), (l = d + 1), d !== a.length - 1))
        throw new Error("Wildcard must be the last character in the route");
    }
    this.caseSensitive || (a = a.toLowerCase()), a === "*" && (a = "/*");
    for (let d of this.routes) {
      let h = d.opts.constraints || {};
      if (d.method === t && d.pattern === a && U0(h, o))
        throw new Error(
          `Method '${t}' already declared for route '${a}' with constraints '${JSON.stringify(o)}'`,
        );
    }
    let f = { method: t, path: r, pattern: a, params: c, opts: n, handler: s, store: i };
    this.routes.push(f), u.addRoute(f, this.constrainer);
  };
  Nt.prototype.hasRoute = function (t, r, n) {
    return this.findRoute(t, r, n) !== null;
  };
  Nt.prototype.findRoute = function (t, r, n = {}) {
    if (this.trees[t] === void 0) return null;
    let s = r,
      i = this.trees[t],
      o = i.prefix.length,
      a = [];
    for (let u = 0; u <= s.length; u++) {
      if (s.charCodeAt(u) === 58 && s.charCodeAt(u + 1) === 58) {
        u++;
        continue;
      }
      let l = s.charCodeAt(u) === 58 && s.charCodeAt(u + 1) !== 58,
        c = s.charCodeAt(u) === 42;
      if (l || c || (u === s.length && u !== o)) {
        let f = s.slice(o, u);
        if (
          (this.caseSensitive || (f = f.toLowerCase()),
          (f = f.split("::").join(":")),
          (f = f.split("%").join("%25")),
          (i = i.getStaticChild(f)),
          i === null)
        )
          return null;
      }
      if (l) {
        let f = !1,
          d = [],
          h = u + 1;
        for (let p = h; ; p++) {
          let y = s.charCodeAt(p),
            _ = y === 40,
            S = y === 45 || y === 46,
            E = y === 47 || p === s.length;
          if (_ || S || E) {
            let g = s.slice(h, p);
            if ((a.push(g), (f = f || _ || S), _)) {
              let N = XI(s, p),
                w = s.slice(p, N + 1);
              this.allowUnsafeRegex || Dt(ud(new RegExp(w)), `The regex '${w}' is not safe!`),
                d.push(YI(w)),
                (p = N + 1);
            } else d.push("(.*?)");
            let m = p;
            for (; p < s.length; p++) {
              let N = s.charCodeAt(p);
              if (N === 47) break;
              if (N === 58)
                if (s.charCodeAt(p + 1) === 58) p++;
                else break;
            }
            let T = s.slice(m, p);
            if (
              (T && ((T = T.split("::").join(":")), (T = T.split("%").join("%25")), d.push(WI(T))),
              (h = p + 1),
              E || s.charCodeAt(p) === 47 || p === s.length)
            ) {
              let N = f ? "()" + T : T,
                w = s.slice(u, p);
              (s = s.slice(0, u + 1) + N + s.slice(p)), (u += N.length);
              let $ = f ? new RegExp("^" + d.join("") + "$") : null;
              if (((i = i.getParametricChild($, T || null, w)), i === null)) return null;
              o = u + 1;
              break;
            }
          }
        }
      } else if (c && (a.push("*"), (i = i.getWildcardChild()), (o = u + 1), u !== s.length - 1))
        throw new Error("Wildcard must be the last character in the route");
    }
    this.caseSensitive || (s = s.toLowerCase());
    for (let u of this.routes) {
      let l = u.opts.constraints || {};
      if (u.method === t && u.pattern === s && U0(l, n))
        return { handler: u.handler, store: u.store, params: u.params };
    }
    return null;
  };
  Nt.prototype.hasConstraintStrategy = function (e) {
    return this.constrainer.hasConstraintStrategy(e);
  };
  Nt.prototype.addConstraintStrategy = function (e) {
    this.constrainer.addConstraintStrategy(e), this._rebuild(this.routes);
  };
  Nt.prototype.reset = function () {
    (this.trees = {}), (this.routes = []);
  };
  Nt.prototype.off = function (t, r, n) {
    Dt(typeof r == "string", "Path should be a string"),
      Dt(r.length > 0, "The path could not be empty"),
      Dt(r[0] === "/" || r[0] === "*", "The first character of a path should be `/` or `*`"),
      Dt(
        typeof n > "u" || (typeof n == "object" && !Array.isArray(n) && n !== null),
        "Constraints should be an object or undefined.",
      );
    let s = r.match(ki);
    if (s) {
      Dt(
        r.length === s.index + s[0].length,
        "Optional Parameter needs to be the last parameter of the path",
      );
      let o = r.replace(ki, "$1$2"),
        a = r.replace(ki, "$2");
      this.off(t, o, n), this.off(t, a, n);
      return;
    }
    this.ignoreDuplicateSlashes && (r = H0(r)), this.ignoreTrailingSlash && (r = B0(r));
    let i = Array.isArray(t) ? t : [t];
    for (let o of i) this._off(o, r, n);
  };
  Nt.prototype._off = function (t, r, n) {
    Dt(typeof t == "string", "Method should be a string"),
      Dt(Ko.includes(t), `Method '${t}' is not an http method.`);
    function s(u) {
      return t !== u.method || r !== u.path;
    }
    function i(u) {
      return s(u) || !U0(n, u.opts.constraints || {});
    }
    let o = n ? i : s,
      a = this.routes.filter(o);
    this._rebuild(a);
  };
  Nt.prototype.lookup = function (t, r, n, s) {
    if ((typeof n == "function" && ((s = n), (n = void 0)), s === void 0)) {
      let i = this.constrainer.deriveConstraints(t, n),
        o = this.find(t.method, t.url, i);
      return this.callHandler(o, t, r, n);
    }
    this.constrainer.deriveConstraints(t, n, (i, o) => {
      if (i !== null) {
        s(i);
        return;
      }
      try {
        let a = this.find(t.method, t.url, o),
          u = this.callHandler(a, t, r, n);
        s(null, u);
      } catch (a) {
        s(a);
      }
    });
  };
  Nt.prototype.callHandler = function (t, r, n, s) {
    return t === null
      ? this._defaultRoute(r, n, s)
      : s === void 0
        ? t.handler(r, n, t.params, t.store, t.searchParams)
        : t.handler.call(s, r, n, t.params, t.store, t.searchParams);
  };
  Nt.prototype.find = function (t, r, n) {
    let s = this.trees[t];
    if (s === void 0) return null;
    r.charCodeAt(0) !== 47 && (r = r.replace(QI, "/")), this.ignoreDuplicateSlashes && (r = H0(r));
    let i, o, a;
    try {
      (i = ZY(r, this.useSemicolonDelimiter)),
        (r = i.path),
        (o = i.querystring),
        (a = i.shouldDecodeParam);
    } catch {
      return this._onBadUrl(r);
    }
    this.ignoreTrailingSlash && (r = B0(r));
    let u = r;
    this.caseSensitive === !1 && (r = r.toLowerCase());
    let l = this.maxParamLength,
      c = s.prefix.length,
      f = [],
      d = r.length,
      h = [];
    for (;;) {
      if (c === d && s.isLeafNode) {
        let S = s.handlerStorage.getMatchingHandler(n);
        if (S !== null)
          return {
            handler: S.handler,
            store: S.store,
            params: S._createParamsObject(f),
            searchParams: this.querystringParser(o),
          };
      }
      let p = s.getNextNode(r, c, h, f.length);
      if (p === null) {
        if (h.length === 0) return null;
        let S = h.pop();
        (c = S.brotherPathIndex), f.splice(S.paramsCount), (p = S.brotherNode);
      }
      if (((s = p), s.kind === GI.STATIC)) {
        c += s.prefix.length;
        continue;
      }
      if (s.kind === GI.WILDCARD) {
        let S = u.slice(c);
        a && (S = JI(S)), f.push(S), (c = d);
        continue;
      }
      let y = u.indexOf("/", c);
      y === -1 && (y = d);
      let _ = u.slice(c, y);
      if ((a && (_ = JI(_)), s.isRegex)) {
        let S = s.regex.exec(_);
        if (S === null) continue;
        for (let E = 1; E < S.length; E++) {
          let g = S[E];
          if (g.length > l) return null;
          f.push(g);
        }
      } else {
        if (_.length > l) return null;
        f.push(_);
      }
      c = y;
    }
  };
  Nt.prototype._rebuild = function (e) {
    this.reset();
    for (let t of e) {
      let { method: r, path: n, opts: s, handler: i, store: o } = t;
      this._on(r, n, s, i, o);
    }
  };
  Nt.prototype._defaultRoute = function (e, t, r) {
    if (this.defaultRoute !== null)
      return r === void 0 ? this.defaultRoute(e, t) : this.defaultRoute.call(r, e, t);
    (t.statusCode = 404), t.end();
  };
  Nt.prototype._onBadUrl = function (e) {
    if (this.onBadUrl === null) return null;
    let t = this.onBadUrl;
    return { handler: (r, n, s) => t(e, r, n), params: {}, store: null };
  };
  Nt.prototype.prettyPrint = function (e = {}) {
    let t = e.method;
    e.buildPrettyMeta = this.buildPrettyMeta.bind(this);
    let r = null;
    if (t === void 0) {
      let { version: n, host: s, ...i } = this.constrainer.strategies;
      i[V0.name] = V0;
      let o = new Nt({ ...this._opts, constraints: i }),
        a = this.routes.map((u) => {
          let l = { ...u.opts.constraints, [V0.name]: u.method };
          return { ...u, method: "MERGED", opts: { constraints: l } };
        });
      o._rebuild(a), (r = o.trees.MERGED);
    } else r = this.trees[t];
    return r == null ? "(empty tree)" : YY(r, e);
  };
  for (let e in Ko) {
    if (!Ko.hasOwnProperty(e)) continue;
    let t = Ko[e],
      r = t.toLowerCase();
    Nt.prototype[r] = function (n, s, i) {
      return this.on(t, n, s, i);
    };
  }
  Nt.prototype.all = function (e, t, r) {
    this.on(Ko, e, t, r);
  };
  ZI.exports = Nt;
  function WI(e) {
    return e.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
  }
  function H0(e) {
    return e.replace(/\/\/+/g, "/");
  }
  function B0(e) {
    return e.length > 1 && e.charCodeAt(e.length - 1) === 47 ? e.slice(0, -1) : e;
  }
  function YI(e) {
    return (
      e.charCodeAt(1) === 94 && (e = e.slice(0, 1) + e.slice(2)),
      e.charCodeAt(e.length - 2) === 36 && (e = e.slice(0, e.length - 2) + e.slice(e.length - 1)),
      e
    );
  }
  function XI(e, t) {
    let r = 1;
    for (; t < e.length; ) {
      if ((t++, e[t] === "\\")) {
        t++;
        continue;
      }
      if ((e[t] === ")" ? r-- : e[t] === "(" && r++, !r)) return t;
    }
    throw new TypeError('Invalid regexp expression in "' + e + '"');
  }
  function eX(e) {
    return e ? (e.store ? Object.assign({}, e.store) : {}) : {};
  }
});
var tC = b((eue, eC) => {
  "use strict";
  function G0(e, t, r, n) {
    if (r === void 0) return t.header("content-length", "0"), n(null, null);
    if (typeof r.resume == "function")
      return (
        r.on("error", (i) => {
          t.log.error({ err: i }, "Error on Stream found for HEAD route");
        }),
        r.resume(),
        n(null, null)
      );
    let s = "" + Buffer.byteLength(r);
    t.header("content-length", s), n(null, null);
  }
  function tX(e) {
    return e == null ? G0 : Array.isArray(e) ? [...e, G0] : [e, G0];
  }
  eC.exports = { parseHeadOnSendHandlers: tX };
});
var _C = b((tue, gC) => {
  "use strict";
  var rX = K0(),
    nX = xc(),
    rC = jh(),
    {
      onRequestAbortHookRunner: sX,
      lifecycleHooks: nC,
      preParsingHookRunner: iX,
      onTimeoutHookRunner: oX,
      onRequestHookRunner: aX,
    } = Os(),
    { supportedMethods: uX } = pm(),
    { normalizeSchema: lX } = wa(),
    { parseHeadOnSendHandlers: cX } = tC(),
    { FSTDEP007: fX, FSTDEP008: dX, FSTDEP014: sC } = ts(),
    { compileSchemasForValidation: hX, compileSchemasForSerialization: pX } = Ih(),
    {
      FST_ERR_SCH_VALIDATION_BUILD: mX,
      FST_ERR_SCH_SERIALIZATION_BUILD: yX,
      FST_ERR_DEFAULT_ROUTE_INVALID_TYPE: gX,
      FST_ERR_DUPLICATED_ROUTE: _X,
      FST_ERR_INVALID_URL: SX,
      FST_ERR_HOOK_INVALID_HANDLER: iC,
      FST_ERR_ROUTE_OPTIONS_NOT_OBJ: vX,
      FST_ERR_ROUTE_DUPLICATED_HANDLER: bX,
      FST_ERR_ROUTE_HANDLER_NOT_FN: oC,
      FST_ERR_ROUTE_MISSING_HANDLER: wX,
      FST_ERR_ROUTE_METHOD_NOT_SUPPORTED: EX,
      FST_ERR_ROUTE_METHOD_INVALID: RX,
      FST_ERR_ROUTE_BODY_VALIDATION_SCHEMA_NOT_SUPPORTED: TX,
      FST_ERR_ROUTE_BODY_LIMIT_OPTION_NOT_INT: PX,
      FST_ERR_HOOK_INVALID_ASYNC_HANDLER: J0,
    } = tr(),
    {
      kRoutePrefix: $X,
      kLogLevel: OX,
      kLogSerializers: aC,
      kHooks: uC,
      kSchemaController: NX,
      kOptions: lC,
      kReplySerializerDefault: Q0,
      kReplyIsError: AX,
      kRequestPayloadStream: IX,
      kDisableRequestLogging: CX,
      kSchemaErrorFormatter: kX,
      kErrorHandler: cC,
      kHasBeenDecorated: fC,
      kRequestAcceptVersion: W0,
      kRouteByFastify: Y0,
      kRouteContext: dC,
    } = Vt(),
    { buildErrorHandler: DX } = Ea(),
    { createChildLogger: qX } = ba(),
    { getGenReqId: jX } = Hf();
  function LX(e) {
    let t = rX(e.config),
      r,
      n,
      s,
      i,
      o,
      a,
      u,
      l,
      c,
      f,
      d,
      h,
      p,
      y = !1;
    return {
      setup($, D) {
        (r = D.avvio),
          (n = D.fourOhFour),
          (s = D.logger),
          (i = D.hasLogger),
          (o = D.setupResponseListeners),
          (a = D.throwIfAlreadyStarted),
          (h = D.validateHTTPVersion),
          (d = $.exposeHeadRoutes),
          (u = $.disableRequestLogging),
          (l = $.ignoreTrailingSlash),
          (c = $.ignoreDuplicateSlashes),
          (f = Object.prototype.hasOwnProperty.call($, "return503OnClosing")
            ? $.return503OnClosing
            : !0),
          (p = D.keepAliveConnections);
      },
      routing: t.lookup.bind(t),
      route: N,
      hasRoute: m,
      prepareRoute: g,
      getDefaultRoute: function () {
        return sC(), t.defaultRoute;
      },
      setDefaultRoute: function ($) {
        if ((sC(), typeof $ != "function")) throw new gX();
        t.defaultRoute = $;
      },
      routeHandler: w,
      closeRoutes: () => {
        y = !0;
      },
      printRoutes: t.prettyPrint.bind(t),
      addConstraintStrategy: _,
      hasConstraintStrategy: S,
      isAsyncConstraint: E,
      findRoute: T,
    };
    function _($) {
      return a("Cannot add constraint strategy!"), t.addConstraintStrategy($);
    }
    function S($) {
      return t.hasConstraintStrategy($);
    }
    function E() {
      return t.constrainer.asyncStrategiesInUse.size > 0;
    }
    function g({ method: $, url: D, options: v, handler: M, isFastify: k }) {
      if (typeof D != "string") throw new SX(typeof D);
      if (!M && typeof v == "function") (M = v), (v = {});
      else if (M && typeof M == "function") {
        if (Object.prototype.toString.call(v) !== "[object Object]") throw new vX($, D);
        if (v.handler) throw typeof v.handler == "function" ? new bX($, D) : new oC($, D);
      }
      return (
        (v = Object.assign({}, v, { method: $, url: D, path: D, handler: M || (v && v.handler) })),
        N.call(this, { options: v, isFastify: k })
      );
    }
    function m({ options: $ }) {
      let D = $.method?.toUpperCase() ?? "";
      return T({ ...$, method: D }) !== null;
    }
    function T($) {
      let D = t.find($.method, $.url || "", $.constraints);
      return D ? { handler: D.handler, params: D.params, searchParams: D.searchParams } : null;
    }
    function N({ options: $, isFastify: D }) {
      let v = { ...$ },
        { exposeHeadRoute: M } = v,
        x = M != null ? M : d,
        ie = v.method === "GET" || (Array.isArray(v.method) && v.method.includes("GET")),
        Z = v.method === "HEAD" || (Array.isArray(v.method) && v.method.includes("HEAD")),
        G = x && ie ? { ...$ } : null;
      a("Cannot add route!");
      let Y = v.url || v.path || "";
      if (Array.isArray(v.method))
        for (var U = 0; U < v.method.length; ++U)
          (v.method[U] = hC(v.method[U])), pC(v.method[U], Y, v.schema);
      else (v.method = hC(v.method)), pC(v.method, Y, v.schema);
      if (!v.handler) throw new wX(v.method, Y);
      if (v.errorHandler !== void 0 && typeof v.errorHandler != "function")
        throw new oC(v.method, Y);
      yC(v.bodyLimit);
      let z = this[$X];
      if (Y === "/" && z.length > 0 && v.method !== "HEAD")
        switch (v.prefixTrailingSlash) {
          case "slash":
            oe.call(this, { path: Y, isFastify: D });
            break;
          case "no-slash":
            oe.call(this, { path: "", isFastify: D });
            break;
          case "both":
          default:
            oe.call(this, { path: "", isFastify: D }),
              l !== !0 &&
                (c !== !0 || !z.endsWith("/")) &&
                oe.call(this, { path: Y, prefixing: !0, isFastify: D });
        }
      else
        Y[0] === "/" && z.endsWith("/")
          ? oe.call(this, { path: Y.slice(1), isFastify: D })
          : oe.call(this, { path: Y, isFastify: D });
      return this;
      function oe({ path: Te, prefixing: ce = !1, isFastify: Se = !1 }) {
        let Ee = z + Te;
        if (
          ((v.url = Ee),
          (v.path = Ee),
          (v.routePath = Te),
          (v.prefix = z),
          (v.logLevel = v.logLevel || this[OX]),
          (this[aC] || v.logSerializers) &&
            (v.logSerializers = Object.assign(Object.create(this[aC]), v.logSerializers)),
          v.attachValidation == null && (v.attachValidation = !1),
          ce === !1)
        )
          for (let Oe of this[uC].onRoute) Oe.call(this, v);
        for (let Oe of nC)
          if (v && Oe in v) {
            if (Array.isArray(v[Oe]))
              for (let me of v[Oe]) {
                if (typeof me != "function") throw new iC(Oe, Object.prototype.toString.call(me));
                if (
                  Oe === "onSend" ||
                  Oe === "preSerialization" ||
                  Oe === "onError" ||
                  Oe === "preParsing"
                ) {
                  if (me.constructor.name === "AsyncFunction" && me.length === 4) throw new J0();
                } else if (Oe === "onRequestAbort") {
                  if (me.constructor.name === "AsyncFunction" && me.length !== 1) throw new J0();
                } else if (me.constructor.name === "AsyncFunction" && me.length === 3)
                  throw new J0();
              }
            else if (v[Oe] !== void 0 && typeof v[Oe] != "function")
              throw new iC(Oe, Object.prototype.toString.call(v[Oe]));
          }
        let ue = v.constraints || {},
          Re = { ...v.config, url: Ee, method: v.method },
          ee = new nX({
            schema: v.schema,
            handler: v.handler.bind(this),
            config: Re,
            errorHandler: v.errorHandler,
            childLoggerFactory: v.childLoggerFactory,
            bodyLimit: v.bodyLimit,
            logLevel: v.logLevel,
            logSerializers: v.logSerializers,
            attachValidation: v.attachValidation,
            schemaErrorFormatter: v.schemaErrorFormatter,
            replySerializer: this[Q0],
            validatorCompiler: v.validatorCompiler,
            serializerCompiler: v.serializerCompiler,
            exposeHeadRoute: x,
            prefixTrailingSlash: v.prefixTrailingSlash || "both",
            server: this,
            isFastify: Se,
          });
        v.version && (dX(), (ue.version = v.version));
        let ve = t.findRoute("HEAD", v.url, ue),
          Ae = ve !== null;
        Z && Ae && !ee[Y0] && ve.store[Y0] && t.off("HEAD", v.url, ue);
        try {
          t.on(v.method, v.url, { constraints: ue }, w, ee);
        } catch (Oe) {
          if (!ee[Y0])
            throw Oe.message.includes(`Method '${v.method}' already declared for route '${v.url}'`)
              ? new _X(v.method, v.url)
              : Oe;
        }
        if (
          (this.after((Oe, me) => {
            (ee.errorHandler = v.errorHandler ? DX(this[cC], v.errorHandler) : this[cC]),
              (ee._parserOptions.limit = v.bodyLimit || null),
              (ee.logLevel = v.logLevel),
              (ee.logSerializers = v.logSerializers),
              (ee.attachValidation = v.attachValidation),
              (ee[Q0] = this[Q0]),
              (ee.schemaErrorFormatter =
                v.schemaErrorFormatter || this[kX] || ee.schemaErrorFormatter),
              r.once("preReady", () => {
                for (let C of nC) {
                  let H = this[uC][C].concat(v[C] || []).map((K) => K.bind(this));
                  ee[C] = H.length ? H : null;
                }
                for (; !ee.Request[fC] && ee.Request.parent; ) ee.Request = ee.Request.parent;
                for (; !ee.Reply[fC] && ee.Reply.parent; ) ee.Reply = ee.Reply.parent;
                if ((n.setContext(this, ee), v.schema)) {
                  ee.schema = lX(ee.schema, this.initialConfig);
                  let C = this[NX];
                  !v.validatorCompiler &&
                    (v.schema.body ||
                      v.schema.headers ||
                      v.schema.querystring ||
                      v.schema.params) &&
                    C.setupValidator(this[lC]);
                  try {
                    let H =
                      typeof v?.validatorCompiler == "function" || C.isCustomValidatorCompiler;
                    hX(ee, v.validatorCompiler || C.validatorCompiler, H);
                  } catch (H) {
                    throw new mX(v.method, Ee, H.message);
                  }
                  v.schema.response && !v.serializerCompiler && C.setupSerializer(this[lC]);
                  try {
                    pX(ee, v.serializerCompiler || C.serializerCompiler);
                  } catch (H) {
                    throw new yX(v.method, Ee, H.message);
                  }
                }
              }),
              me(Oe);
          }),
          x && ie && !Z && !Ae)
        ) {
          let Oe = cX(G.onSend);
          g.call(this, { method: "HEAD", url: Te, options: { ...G, onSend: Oe }, isFastify: !0 });
        } else Ae && M && fX();
      }
    }
    function w($, D, v, M, k) {
      let x = jX(M.server, $),
        ie = { level: M.logLevel };
      M.logSerializers && (ie.serializers = M.logSerializers);
      let Z = qX(M, s, $, x, ie);
      if (((Z[CX] = u), !h($.httpVersion))) {
        Z.info({ res: { statusCode: 505 } }, "request aborted - invalid HTTP version");
        let z =
            '{"error":"HTTP Version Not Supported","message":"HTTP Version Not Supported","statusCode":505}',
          oe = { "Content-Type": "application/json", "Content-Length": z.length };
        D.writeHead(505, oe), D.end(z);
        return;
      }
      if (y === !0 && ($.httpVersionMajor !== 2 && D.setHeader("Connection", "close"), f)) {
        let z = { "Content-Type": "application/json", "Content-Length": "80" };
        D.writeHead(503, z),
          D.end('{"error":"Service Unavailable","message":"Service Unavailable","statusCode":503}'),
          Z.info(
            { res: { statusCode: 503 } },
            "request aborted - refusing to accept new requests as server is closing",
          );
        return;
      }
      String.prototype.toLowerCase.call($.headers.connection || "") === "keep-alive" &&
        p.has($.socket) === !1 &&
        (p.add($.socket),
        $.socket.on("close", MX.bind({ keepAliveConnections: p, socket: $.socket }))),
        $.headers[W0] !== void 0 &&
          (($.headers["accept-version"] = $.headers[W0]), ($.headers[W0] = void 0));
      let Y = new M.Request(x, v, $, k, Z, M),
        U = new M.Reply(D, Y, Z);
      u === !1 && Z.info({ req: Y }, "incoming request"),
        (i === !0 || M.onResponse !== null) && o(U),
        M.onRequest !== null ? aX(M.onRequest, Y, U, mC) : mC(null, Y, U),
        M.onRequestAbort !== null &&
          $.on("close", () => {
            $.aborted && sX(M.onRequestAbort, Y, xX.bind(null, U));
          }),
        M.onTimeout !== null &&
          (Y.raw.socket._meta || Y.raw.socket.on("timeout", FX),
          (Y.raw.socket._meta = { context: M, request: Y, reply: U }));
    }
  }
  function xX(e, t) {
    t && e.log.error({ err: t }, "onRequestAborted hook failed");
  }
  function FX() {
    let { context: e, request: t, reply: r } = this._meta;
    oX(e.onTimeout, t, r, zX);
  }
  function hC(e) {
    if (typeof e != "string") throw new RX();
    if (((e = e.toUpperCase()), uX.indexOf(e) === -1)) throw new EX(e);
    return e;
  }
  function pC(e, t, r) {
    if ((e === "GET" || e === "HEAD") && r && r.body) throw new TX(e, t);
  }
  function yC(e) {
    if (e !== void 0 && (!Number.isInteger(e) || e <= 0)) throw new PX(e);
  }
  function mC(e, t, r) {
    if (r.sent !== !0) {
      if (e != null) {
        (r[AX] = !0), r.send(e);
        return;
      }
      (t[IX] = t.raw), t[dC].preParsing !== null ? iX(t[dC].preParsing, t, r, rC) : rC(null, t, r);
    }
  }
  function MX() {
    this.keepAliveConnections.delete(this.socket);
  }
  function zX() {}
  gC.exports = { buildRouting: LX, validateBodyLimitOption: yC };
});
var TC = b((rue, RC) => {
  "use strict";
  var VX = K0(),
    SC = wc(),
    vC = Lc(),
    UX = xc(),
    {
      kRoutePrefix: HX,
      kCanSetNotFoundHandler: Au,
      kFourOhFourLevelInstance: Iu,
      kFourOhFourContext: Hn,
      kHooks: BX,
      kErrorHandler: bC,
    } = Vt(),
    { lifecycleHooks: KX } = Os(),
    { buildErrorHandler: GX } = Ea(),
    { FST_ERR_NOT_FOUND: JX } = tr(),
    { createChildLogger: wC } = ba(),
    { getGenReqId: EC } = Hf();
  function QX(e) {
    let { logger: t, disableRequestLogging: r } = e,
      n = VX({ onBadUrl: a(), defaultRoute: f }),
      s = null;
    return { router: n, setNotFoundHandler: l, setContext: u, arrange404: i };
    function i(d) {
      (d[Iu] = d),
        (d[Au] = !0),
        (n.onBadUrl = n.onBadUrl.bind(d)),
        (n.defaultRoute = n.defaultRoute.bind(d));
    }
    function o(d, h) {
      let { url: p, method: y } = d.raw,
        _ = `Route ${y}:${p} not found`;
      r || d.log.info(_), h.code(404).send({ message: _, error: "Not Found", statusCode: 404 });
    }
    function a() {
      return function (h, p, y) {
        let _ = this[Iu][Hn],
          S = EC(_.server, p),
          E = wC(_, t, p, S),
          g = new vC(S, null, p, null, E, _),
          m = new SC(y, g, E);
        s(g, m);
      };
    }
    function u(d, h) {
      let p = Object.assign({}, d[Hn]);
      (p.onSend = h.onSend), (h[Hn] = p);
    }
    function l(d, h, p, y) {
      this[Au] === void 0 && (this[Au] = !0), this[Hn] === void 0 && (this[Hn] = null);
      let _ = this,
        S = this[HX] || "/";
      if (this[Au] === !1)
        throw new Error(`Not found handler already set for Fastify instance with prefix: '${S}'`);
      typeof d == "object" &&
        (d.preHandler &&
          (Array.isArray(d.preHandler)
            ? (d.preHandler = d.preHandler.map((E) => E.bind(_)))
            : (d.preHandler = d.preHandler.bind(_))),
        d.preValidation &&
          (Array.isArray(d.preValidation)
            ? (d.preValidation = d.preValidation.map((E) => E.bind(_)))
            : (d.preValidation = d.preValidation.bind(_)))),
        typeof d == "function" && ((h = d), (d = void 0)),
        (d = d || {}),
        h ? ((this[Iu][Au] = !1), (h = h.bind(this)), (s = h)) : ((h = o), (s = o)),
        this.after((E, g) => {
          c.call(this, S, d, h, p, y), g(E);
        });
    }
    function c(d, h, p, y, _) {
      let S = new UX({ schema: h.schema, handler: p, config: h.config || {}, server: this });
      if (
        (y.once("preReady", () => {
          let E = this[Hn];
          for (let g of KX) {
            let m = this[BX][g].concat(h[g] || []).map((T) => T.bind(this));
            E[g] = m.length ? m : null;
          }
          E.errorHandler = h.errorHandler ? GX(this[bC], h.errorHandler) : this[bC];
        }),
        this[Hn] !== null && d === "/")
      ) {
        Object.assign(this[Hn], S);
        return;
      }
      (this[Iu][Hn] = S), n.all(d + (d.endsWith("/") ? "*" : "/*"), _, S), n.all(d, _, S);
    }
    function f(d, h) {
      let p = this[Iu][Hn],
        y = EC(p.server, d),
        _ = wC(p, t, d, y);
      _.info({ req: d }, "incoming request");
      let S = new vC(y, null, d, null, _, p),
        E = new SC(h, S, _);
      S.log.warn(
        "the default handler for 404 did not catch this, this is likely a fastify bug, please report it",
      ),
        S.log.warn(n.prettyPrint()),
        E.code(404).send(new JX());
    }
  }
  RC.exports = QX;
});
var $C = b((nue, ld) => {
  "use strict";
  ld.exports = Be;
  ld.exports.default = Be;
  var PC = {
      type: "object",
      additionalProperties: !1,
      properties: {
        connectionTimeout: { type: "integer", default: 0 },
        keepAliveTimeout: { type: "integer", default: 72e3 },
        forceCloseConnections: {
          oneOf: [{ type: "string", pattern: "idle" }, { type: "boolean" }],
        },
        maxRequestsPerSocket: { type: "integer", default: 0, nullable: !0 },
        requestTimeout: { type: "integer", default: 0 },
        bodyLimit: { type: "integer", default: 1048576 },
        caseSensitive: { type: "boolean", default: !0 },
        allowUnsafeRegex: { type: "boolean", default: !1 },
        http2: { type: "boolean" },
        https: {
          if: {
            not: {
              oneOf: [
                { type: "boolean" },
                { type: "null" },
                {
                  type: "object",
                  additionalProperties: !1,
                  required: ["allowHTTP1"],
                  properties: { allowHTTP1: { type: "boolean" } },
                },
              ],
            },
          },
          then: { setDefaultValue: !0 },
        },
        ignoreTrailingSlash: { type: "boolean", default: !1 },
        ignoreDuplicateSlashes: { type: "boolean", default: !1 },
        disableRequestLogging: { type: "boolean", default: !1 },
        jsonShorthand: { type: "boolean", default: !0 },
        maxParamLength: { type: "integer", default: 100 },
        onProtoPoisoning: { type: "string", default: "error" },
        onConstructorPoisoning: { type: "string", default: "error" },
        pluginTimeout: { type: "integer", default: 1e4 },
        requestIdHeader: { anyOf: [{ enum: [!1] }, { type: "string" }], default: "request-id" },
        requestIdLogLabel: { type: "string", default: "reqId" },
        http2SessionTimeout: { type: "integer", default: 72e3 },
        exposeHeadRoutes: { type: "boolean", default: !0 },
        useSemicolonDelimiter: { type: "boolean", default: !0 },
        versioning: {
          type: "object",
          additionalProperties: !0,
          required: ["storage", "deriveVersion"],
          properties: { storage: {}, deriveVersion: {} },
        },
        constraints: {
          type: "object",
          additionalProperties: {
            type: "object",
            required: ["name", "storage", "validate", "deriveConstraint"],
            additionalProperties: !0,
            properties: {
              name: { type: "string" },
              storage: {},
              validate: {},
              deriveConstraint: {},
            },
          },
        },
      },
    },
    WX = Object.prototype.hasOwnProperty,
    YX = new RegExp("idle", "u");
  function Be(
    e,
    { instancePath: t = "", parentData: r, parentDataProperty: n, rootData: s = e } = {},
  ) {
    let i = null,
      o = 0;
    if (o === 0)
      if (e && typeof e == "object" && !Array.isArray(e)) {
        e.connectionTimeout === void 0 && (e.connectionTimeout = 0),
          e.keepAliveTimeout === void 0 && (e.keepAliveTimeout = 72e3),
          e.maxRequestsPerSocket === void 0 && (e.maxRequestsPerSocket = 0),
          e.requestTimeout === void 0 && (e.requestTimeout = 0),
          e.bodyLimit === void 0 && (e.bodyLimit = 1048576),
          e.caseSensitive === void 0 && (e.caseSensitive = !0),
          e.allowUnsafeRegex === void 0 && (e.allowUnsafeRegex = !1),
          e.ignoreTrailingSlash === void 0 && (e.ignoreTrailingSlash = !1),
          e.ignoreDuplicateSlashes === void 0 && (e.ignoreDuplicateSlashes = !1),
          e.disableRequestLogging === void 0 && (e.disableRequestLogging = !1),
          e.jsonShorthand === void 0 && (e.jsonShorthand = !0),
          e.maxParamLength === void 0 && (e.maxParamLength = 100),
          e.onProtoPoisoning === void 0 && (e.onProtoPoisoning = "error"),
          e.onConstructorPoisoning === void 0 && (e.onConstructorPoisoning = "error"),
          e.pluginTimeout === void 0 && (e.pluginTimeout = 1e4),
          e.requestIdHeader === void 0 && (e.requestIdHeader = "request-id"),
          e.requestIdLogLabel === void 0 && (e.requestIdLogLabel = "reqId"),
          e.http2SessionTimeout === void 0 && (e.http2SessionTimeout = 72e3),
          e.exposeHeadRoutes === void 0 && (e.exposeHeadRoutes = !0),
          e.useSemicolonDelimiter === void 0 && (e.useSemicolonDelimiter = !0);
        let p = o;
        for (let y in e) WX.call(PC.properties, y) || delete e[y];
        if (p === o) {
          let y = e.connectionTimeout,
            _ = o;
          if (!(typeof y == "number" && !(y % 1) && !isNaN(y) && isFinite(y))) {
            let S = typeof y,
              E;
            if (E === void 0)
              if (S === "boolean" || y === null || (S === "string" && y && y == +y && !(y % 1)))
                E = +y;
              else
                return (
                  (Be.errors = [
                    {
                      instancePath: t + "/connectionTimeout",
                      schemaPath: "#/properties/connectionTimeout/type",
                      keyword: "type",
                      params: { type: "integer" },
                      message: "must be integer",
                    },
                  ]),
                  !1
                );
            E !== void 0 && ((y = E), e !== void 0 && (e.connectionTimeout = E));
          }
          var a = _ === o;
          if (a) {
            let S = e.keepAliveTimeout,
              E = o;
            if (!(typeof S == "number" && !(S % 1) && !isNaN(S) && isFinite(S))) {
              let m = typeof S,
                T;
              if (T === void 0)
                if (m === "boolean" || S === null || (m === "string" && S && S == +S && !(S % 1)))
                  T = +S;
                else
                  return (
                    (Be.errors = [
                      {
                        instancePath: t + "/keepAliveTimeout",
                        schemaPath: "#/properties/keepAliveTimeout/type",
                        keyword: "type",
                        params: { type: "integer" },
                        message: "must be integer",
                      },
                    ]),
                    !1
                  );
              T !== void 0 && ((S = T), e !== void 0 && (e.keepAliveTimeout = T));
            }
            var a = E === o;
            if (a) {
              if (e.forceCloseConnections !== void 0) {
                let m = e.forceCloseConnections,
                  T = o,
                  N = o,
                  w = !1,
                  $ = null,
                  D = o;
                if (typeof m != "string") {
                  let k = typeof m,
                    x;
                  if (x === void 0)
                    if (k == "number" || k == "boolean") x = "" + m;
                    else if (m === null) x = "";
                    else {
                      let ie = {
                        instancePath: t + "/forceCloseConnections",
                        schemaPath: "#/properties/forceCloseConnections/oneOf/0/type",
                        keyword: "type",
                        params: { type: "string" },
                        message: "must be string",
                      };
                      i === null ? (i = [ie]) : i.push(ie), o++;
                    }
                  x !== void 0 && ((m = x), e !== void 0 && (e.forceCloseConnections = x));
                }
                if (o === D && typeof m == "string" && !YX.test(m)) {
                  let k = {
                    instancePath: t + "/forceCloseConnections",
                    schemaPath: "#/properties/forceCloseConnections/oneOf/0/pattern",
                    keyword: "pattern",
                    params: { pattern: "idle" },
                    message: 'must match pattern "idle"',
                  };
                  i === null ? (i = [k]) : i.push(k), o++;
                }
                var u = D === o;
                u && ((w = !0), ($ = 0));
                let v = o;
                if (typeof m != "boolean") {
                  let k;
                  if (k === void 0)
                    if (m === "false" || m === 0 || m === null) k = !1;
                    else if (m === "true" || m === 1) k = !0;
                    else {
                      let x = {
                        instancePath: t + "/forceCloseConnections",
                        schemaPath: "#/properties/forceCloseConnections/oneOf/1/type",
                        keyword: "type",
                        params: { type: "boolean" },
                        message: "must be boolean",
                      };
                      i === null ? (i = [x]) : i.push(x), o++;
                    }
                  k !== void 0 && ((m = k), e !== void 0 && (e.forceCloseConnections = k));
                }
                var u = v === o;
                if ((u && w ? ((w = !1), ($ = [$, 1])) : u && ((w = !0), ($ = 1)), w))
                  (o = N), i !== null && (N ? (i.length = N) : (i = null));
                else {
                  let k = {
                    instancePath: t + "/forceCloseConnections",
                    schemaPath: "#/properties/forceCloseConnections/oneOf",
                    keyword: "oneOf",
                    params: { passingSchemas: $ },
                    message: "must match exactly one schema in oneOf",
                  };
                  return i === null ? (i = [k]) : i.push(k), o++, (Be.errors = i), !1;
                }
                var a = T === o;
              } else var a = !0;
              if (a) {
                let m = e.maxRequestsPerSocket,
                  T = o;
                if (!(typeof m == "number" && !(m % 1) && !isNaN(m) && isFinite(m)) && m !== null) {
                  let w = typeof m,
                    $;
                  if ($ === void 0)
                    if (
                      w === "boolean" ||
                      m === null ||
                      (w === "string" && m && m == +m && !(m % 1))
                    )
                      $ = +m;
                    else if (m === "" || m === 0 || m === !1) $ = null;
                    else
                      return (
                        (Be.errors = [
                          {
                            instancePath: t + "/maxRequestsPerSocket",
                            schemaPath: "#/properties/maxRequestsPerSocket/type",
                            keyword: "type",
                            params: { type: "integer" },
                            message: "must be integer",
                          },
                        ]),
                        !1
                      );
                  $ !== void 0 && ((m = $), e !== void 0 && (e.maxRequestsPerSocket = $));
                }
                var a = T === o;
                if (a) {
                  let w = e.requestTimeout,
                    $ = o;
                  if (!(typeof w == "number" && !(w % 1) && !isNaN(w) && isFinite(w))) {
                    let v = typeof w,
                      M;
                    if (M === void 0)
                      if (
                        v === "boolean" ||
                        w === null ||
                        (v === "string" && w && w == +w && !(w % 1))
                      )
                        M = +w;
                      else
                        return (
                          (Be.errors = [
                            {
                              instancePath: t + "/requestTimeout",
                              schemaPath: "#/properties/requestTimeout/type",
                              keyword: "type",
                              params: { type: "integer" },
                              message: "must be integer",
                            },
                          ]),
                          !1
                        );
                    M !== void 0 && ((w = M), e !== void 0 && (e.requestTimeout = M));
                  }
                  var a = $ === o;
                  if (a) {
                    let v = e.bodyLimit,
                      M = o;
                    if (!(typeof v == "number" && !(v % 1) && !isNaN(v) && isFinite(v))) {
                      let x = typeof v,
                        ie;
                      if (ie === void 0)
                        if (
                          x === "boolean" ||
                          v === null ||
                          (x === "string" && v && v == +v && !(v % 1))
                        )
                          ie = +v;
                        else
                          return (
                            (Be.errors = [
                              {
                                instancePath: t + "/bodyLimit",
                                schemaPath: "#/properties/bodyLimit/type",
                                keyword: "type",
                                params: { type: "integer" },
                                message: "must be integer",
                              },
                            ]),
                            !1
                          );
                      ie !== void 0 && ((v = ie), e !== void 0 && (e.bodyLimit = ie));
                    }
                    var a = M === o;
                    if (a) {
                      let x = e.caseSensitive,
                        ie = o;
                      if (typeof x != "boolean") {
                        let G;
                        if (G === void 0)
                          if (x === "false" || x === 0 || x === null) G = !1;
                          else if (x === "true" || x === 1) G = !0;
                          else
                            return (
                              (Be.errors = [
                                {
                                  instancePath: t + "/caseSensitive",
                                  schemaPath: "#/properties/caseSensitive/type",
                                  keyword: "type",
                                  params: { type: "boolean" },
                                  message: "must be boolean",
                                },
                              ]),
                              !1
                            );
                        G !== void 0 && ((x = G), e !== void 0 && (e.caseSensitive = G));
                      }
                      var a = ie === o;
                      if (a) {
                        let G = e.allowUnsafeRegex,
                          Y = o;
                        if (typeof G != "boolean") {
                          let z;
                          if (z === void 0)
                            if (G === "false" || G === 0 || G === null) z = !1;
                            else if (G === "true" || G === 1) z = !0;
                            else
                              return (
                                (Be.errors = [
                                  {
                                    instancePath: t + "/allowUnsafeRegex",
                                    schemaPath: "#/properties/allowUnsafeRegex/type",
                                    keyword: "type",
                                    params: { type: "boolean" },
                                    message: "must be boolean",
                                  },
                                ]),
                                !1
                              );
                          z !== void 0 && ((G = z), e !== void 0 && (e.allowUnsafeRegex = z));
                        }
                        var a = Y === o;
                        if (a) {
                          if (e.http2 !== void 0) {
                            let z = e.http2,
                              oe = o;
                            if (typeof z != "boolean") {
                              let ce;
                              if (ce === void 0)
                                if (z === "false" || z === 0 || z === null) ce = !1;
                                else if (z === "true" || z === 1) ce = !0;
                                else
                                  return (
                                    (Be.errors = [
                                      {
                                        instancePath: t + "/http2",
                                        schemaPath: "#/properties/http2/type",
                                        keyword: "type",
                                        params: { type: "boolean" },
                                        message: "must be boolean",
                                      },
                                    ]),
                                    !1
                                  );
                              ce !== void 0 && ((z = ce), e !== void 0 && (e.http2 = ce));
                            }
                            var a = oe === o;
                          } else var a = !0;
                          if (a) {
                            if (e.https !== void 0) {
                              let z = e.https,
                                oe = o,
                                Te = o,
                                ce = !0,
                                Se = o,
                                Ee = o,
                                ue = o,
                                Re = o,
                                ee = !1,
                                ve = null,
                                Ae = o;
                              if (typeof z != "boolean") {
                                let C;
                                if (C === void 0)
                                  if (z === "false" || z === 0 || z === null) C = !1;
                                  else if (z === "true" || z === 1) C = !0;
                                  else {
                                    let H = {};
                                    i === null ? (i = [H]) : i.push(H), o++;
                                  }
                                C !== void 0 && ((z = C), e !== void 0 && (e.https = C));
                              }
                              var l = Ae === o;
                              l && ((ee = !0), (ve = 0));
                              let Oe = o;
                              if (z !== null) {
                                let C;
                                if (C === void 0)
                                  if (z === "" || z === 0 || z === !1) C = null;
                                  else {
                                    let H = {};
                                    i === null ? (i = [H]) : i.push(H), o++;
                                  }
                                C !== void 0 && ((z = C), e !== void 0 && (e.https = C));
                              }
                              var l = Oe === o;
                              if (l && ee) (ee = !1), (ve = [ve, 1]);
                              else {
                                l && ((ee = !0), (ve = 1));
                                let C = o;
                                if (o === C)
                                  if (z && typeof z == "object" && !Array.isArray(z)) {
                                    let K;
                                    if (z.allowHTTP1 === void 0 && (K = "allowHTTP1")) {
                                      let te = {};
                                      i === null ? (i = [te]) : i.push(te), o++;
                                    } else {
                                      let te = o;
                                      for (let _e in z) _e !== "allowHTTP1" && delete z[_e];
                                      if (te === o && z.allowHTTP1 !== void 0) {
                                        let _e = z.allowHTTP1;
                                        if (typeof _e != "boolean") {
                                          let F;
                                          if (F === void 0)
                                            if (_e === "false" || _e === 0 || _e === null) F = !1;
                                            else if (_e === "true" || _e === 1) F = !0;
                                            else {
                                              let Me = {};
                                              i === null ? (i = [Me]) : i.push(Me), o++;
                                            }
                                          F !== void 0 &&
                                            ((_e = F), z !== void 0 && (z.allowHTTP1 = F));
                                        }
                                      }
                                    }
                                  } else {
                                    let K = {};
                                    i === null ? (i = [K]) : i.push(K), o++;
                                  }
                                var l = C === o;
                                l && ee ? ((ee = !1), (ve = [ve, 2])) : l && ((ee = !0), (ve = 2));
                              }
                              if (ee) (o = Re), i !== null && (Re ? (i.length = Re) : (i = null));
                              else {
                                let C = {};
                                i === null ? (i = [C]) : i.push(C), o++;
                              }
                              var c = ue === o;
                              if (c) {
                                let C = {};
                                i === null ? (i = [C]) : i.push(C), o++;
                              } else (o = Ee), i !== null && (Ee ? (i.length = Ee) : (i = null));
                              var f = Se === o;
                              if (
                                ((o = Te), i !== null && (Te ? (i.length = Te) : (i = null)), f)
                              ) {
                                let C = o;
                                e.https = !0;
                                var f = C === o;
                                ce = f;
                              }
                              if (!ce) {
                                let C = {
                                  instancePath: t + "/https",
                                  schemaPath: "#/properties/https/if",
                                  keyword: "if",
                                  params: { failingKeyword: "then" },
                                  message: 'must match "then" schema',
                                };
                                return i === null ? (i = [C]) : i.push(C), o++, (Be.errors = i), !1;
                              }
                              var a = oe === o;
                            } else var a = !0;
                            if (a) {
                              let z = e.ignoreTrailingSlash,
                                oe = o;
                              if (typeof z != "boolean") {
                                let ce;
                                if (ce === void 0)
                                  if (z === "false" || z === 0 || z === null) ce = !1;
                                  else if (z === "true" || z === 1) ce = !0;
                                  else
                                    return (
                                      (Be.errors = [
                                        {
                                          instancePath: t + "/ignoreTrailingSlash",
                                          schemaPath: "#/properties/ignoreTrailingSlash/type",
                                          keyword: "type",
                                          params: { type: "boolean" },
                                          message: "must be boolean",
                                        },
                                      ]),
                                      !1
                                    );
                                ce !== void 0 &&
                                  ((z = ce), e !== void 0 && (e.ignoreTrailingSlash = ce));
                              }
                              var a = oe === o;
                              if (a) {
                                let ce = e.ignoreDuplicateSlashes,
                                  Se = o;
                                if (typeof ce != "boolean") {
                                  let ue;
                                  if (ue === void 0)
                                    if (ce === "false" || ce === 0 || ce === null) ue = !1;
                                    else if (ce === "true" || ce === 1) ue = !0;
                                    else
                                      return (
                                        (Be.errors = [
                                          {
                                            instancePath: t + "/ignoreDuplicateSlashes",
                                            schemaPath: "#/properties/ignoreDuplicateSlashes/type",
                                            keyword: "type",
                                            params: { type: "boolean" },
                                            message: "must be boolean",
                                          },
                                        ]),
                                        !1
                                      );
                                  ue !== void 0 &&
                                    ((ce = ue), e !== void 0 && (e.ignoreDuplicateSlashes = ue));
                                }
                                var a = Se === o;
                                if (a) {
                                  let ue = e.disableRequestLogging,
                                    Re = o;
                                  if (typeof ue != "boolean") {
                                    let ve;
                                    if (ve === void 0)
                                      if (ue === "false" || ue === 0 || ue === null) ve = !1;
                                      else if (ue === "true" || ue === 1) ve = !0;
                                      else
                                        return (
                                          (Be.errors = [
                                            {
                                              instancePath: t + "/disableRequestLogging",
                                              schemaPath: "#/properties/disableRequestLogging/type",
                                              keyword: "type",
                                              params: { type: "boolean" },
                                              message: "must be boolean",
                                            },
                                          ]),
                                          !1
                                        );
                                    ve !== void 0 &&
                                      ((ue = ve), e !== void 0 && (e.disableRequestLogging = ve));
                                  }
                                  var a = Re === o;
                                  if (a) {
                                    let ve = e.jsonShorthand,
                                      Ae = o;
                                    if (typeof ve != "boolean") {
                                      let me;
                                      if (me === void 0)
                                        if (ve === "false" || ve === 0 || ve === null) me = !1;
                                        else if (ve === "true" || ve === 1) me = !0;
                                        else
                                          return (
                                            (Be.errors = [
                                              {
                                                instancePath: t + "/jsonShorthand",
                                                schemaPath: "#/properties/jsonShorthand/type",
                                                keyword: "type",
                                                params: { type: "boolean" },
                                                message: "must be boolean",
                                              },
                                            ]),
                                            !1
                                          );
                                      me !== void 0 &&
                                        ((ve = me), e !== void 0 && (e.jsonShorthand = me));
                                    }
                                    var a = Ae === o;
                                    if (a) {
                                      let me = e.maxParamLength,
                                        C = o;
                                      if (
                                        !(
                                          typeof me == "number" &&
                                          !(me % 1) &&
                                          !isNaN(me) &&
                                          isFinite(me)
                                        )
                                      ) {
                                        let K = typeof me,
                                          te;
                                        if (te === void 0)
                                          if (
                                            K === "boolean" ||
                                            me === null ||
                                            (K === "string" && me && me == +me && !(me % 1))
                                          )
                                            te = +me;
                                          else
                                            return (
                                              (Be.errors = [
                                                {
                                                  instancePath: t + "/maxParamLength",
                                                  schemaPath: "#/properties/maxParamLength/type",
                                                  keyword: "type",
                                                  params: { type: "integer" },
                                                  message: "must be integer",
                                                },
                                              ]),
                                              !1
                                            );
                                        te !== void 0 &&
                                          ((me = te), e !== void 0 && (e.maxParamLength = te));
                                      }
                                      var a = C === o;
                                      if (a) {
                                        let K = e.onProtoPoisoning,
                                          te = o;
                                        if (typeof K != "string") {
                                          let F = typeof K,
                                            Me;
                                          if (Me === void 0)
                                            if (F == "number" || F == "boolean") Me = "" + K;
                                            else if (K === null) Me = "";
                                            else
                                              return (
                                                (Be.errors = [
                                                  {
                                                    instancePath: t + "/onProtoPoisoning",
                                                    schemaPath:
                                                      "#/properties/onProtoPoisoning/type",
                                                    keyword: "type",
                                                    params: { type: "string" },
                                                    message: "must be string",
                                                  },
                                                ]),
                                                !1
                                              );
                                          Me !== void 0 &&
                                            ((K = Me), e !== void 0 && (e.onProtoPoisoning = Me));
                                        }
                                        var a = te === o;
                                        if (a) {
                                          let F = e.onConstructorPoisoning,
                                            Me = o;
                                          if (typeof F != "string") {
                                            let Je = typeof F,
                                              wt;
                                            if (wt === void 0)
                                              if (Je == "number" || Je == "boolean") wt = "" + F;
                                              else if (F === null) wt = "";
                                              else
                                                return (
                                                  (Be.errors = [
                                                    {
                                                      instancePath: t + "/onConstructorPoisoning",
                                                      schemaPath:
                                                        "#/properties/onConstructorPoisoning/type",
                                                      keyword: "type",
                                                      params: { type: "string" },
                                                      message: "must be string",
                                                    },
                                                  ]),
                                                  !1
                                                );
                                            wt !== void 0 &&
                                              ((F = wt),
                                              e !== void 0 && (e.onConstructorPoisoning = wt));
                                          }
                                          var a = Me === o;
                                          if (a) {
                                            let Je = e.pluginTimeout,
                                              wt = o;
                                            if (
                                              !(
                                                typeof Je == "number" &&
                                                !(Je % 1) &&
                                                !isNaN(Je) &&
                                                isFinite(Je)
                                              )
                                            ) {
                                              let jr = typeof Je,
                                                Hr;
                                              if (Hr === void 0)
                                                if (
                                                  jr === "boolean" ||
                                                  Je === null ||
                                                  (jr === "string" && Je && Je == +Je && !(Je % 1))
                                                )
                                                  Hr = +Je;
                                                else
                                                  return (
                                                    (Be.errors = [
                                                      {
                                                        instancePath: t + "/pluginTimeout",
                                                        schemaPath:
                                                          "#/properties/pluginTimeout/type",
                                                        keyword: "type",
                                                        params: { type: "integer" },
                                                        message: "must be integer",
                                                      },
                                                    ]),
                                                    !1
                                                  );
                                              Hr !== void 0 &&
                                                ((Je = Hr), e !== void 0 && (e.pluginTimeout = Hr));
                                            }
                                            var a = wt === o;
                                            if (a) {
                                              let jr = e.requestIdHeader,
                                                Hr = o,
                                                Pn = o,
                                                $n = !1,
                                                Lr = o;
                                              if (jr !== !1) {
                                                let Ft = {
                                                  instancePath: t + "/requestIdHeader",
                                                  schemaPath:
                                                    "#/properties/requestIdHeader/anyOf/0/enum",
                                                  keyword: "enum",
                                                  params: {
                                                    allowedValues:
                                                      PC.properties.requestIdHeader.anyOf[0].enum,
                                                  },
                                                  message:
                                                    "must be equal to one of the allowed values",
                                                };
                                                i === null ? (i = [Ft]) : i.push(Ft), o++;
                                              }
                                              var d = Lr === o;
                                              if ((($n = $n || d), !$n)) {
                                                let Ft = o;
                                                if (typeof jr != "string") {
                                                  let fn = typeof jr,
                                                    Ze;
                                                  if (Ze === void 0)
                                                    if (fn == "number" || fn == "boolean")
                                                      Ze = "" + jr;
                                                    else if (jr === null) Ze = "";
                                                    else {
                                                      let Bt = {
                                                        instancePath: t + "/requestIdHeader",
                                                        schemaPath:
                                                          "#/properties/requestIdHeader/anyOf/1/type",
                                                        keyword: "type",
                                                        params: { type: "string" },
                                                        message: "must be string",
                                                      };
                                                      i === null ? (i = [Bt]) : i.push(Bt), o++;
                                                    }
                                                  Ze !== void 0 &&
                                                    ((jr = Ze),
                                                    e !== void 0 && (e.requestIdHeader = Ze));
                                                }
                                                var d = Ft === o;
                                                $n = $n || d;
                                              }
                                              if ($n)
                                                (o = Pn),
                                                  i !== null && (Pn ? (i.length = Pn) : (i = null));
                                              else {
                                                let Ft = {
                                                  instancePath: t + "/requestIdHeader",
                                                  schemaPath: "#/properties/requestIdHeader/anyOf",
                                                  keyword: "anyOf",
                                                  params: {},
                                                  message: "must match a schema in anyOf",
                                                };
                                                return (
                                                  i === null ? (i = [Ft]) : i.push(Ft),
                                                  o++,
                                                  (Be.errors = i),
                                                  !1
                                                );
                                              }
                                              var a = Hr === o;
                                              if (a) {
                                                let Ft = e.requestIdLogLabel,
                                                  Hi = o;
                                                if (typeof Ft != "string") {
                                                  let Ze = typeof Ft,
                                                    Bt;
                                                  if (Bt === void 0)
                                                    if (Ze == "number" || Ze == "boolean")
                                                      Bt = "" + Ft;
                                                    else if (Ft === null) Bt = "";
                                                    else
                                                      return (
                                                        (Be.errors = [
                                                          {
                                                            instancePath: t + "/requestIdLogLabel",
                                                            schemaPath:
                                                              "#/properties/requestIdLogLabel/type",
                                                            keyword: "type",
                                                            params: { type: "string" },
                                                            message: "must be string",
                                                          },
                                                        ]),
                                                        !1
                                                      );
                                                  Bt !== void 0 &&
                                                    ((Ft = Bt),
                                                    e !== void 0 && (e.requestIdLogLabel = Bt));
                                                }
                                                var a = Hi === o;
                                                if (a) {
                                                  let Ze = e.http2SessionTimeout,
                                                    Bt = o;
                                                  if (
                                                    !(
                                                      typeof Ze == "number" &&
                                                      !(Ze % 1) &&
                                                      !isNaN(Ze) &&
                                                      isFinite(Ze)
                                                    )
                                                  ) {
                                                    let Zt = typeof Ze,
                                                      ht;
                                                    if (ht === void 0)
                                                      if (
                                                        Zt === "boolean" ||
                                                        Ze === null ||
                                                        (Zt === "string" &&
                                                          Ze &&
                                                          Ze == +Ze &&
                                                          !(Ze % 1))
                                                      )
                                                        ht = +Ze;
                                                      else
                                                        return (
                                                          (Be.errors = [
                                                            {
                                                              instancePath:
                                                                t + "/http2SessionTimeout",
                                                              schemaPath:
                                                                "#/properties/http2SessionTimeout/type",
                                                              keyword: "type",
                                                              params: { type: "integer" },
                                                              message: "must be integer",
                                                            },
                                                          ]),
                                                          !1
                                                        );
                                                    ht !== void 0 &&
                                                      ((Ze = ht),
                                                      e !== void 0 && (e.http2SessionTimeout = ht));
                                                  }
                                                  var a = Bt === o;
                                                  if (a) {
                                                    let Zt = e.exposeHeadRoutes,
                                                      ht = o;
                                                    if (typeof Zt != "boolean") {
                                                      let nt;
                                                      if (nt === void 0)
                                                        if (
                                                          Zt === "false" ||
                                                          Zt === 0 ||
                                                          Zt === null
                                                        )
                                                          nt = !1;
                                                        else if (Zt === "true" || Zt === 1) nt = !0;
                                                        else
                                                          return (
                                                            (Be.errors = [
                                                              {
                                                                instancePath:
                                                                  t + "/exposeHeadRoutes",
                                                                schemaPath:
                                                                  "#/properties/exposeHeadRoutes/type",
                                                                keyword: "type",
                                                                params: { type: "boolean" },
                                                                message: "must be boolean",
                                                              },
                                                            ]),
                                                            !1
                                                          );
                                                      nt !== void 0 &&
                                                        ((Zt = nt),
                                                        e !== void 0 && (e.exposeHeadRoutes = nt));
                                                    }
                                                    var a = ht === o;
                                                    if (a) {
                                                      let nt = e.useSemicolonDelimiter,
                                                        Es = o;
                                                      if (typeof nt != "boolean") {
                                                        let ut;
                                                        if (ut === void 0)
                                                          if (
                                                            nt === "false" ||
                                                            nt === 0 ||
                                                            nt === null
                                                          )
                                                            ut = !1;
                                                          else if (nt === "true" || nt === 1)
                                                            ut = !0;
                                                          else
                                                            return (
                                                              (Be.errors = [
                                                                {
                                                                  instancePath:
                                                                    t + "/useSemicolonDelimiter",
                                                                  schemaPath:
                                                                    "#/properties/useSemicolonDelimiter/type",
                                                                  keyword: "type",
                                                                  params: { type: "boolean" },
                                                                  message: "must be boolean",
                                                                },
                                                              ]),
                                                              !1
                                                            );
                                                        ut !== void 0 &&
                                                          ((nt = ut),
                                                          e !== void 0 &&
                                                            (e.useSemicolonDelimiter = ut));
                                                      }
                                                      var a = Es === o;
                                                      if (a) {
                                                        if (e.versioning !== void 0) {
                                                          let ut = e.versioning,
                                                            On = o;
                                                          if (o === On)
                                                            if (
                                                              ut &&
                                                              typeof ut == "object" &&
                                                              !Array.isArray(ut)
                                                            ) {
                                                              let xr;
                                                              if (
                                                                (ut.storage === void 0 &&
                                                                  (xr = "storage")) ||
                                                                (ut.deriveVersion === void 0 &&
                                                                  (xr = "deriveVersion"))
                                                              )
                                                                return (
                                                                  (Be.errors = [
                                                                    {
                                                                      instancePath:
                                                                        t + "/versioning",
                                                                      schemaPath:
                                                                        "#/properties/versioning/required",
                                                                      keyword: "required",
                                                                      params: {
                                                                        missingProperty: xr,
                                                                      },
                                                                      message:
                                                                        "must have required property '" +
                                                                        xr +
                                                                        "'",
                                                                    },
                                                                  ]),
                                                                  !1
                                                                );
                                                            } else
                                                              return (
                                                                (Be.errors = [
                                                                  {
                                                                    instancePath: t + "/versioning",
                                                                    schemaPath:
                                                                      "#/properties/versioning/type",
                                                                    keyword: "type",
                                                                    params: { type: "object" },
                                                                    message: "must be object",
                                                                  },
                                                                ]),
                                                                !1
                                                              );
                                                          var a = On === o;
                                                        } else var a = !0;
                                                        if (a)
                                                          if (e.constraints !== void 0) {
                                                            let ut = e.constraints,
                                                              On = o;
                                                            if (o === On)
                                                              if (
                                                                ut &&
                                                                typeof ut == "object" &&
                                                                !Array.isArray(ut)
                                                              )
                                                                for (let xr in ut) {
                                                                  let er = ut[xr],
                                                                    Bi = o;
                                                                  if (o === Bi)
                                                                    if (
                                                                      er &&
                                                                      typeof er == "object" &&
                                                                      !Array.isArray(er)
                                                                    ) {
                                                                      let Br;
                                                                      if (
                                                                        (er.name === void 0 &&
                                                                          (Br = "name")) ||
                                                                        (er.storage === void 0 &&
                                                                          (Br = "storage")) ||
                                                                        (er.validate === void 0 &&
                                                                          (Br = "validate")) ||
                                                                        (er.deriveConstraint ===
                                                                          void 0 &&
                                                                          (Br = "deriveConstraint"))
                                                                      )
                                                                        return (
                                                                          (Be.errors = [
                                                                            {
                                                                              instancePath:
                                                                                t +
                                                                                "/constraints/" +
                                                                                xr
                                                                                  .replace(
                                                                                    /~/g,
                                                                                    "~0",
                                                                                  )
                                                                                  .replace(
                                                                                    /\//g,
                                                                                    "~1",
                                                                                  ),
                                                                              schemaPath:
                                                                                "#/properties/constraints/additionalProperties/required",
                                                                              keyword: "required",
                                                                              params: {
                                                                                missingProperty: Br,
                                                                              },
                                                                              message:
                                                                                "must have required property '" +
                                                                                Br +
                                                                                "'",
                                                                            },
                                                                          ]),
                                                                          !1
                                                                        );
                                                                      if (er.name !== void 0) {
                                                                        let Nn = er.name;
                                                                        if (typeof Nn != "string") {
                                                                          let ai = typeof Nn,
                                                                            dn;
                                                                          if (dn === void 0)
                                                                            if (
                                                                              ai == "number" ||
                                                                              ai == "boolean"
                                                                            )
                                                                              dn = "" + Nn;
                                                                            else if (Nn === null)
                                                                              dn = "";
                                                                            else
                                                                              return (
                                                                                (Be.errors = [
                                                                                  {
                                                                                    instancePath:
                                                                                      t +
                                                                                      "/constraints/" +
                                                                                      xr
                                                                                        .replace(
                                                                                          /~/g,
                                                                                          "~0",
                                                                                        )
                                                                                        .replace(
                                                                                          /\//g,
                                                                                          "~1",
                                                                                        ) +
                                                                                      "/name",
                                                                                    schemaPath:
                                                                                      "#/properties/constraints/additionalProperties/properties/name/type",
                                                                                    keyword: "type",
                                                                                    params: {
                                                                                      type: "string",
                                                                                    },
                                                                                    message:
                                                                                      "must be string",
                                                                                  },
                                                                                ]),
                                                                                !1
                                                                              );
                                                                          dn !== void 0 &&
                                                                            ((Nn = dn),
                                                                            er !== void 0 &&
                                                                              (er.name = dn));
                                                                        }
                                                                      }
                                                                    } else
                                                                      return (
                                                                        (Be.errors = [
                                                                          {
                                                                            instancePath:
                                                                              t +
                                                                              "/constraints/" +
                                                                              xr
                                                                                .replace(/~/g, "~0")
                                                                                .replace(
                                                                                  /\//g,
                                                                                  "~1",
                                                                                ),
                                                                            schemaPath:
                                                                              "#/properties/constraints/additionalProperties/type",
                                                                            keyword: "type",
                                                                            params: {
                                                                              type: "object",
                                                                            },
                                                                            message:
                                                                              "must be object",
                                                                          },
                                                                        ]),
                                                                        !1
                                                                      );
                                                                  var h = Bi === o;
                                                                  if (!h) break;
                                                                }
                                                              else
                                                                return (
                                                                  (Be.errors = [
                                                                    {
                                                                      instancePath:
                                                                        t + "/constraints",
                                                                      schemaPath:
                                                                        "#/properties/constraints/type",
                                                                      keyword: "type",
                                                                      params: { type: "object" },
                                                                      message: "must be object",
                                                                    },
                                                                  ]),
                                                                  !1
                                                                );
                                                            var a = On === o;
                                                          } else var a = !0;
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      } else
        return (
          (Be.errors = [
            {
              instancePath: t,
              schemaPath: "#/type",
              keyword: "type",
              params: { type: "object" },
              message: "must be object",
            },
          ]),
          !1
        );
    return (Be.errors = i), o === 0;
  }
  ld.exports.defaultInitOptions = {
    connectionTimeout: 0,
    keepAliveTimeout: 72e3,
    maxRequestsPerSocket: 0,
    requestTimeout: 0,
    bodyLimit: 1048576,
    caseSensitive: !0,
    allowUnsafeRegex: !1,
    disableRequestLogging: !1,
    jsonShorthand: !0,
    ignoreTrailingSlash: !1,
    ignoreDuplicateSlashes: !1,
    maxParamLength: 100,
    onProtoPoisoning: "error",
    onConstructorPoisoning: "error",
    pluginTimeout: 1e4,
    requestIdHeader: "request-id",
    requestIdLogLabel: "reqId",
    http2SessionTimeout: 72e3,
    exposeHeadRoutes: !0,
    useSemicolonDelimiter: !0,
  };
});
var OC = b((sue, fd) => {
  "use strict";
  var cd = $C(),
    XX = dc()({ circles: !0, proto: !1 }),
    { FST_ERR_INIT_OPTS_INVALID: ZX } = tr();
  function eZ(e) {
    let t = XX(e);
    if (!cd(t)) {
      let r = new ZX(JSON.stringify(cd.errors.map((n) => n.message)));
      throw ((r.errors = cd.errors), r);
    }
    return X0(t);
  }
  function X0(e) {
    let t = Object.getOwnPropertyNames(e);
    for (let r of t) {
      let n = e[r];
      (ArrayBuffer.isView(n) && !(n instanceof DataView)) ||
        (e[r] = n && typeof n == "object" ? X0(n) : n);
    }
    return Object.freeze(e);
  }
  fd.exports = eZ;
  fd.exports.defaultInitOptions = cd.defaultInitOptions;
  fd.exports.utils = { deepFreezeObject: X0 };
});
var LC = b((iue, jC) => {
  "use strict";
  var {
      kAvvioBoot: tZ,
      kChildren: NC,
      kRoutePrefix: AC,
      kLogLevel: IC,
      kLogSerializers: Z0,
      kHooks: e_,
      kSchemaController: Go,
      kContentTypeParser: CC,
      kReply: kC,
      kRequest: DC,
      kFourOhFour: rZ,
      kPluginNameChain: qC,
    } = Vt(),
    nZ = wc(),
    sZ = Lc(),
    iZ = R0(),
    oZ = Om(),
    { buildHooks: aZ } = Os(),
    Cu = A0();
  jC.exports = function (t, r, n) {
    let s = Cu.registerPlugin.call(t, r),
      i = Cu.getPluginName(r) || Cu.getFuncPreview(r);
    if (s) return t[qC].push(i), t;
    let o = Object.create(t);
    t[NC].push(o),
      (o.ready = t[tZ].bind(o)),
      (o[NC] = []),
      (o[kC] = nZ.buildReply(o[kC])),
      (o[DC] = sZ.buildRequest(o[DC])),
      (o[CC] = oZ.helpers.buildContentTypeParser(o[CC])),
      (o[e_] = aZ(o[e_])),
      (o[AC] = uZ(o[AC], n.prefix)),
      (o[IC] = n.logLevel || o[IC]),
      (o[Go] = iZ.buildSchemaController(t[Go])),
      (o.getSchema = o[Go].getSchema.bind(o[Go])),
      (o.getSchemas = o[Go].getSchemas.bind(o[Go])),
      (o[Cu.kRegisteredPlugins] = Object.create(o[Cu.kRegisteredPlugins])),
      (o[qC] = [i]),
      (o[Z0] || n.logSerializers) &&
        (o[Z0] = Object.assign(Object.create(o[Z0]), n.logSerializers)),
      n.prefix && o[rZ].arrange404(o);
    for (let a of o[e_].onRegister) a.call(this, o, n);
    return o;
  };
  function uZ(e, t) {
    return t
      ? (e.endsWith("/") && t[0] === "/" ? (t = t.slice(1)) : t[0] !== "/" && (t = "/" + t), e + t)
      : e;
  }
});
var FC = b((oue, xC) => {
  "use strict";
  xC.exports = function () {
    return {
      [Symbol.iterator]: function* () {},
      add() {},
      delete() {},
      has() {
        return !0;
      },
    };
  };
});
var MC = b((t_) => {
  "use strict";
  t_.parse = cZ;
  t_.serialize = fZ;
  var lZ = Object.prototype.toString,
    dd = /^[\u0009\u0020-\u007e\u0080-\u00ff]+$/;
  function cZ(e, t) {
    if (typeof e != "string") throw new TypeError("argument str must be a string");
    for (var r = {}, n = t || {}, s = n.decode || dZ, i = 0; i < e.length; ) {
      var o = e.indexOf("=", i);
      if (o === -1) break;
      var a = e.indexOf(";", i);
      if (a === -1) a = e.length;
      else if (a < o) {
        i = e.lastIndexOf(";", o - 1) + 1;
        continue;
      }
      var u = e.slice(i, o).trim();
      if (r[u] === void 0) {
        var l = e.slice(o + 1, a).trim();
        l.charCodeAt(0) === 34 && (l = l.slice(1, -1)), (r[u] = mZ(l, s));
      }
      i = a + 1;
    }
    return r;
  }
  function fZ(e, t, r) {
    var n = r || {},
      s = n.encode || hZ;
    if (typeof s != "function") throw new TypeError("option encode is invalid");
    if (!dd.test(e)) throw new TypeError("argument name is invalid");
    var i = s(t);
    if (i && !dd.test(i)) throw new TypeError("argument val is invalid");
    var o = e + "=" + i;
    if (n.maxAge != null) {
      var a = n.maxAge - 0;
      if (isNaN(a) || !isFinite(a)) throw new TypeError("option maxAge is invalid");
      o += "; Max-Age=" + Math.floor(a);
    }
    if (n.domain) {
      if (!dd.test(n.domain)) throw new TypeError("option domain is invalid");
      o += "; Domain=" + n.domain;
    }
    if (n.path) {
      if (!dd.test(n.path)) throw new TypeError("option path is invalid");
      o += "; Path=" + n.path;
    }
    if (n.expires) {
      var u = n.expires;
      if (!pZ(u) || isNaN(u.valueOf())) throw new TypeError("option expires is invalid");
      o += "; Expires=" + u.toUTCString();
    }
    if (
      (n.httpOnly && (o += "; HttpOnly"),
      n.secure && (o += "; Secure"),
      n.partitioned && (o += "; Partitioned"),
      n.priority)
    ) {
      var l = typeof n.priority == "string" ? n.priority.toLowerCase() : n.priority;
      switch (l) {
        case "low":
          o += "; Priority=Low";
          break;
        case "medium":
          o += "; Priority=Medium";
          break;
        case "high":
          o += "; Priority=High";
          break;
        default:
          throw new TypeError("option priority is invalid");
      }
    }
    if (n.sameSite) {
      var c = typeof n.sameSite == "string" ? n.sameSite.toLowerCase() : n.sameSite;
      switch (c) {
        case !0:
          o += "; SameSite=Strict";
          break;
        case "lax":
          o += "; SameSite=Lax";
          break;
        case "strict":
          o += "; SameSite=Strict";
          break;
        case "none":
          o += "; SameSite=None";
          break;
        default:
          throw new TypeError("option sameSite is invalid");
      }
    }
    return o;
  }
  function dZ(e) {
    return e.indexOf("%") !== -1 ? decodeURIComponent(e) : e;
  }
  function hZ(e) {
    return encodeURIComponent(e);
  }
  function pZ(e) {
    return lZ.call(e) === "[object Date]" || e instanceof Date;
  }
  function mZ(e, t) {
    try {
      return t(e);
    } catch {
      return e;
    }
  }
});
var UC = b((uue, VC) => {
  "use strict";
  var { URL: zC } = require("node:url"),
    r_ = "http://localhost";
  VC.exports = function (t, r) {
    (typeof t == "string" || Object.prototype.toString.call(t) === "[object String]") &&
      t.startsWith("//") &&
      (t = r_ + t);
    let n = typeof t == "object" ? Object.assign(new zC(r_), t) : new zC(t, r_);
    if (typeof r == "string") {
      r = new URLSearchParams(r);
      for (let s of r.keys()) {
        n.searchParams.delete(s);
        for (let i of r.getAll(s)) n.searchParams.append(s, i);
      }
    } else {
      let s = Object.assign({}, t.query, r);
      for (let i in s) {
        let o = s[i];
        if (Array.isArray(o)) {
          n.searchParams.delete(i);
          for (let a of o) n.searchParams.append(i, a);
        } else n.searchParams.set(i, o);
      }
    }
    return n;
  };
});
var HC = b((lue, n_) => {
  "use strict";
  var { randomUUID: yZ } = require("node:crypto"),
    { Readable: gZ } = require("node:stream"),
    Jo;
  function _Z(e) {
    return (
      e &&
      typeof e == "object" &&
      typeof e.append == "function" &&
      typeof e.delete == "function" &&
      typeof e.get == "function" &&
      typeof e.getAll == "function" &&
      typeof e.has == "function" &&
      typeof e.set == "function" &&
      e[Symbol.toStringTag] === "FormData"
    );
  }
  function SZ(e) {
    Jo = Jo ?? new TextEncoder();
    let t = `----formdata-${yZ()}`,
      r = `--${t}\r
Content-Disposition: form-data`;
    let n = (u) => u.replace(/\n/g, "%0A").replace(/\r/g, "%0D").replace(/"/g, "%22"),
      s = (u) =>
        u.replace(
          /\r?\n|\r/g,
          `\r
`,
        ),
      i = new Uint8Array([13, 10]);
    async function* o() {
      for (let [u, l] of e)
        if (typeof l == "string")
          yield Jo.encode(`${r}; name="${n(s(u))}"\r
\r
`),
            yield Jo.encode(`${s(l)}\r
`);
        else {
          let c = `${r}; name="${n(s(u))}"`;
          l.name && (c += `; filename="${n(l.name)}"`),
            (c += `\r
Content-Type: ${l.type || "application/octet-stream"}\r
\r
`),
            yield Jo.encode(c),
            l.stream ? yield* l.stream() : yield l,
            yield i;
        }
      yield Jo.encode(`--${t}--`);
    }
    return { stream: gZ.from(o()), contentType: `multipart/form-data; boundary=${t}` };
  }
  n_.exports.isFormDataLike = _Z;
  n_.exports.formDataToStream = SZ;
});
var GC = b((cue, hd) => {
  "use strict";
  var { Readable: BC, addAbortSignal: vZ } = require("node:stream"),
    i_ = require("node:util"),
    bZ = MC(),
    wZ = require("node:assert"),
    { createDeprecation: EZ } = Th(),
    RZ = UC(),
    { isFormDataLike: TZ, formDataToStream: PZ } = HC(),
    { EventEmitter: $Z } = require("node:events"),
    OZ = EZ({
      name: "FastifyDeprecationLightMyRequest",
      code: "FST_LIGHTMYREQUEST_DEP01",
      message: 'You are accessing "request.connection", use "request.socket" instead.',
    });
  function NZ(e) {
    return e.port ? e.host : e.hostname + (e.protocol === "https:" ? ":443" : ":80");
  }
  var s_ = class extends $Z {
    constructor(t) {
      super(), (this.remoteAddress = t);
    }
  };
  function KC(e) {
    return new t(this);
    function t(r) {
      Bn.call(r, { ...e, Request: void 0 }), Object.assign(this, r);
      for (let n of Object.keys(Bn.prototype)) this.constructor.prototype[n] = Bn.prototype[n];
      return i_.inherits(this.constructor, e.Request), this;
    }
  }
  function Bn(e) {
    BC.call(this, { autoDestroy: !1 });
    let t = RZ(e.url || e.path, e.query);
    (this.url = t.pathname + t.search),
      (this.aborted = !1),
      (this.httpVersionMajor = 1),
      (this.httpVersionMinor = 1),
      (this.httpVersion = "1.1"),
      (this.method = e.method ? e.method.toUpperCase() : "GET"),
      (this.headers = {}),
      (this.rawHeaders = []);
    let r = e.headers || {};
    for (let o in r) {
      let a = o.toLowerCase();
      if ((a === "user-agent" || a === "content-type") && r[o] === void 0) {
        this.headers[a] = void 0;
        continue;
      }
      let u = r[o];
      wZ(u !== void 0, 'invalid value "undefined" for header ' + o), (this.headers[a] = "" + u);
    }
    if (
      ("user-agent" in this.headers || (this.headers["user-agent"] = "lightMyRequest"),
      (this.headers.host = this.headers.host || e.authority || NZ(t)),
      e.cookies)
    ) {
      let { cookies: o } = e,
        a = Object.keys(o).map((u) => bZ.serialize(u, o[u]));
      this.headers.cookie && a.unshift(this.headers.cookie), (this.headers.cookie = a.join("; "));
    }
    (this.socket = new s_(e.remoteAddress || "127.0.0.1")),
      Object.defineProperty(this, "connection", {
        get() {
          return OZ(), this.socket;
        },
        configurable: !0,
      });
    let n = e.payload || e.body || null,
      s = n && typeof n.resume == "function";
    if (TZ(n)) {
      let o = PZ(n);
      (n = o.stream), (s = !0), (this.headers["content-type"] = o.contentType);
    }
    n &&
      typeof n != "string" &&
      !s &&
      !Buffer.isBuffer(n) &&
      ((n = JSON.stringify(n)),
      "content-type" in this.headers || (this.headers["content-type"] = "application/json")),
      n &&
        !s &&
        !Object.prototype.hasOwnProperty.call(this.headers, "content-length") &&
        (this.headers["content-length"] = (
          Buffer.isBuffer(n) ? n.length : Buffer.byteLength(n)
        ).toString());
    for (let o of Object.keys(this.headers)) this.rawHeaders.push(o, this.headers[o]);
    this._lightMyRequest = { payload: n, isDone: !1, simulate: e.simulate || {} };
    let i = e.signal;
    return i && vZ(i, this), this;
  }
  i_.inherits(Bn, BC);
  i_.inherits(KC, Bn);
  Bn.prototype.prepare = function (e) {
    let t = this._lightMyRequest.payload;
    if (!t || typeof t.resume != "function") return e();
    let r = [];
    t.on("data", (n) => r.push(Buffer.from(n))),
      t.on("end", () => {
        let n = Buffer.concat(r);
        return (
          (this.headers["content-length"] = this.headers["content-length"] || "" + n.length),
          (this._lightMyRequest.payload = n),
          e()
        );
      }),
      t.resume();
  };
  Bn.prototype._read = function (e) {
    setImmediate(() => {
      if (this._lightMyRequest.isDone) {
        this._lightMyRequest.simulate.end !== !1 && this.push(null);
        return;
      }
      (this._lightMyRequest.isDone = !0),
        this._lightMyRequest.payload &&
          (this._lightMyRequest.simulate.split
            ? (this.push(this._lightMyRequest.payload.slice(0, 1)),
              this.push(this._lightMyRequest.payload.slice(1)))
            : this.push(this._lightMyRequest.payload)),
        this._lightMyRequest.simulate.error && this.emit("error", new Error("Simulated")),
        this._lightMyRequest.simulate.close && this.emit("close"),
        this._lightMyRequest.simulate.end !== !1 && this.push(null);
    });
  };
  Bn.prototype.destroy = function (e) {
    this.destroyed ||
      this._lightMyRequest.isDone ||
      ((this.destroyed = !0),
      e && ((this._error = !0), process.nextTick(() => this.emit("error", e))),
      process.nextTick(() => this.emit("close")));
  };
  hd.exports = Bn;
  hd.exports.Request = Bn;
  hd.exports.CustomRequest = KC;
});
var QC = b((fue, ku) => {
  "use strict";
  var Qo = { decodeValues: !0, map: !1, silent: !1 };
  function o_(e) {
    return typeof e == "string" && !!e.trim();
  }
  function a_(e, t) {
    var r = e.split(";").filter(o_),
      n = r.shift(),
      s = AZ(n),
      i = s.name,
      o = s.value;
    t = t ? Object.assign({}, Qo, t) : Qo;
    try {
      o = t.decodeValues ? decodeURIComponent(o) : o;
    } catch (u) {
      console.error(
        "set-cookie-parser encountered an error while decoding a cookie with value '" +
          o +
          "'. Set options.decodeValues to false to disable this feature.",
        u,
      );
    }
    var a = { name: i, value: o };
    return (
      r.forEach(function (u) {
        var l = u.split("="),
          c = l.shift().trimLeft().toLowerCase(),
          f = l.join("=");
        c === "expires"
          ? (a.expires = new Date(f))
          : c === "max-age"
            ? (a.maxAge = parseInt(f, 10))
            : c === "secure"
              ? (a.secure = !0)
              : c === "httponly"
                ? (a.httpOnly = !0)
                : c === "samesite"
                  ? (a.sameSite = f)
                  : (a[c] = f);
      }),
      a
    );
  }
  function AZ(e) {
    var t = "",
      r = "",
      n = e.split("=");
    return n.length > 1 ? ((t = n.shift()), (r = n.join("="))) : (r = e), { name: t, value: r };
  }
  function JC(e, t) {
    if (((t = t ? Object.assign({}, Qo, t) : Qo), !e)) return t.map ? {} : [];
    if (e.headers)
      if (typeof e.headers.getSetCookie == "function") e = e.headers.getSetCookie();
      else if (e.headers["set-cookie"]) e = e.headers["set-cookie"];
      else {
        var r =
          e.headers[
            Object.keys(e.headers).find(function (s) {
              return s.toLowerCase() === "set-cookie";
            })
          ];
        !r &&
          e.headers.cookie &&
          !t.silent &&
          console.warn(
            "Warning: set-cookie-parser appears to have been called on a request object. It is designed to parse Set-Cookie headers from responses, not Cookie headers from requests. Set the option {silent: true} to suppress this warning.",
          ),
          (e = r);
      }
    if ((Array.isArray(e) || (e = [e]), (t = t ? Object.assign({}, Qo, t) : Qo), t.map)) {
      var n = {};
      return e.filter(o_).reduce(function (s, i) {
        var o = a_(i, t);
        return (s[o.name] = o), s;
      }, n);
    } else
      return e.filter(o_).map(function (s) {
        return a_(s, t);
      });
  }
  function IZ(e) {
    if (Array.isArray(e)) return e;
    if (typeof e != "string") return [];
    var t = [],
      r = 0,
      n,
      s,
      i,
      o,
      a;
    function u() {
      for (; r < e.length && /\s/.test(e.charAt(r)); ) r += 1;
      return r < e.length;
    }
    function l() {
      return (s = e.charAt(r)), s !== "=" && s !== ";" && s !== ",";
    }
    for (; r < e.length; ) {
      for (n = r, a = !1; u(); )
        if (((s = e.charAt(r)), s === ",")) {
          for (i = r, r += 1, u(), o = r; r < e.length && l(); ) r += 1;
          r < e.length && e.charAt(r) === "="
            ? ((a = !0), (r = o), t.push(e.substring(n, i)), (n = r))
            : (r = i + 1);
        } else r += 1;
      (!a || r >= e.length) && t.push(e.substring(n, e.length));
    }
    return t;
  }
  ku.exports = JC;
  ku.exports.parse = JC;
  ku.exports.parseString = a_;
  ku.exports.splitCookiesString = IZ;
});
var XC = b((due, YC) => {
  "use strict";
  var Du = require("node:http"),
    { Writable: CZ, Readable: kZ } = require("node:stream"),
    DZ = require("node:util"),
    qZ = QC();
  function Ys(e, t, r) {
    Du.ServerResponse.call(this, e),
      (this._lightMyRequest = { headers: null, trailers: {}, payloadChunks: [] }),
      this.setHeader("foo", "bar"),
      this.removeHeader("foo"),
      this.assignSocket(LZ()),
      (this._promiseCallback = typeof r == "function");
    let n = !1,
      s = (o) => {
        if (((n = !0), this._promiseCallback)) return process.nextTick(() => t(o));
        process.nextTick(() => t(null, o));
      },
      i = (o) => {
        if (!n) {
          if (((n = !0), this._promiseCallback)) return process.nextTick(() => r(o));
          process.nextTick(() => t(o, null));
        }
      };
    this.once("finish", () => {
      let o = jZ(this);
      (o.raw.req = e), s(o);
    }),
      this.connection.once("error", i),
      this.once("error", i),
      this.once("close", i);
  }
  DZ.inherits(Ys, Du.ServerResponse);
  Ys.prototype.setTimeout = function (e, t) {
    return (
      (this.timeoutHandle = setTimeout(() => {
        this.emit("timeout");
      }, e)),
      this.on("timeout", t),
      this
    );
  };
  Ys.prototype.writeHead = function () {
    let e = Du.ServerResponse.prototype.writeHead.apply(this, arguments);
    return WC(this), e;
  };
  Ys.prototype.write = function (e, t, r) {
    return (
      this.timeoutHandle && clearTimeout(this.timeoutHandle),
      Du.ServerResponse.prototype.write.call(this, e, t, r),
      this._lightMyRequest.payloadChunks.push(Buffer.from(e, t)),
      !0
    );
  };
  Ys.prototype.end = function (e, t, r) {
    e && this.write(e, t),
      Du.ServerResponse.prototype.end.call(this, r),
      this.emit("finish"),
      this.destroy();
  };
  Ys.prototype.destroy = function (e) {
    this.destroyed ||
      ((this.destroyed = !0),
      e && process.nextTick(() => this.emit("error", e)),
      process.nextTick(() => this.emit("close")));
  };
  Ys.prototype.addTrailers = function (e) {
    for (let t in e) this._lightMyRequest.trailers[t.toLowerCase().trim()] = e[t].toString().trim();
  };
  function jZ(e) {
    e._lightMyRequest.headers === null && WC(e), xZ(e);
    let t = {
        raw: { res: e },
        headers: e._lightMyRequest.headers,
        statusCode: e.statusCode,
        statusMessage: e.statusMessage,
        trailers: {},
        get cookies() {
          return qZ.parse(this);
        },
      },
      r = Buffer.concat(e._lightMyRequest.payloadChunks);
    return (
      (t.rawPayload = r),
      (t.payload = r.toString()),
      (t.body = t.payload),
      (t.trailers = e._lightMyRequest.trailers),
      (t.json = function () {
        return JSON.parse(t.payload);
      }),
      (t.stream = function () {
        return kZ.from(e._lightMyRequest.payloadChunks);
      }),
      t
    );
  }
  function LZ() {
    return new CZ({
      write(e, t, r) {
        setImmediate(r);
      },
    });
  }
  function xZ(e) {
    let t = e._lightMyRequest.headers;
    for (let r of Object.keys(t)) {
      let n = t[r];
      Array.isArray(n) ? (t[r] = n.map((s) => "" + s)) : (t[r] = "" + n);
    }
  }
  function WC(e) {
    (e._lightMyRequest.headers = Object.assign({}, e.getHeaders())),
      ["Date", "Connection", "Transfer-Encoding"].forEach((t) => {
        let r = new RegExp("\\r\\n" + t + ": ([^\\r]*)\\r\\n"),
          n = e._header.match(r);
        n && (e._lightMyRequest.headers[t.toLowerCase()] = n[1]);
      });
  }
  YC.exports = Ys;
});
var ZC = b((hue, u_) => {
  "use strict";
  u_.exports = jt;
  u_.exports.default = jt;
  var FZ = {
    type: "object",
    properties: {
      url: {
        oneOf: [
          { type: "string" },
          {
            type: "object",
            properties: {
              protocol: { type: "string" },
              hostname: { type: "string" },
              pathname: { type: "string" },
            },
            additionalProperties: !0,
            required: ["pathname"],
          },
        ],
      },
      path: {
        oneOf: [
          { type: "string" },
          {
            type: "object",
            properties: {
              protocol: { type: "string" },
              hostname: { type: "string" },
              pathname: { type: "string" },
            },
            additionalProperties: !0,
            required: ["pathname"],
          },
        ],
      },
      cookies: { type: "object", additionalProperties: !0 },
      headers: { type: "object", additionalProperties: !0 },
      query: { anyOf: [{ type: "object", additionalProperties: !0 }, { type: "string" }] },
      simulate: {
        type: "object",
        properties: {
          end: { type: "boolean" },
          split: { type: "boolean" },
          error: { type: "boolean" },
          close: { type: "boolean" },
        },
      },
      authority: { type: "string" },
      remoteAddress: { type: "string" },
      method: {
        type: "string",
        enum: [
          "ACL",
          "BIND",
          "CHECKOUT",
          "CONNECT",
          "COPY",
          "DELETE",
          "GET",
          "HEAD",
          "LINK",
          "LOCK",
          "M-SEARCH",
          "MERGE",
          "MKACTIVITY",
          "MKCALENDAR",
          "MKCOL",
          "MOVE",
          "NOTIFY",
          "OPTIONS",
          "PATCH",
          "POST",
          "PROPFIND",
          "PROPPATCH",
          "PURGE",
          "PUT",
          "REBIND",
          "REPORT",
          "SEARCH",
          "SOURCE",
          "SUBSCRIBE",
          "TRACE",
          "UNBIND",
          "UNLINK",
          "UNLOCK",
          "UNSUBSCRIBE",
          "acl",
          "bind",
          "checkout",
          "connect",
          "copy",
          "delete",
          "get",
          "head",
          "link",
          "lock",
          "m-search",
          "merge",
          "mkactivity",
          "mkcalendar",
          "mkcol",
          "move",
          "notify",
          "options",
          "patch",
          "post",
          "propfind",
          "proppatch",
          "purge",
          "put",
          "rebind",
          "report",
          "search",
          "source",
          "subscribe",
          "trace",
          "unbind",
          "unlink",
          "unlock",
          "unsubscribe",
        ],
      },
      validate: { type: "boolean" },
    },
    additionalProperties: !0,
    oneOf: [{ required: ["url"] }, { required: ["path"] }],
  };
  function jt(
    e,
    { instancePath: t = "", parentData: r, parentDataProperty: n, rootData: s = e } = {},
  ) {
    let i = null,
      o = 0,
      a = o,
      u = !1,
      l = null,
      c = o;
    if (e && typeof e == "object" && !Array.isArray(e)) {
      let m;
      if (e.url === void 0 && (m = "url")) {
        let T = {
          instancePath: t,
          schemaPath: "#/oneOf/0/required",
          keyword: "required",
          params: { missingProperty: m },
          message: "must have required property '" + m + "'",
        };
        i === null ? (i = [T]) : i.push(T), o++;
      }
    }
    var d = c === o;
    d && ((u = !0), (l = 0));
    let f = o;
    if (e && typeof e == "object" && !Array.isArray(e)) {
      let m;
      if (e.path === void 0 && (m = "path")) {
        let T = {
          instancePath: t,
          schemaPath: "#/oneOf/1/required",
          keyword: "required",
          params: { missingProperty: m },
          message: "must have required property '" + m + "'",
        };
        i === null ? (i = [T]) : i.push(T), o++;
      }
    }
    var d = f === o;
    if ((d && u ? ((u = !1), (l = [l, 1])) : d && ((u = !0), (l = 1)), u))
      (o = a), i !== null && (a ? (i.length = a) : (i = null));
    else {
      let m = {
        instancePath: t,
        schemaPath: "#/oneOf",
        keyword: "oneOf",
        params: { passingSchemas: l },
        message: "must match exactly one schema in oneOf",
      };
      return i === null ? (i = [m]) : i.push(m), o++, (jt.errors = i), !1;
    }
    if (o === 0)
      if (e && typeof e == "object" && !Array.isArray(e)) {
        if (e.url !== void 0) {
          let m = e.url,
            T = o,
            N = o,
            w = !1,
            $ = null,
            D = o;
          if (typeof m != "string") {
            let M = typeof m,
              k;
            if (k === void 0)
              if (M == "number" || M == "boolean") k = "" + m;
              else if (m === null) k = "";
              else {
                let x = {
                  instancePath: t + "/url",
                  schemaPath: "#/properties/url/oneOf/0/type",
                  keyword: "type",
                  params: { type: "string" },
                  message: "must be string",
                };
                i === null ? (i = [x]) : i.push(x), o++;
              }
            k !== void 0 && ((m = k), e !== void 0 && (e.url = k));
          }
          var p = D === o;
          p && ((w = !0), ($ = 0));
          let v = o;
          if (o === v)
            if (m && typeof m == "object" && !Array.isArray(m)) {
              let M;
              if (m.pathname === void 0 && (M = "pathname")) {
                let k = {
                  instancePath: t + "/url",
                  schemaPath: "#/properties/url/oneOf/1/required",
                  keyword: "required",
                  params: { missingProperty: M },
                  message: "must have required property '" + M + "'",
                };
                i === null ? (i = [k]) : i.push(k), o++;
              } else {
                if (m.protocol !== void 0) {
                  let k = m.protocol,
                    x = o;
                  if (typeof k != "string") {
                    let ie = typeof k,
                      Z;
                    if (Z === void 0)
                      if (ie == "number" || ie == "boolean") Z = "" + k;
                      else if (k === null) Z = "";
                      else {
                        let G = {
                          instancePath: t + "/url/protocol",
                          schemaPath: "#/properties/url/oneOf/1/properties/protocol/type",
                          keyword: "type",
                          params: { type: "string" },
                          message: "must be string",
                        };
                        i === null ? (i = [G]) : i.push(G), o++;
                      }
                    Z !== void 0 && ((k = Z), m !== void 0 && (m.protocol = Z));
                  }
                  var h = x === o;
                } else var h = !0;
                if (h) {
                  if (m.hostname !== void 0) {
                    let k = m.hostname,
                      x = o;
                    if (typeof k != "string") {
                      let Z = typeof k,
                        G;
                      if (G === void 0)
                        if (Z == "number" || Z == "boolean") G = "" + k;
                        else if (k === null) G = "";
                        else {
                          let Y = {
                            instancePath: t + "/url/hostname",
                            schemaPath: "#/properties/url/oneOf/1/properties/hostname/type",
                            keyword: "type",
                            params: { type: "string" },
                            message: "must be string",
                          };
                          i === null ? (i = [Y]) : i.push(Y), o++;
                        }
                      G !== void 0 && ((k = G), m !== void 0 && (m.hostname = G));
                    }
                    var h = x === o;
                  } else var h = !0;
                  if (h)
                    if (m.pathname !== void 0) {
                      let k = m.pathname,
                        x = o;
                      if (typeof k != "string") {
                        let Z = typeof k,
                          G;
                        if (G === void 0)
                          if (Z == "number" || Z == "boolean") G = "" + k;
                          else if (k === null) G = "";
                          else {
                            let Y = {
                              instancePath: t + "/url/pathname",
                              schemaPath: "#/properties/url/oneOf/1/properties/pathname/type",
                              keyword: "type",
                              params: { type: "string" },
                              message: "must be string",
                            };
                            i === null ? (i = [Y]) : i.push(Y), o++;
                          }
                        G !== void 0 && ((k = G), m !== void 0 && (m.pathname = G));
                      }
                      var h = x === o;
                    } else var h = !0;
                }
              }
            } else {
              let M = {
                instancePath: t + "/url",
                schemaPath: "#/properties/url/oneOf/1/type",
                keyword: "type",
                params: { type: "object" },
                message: "must be object",
              };
              i === null ? (i = [M]) : i.push(M), o++;
            }
          var p = v === o;
          if ((p && w ? ((w = !1), ($ = [$, 1])) : p && ((w = !0), ($ = 1)), w))
            (o = N), i !== null && (N ? (i.length = N) : (i = null));
          else {
            let M = {
              instancePath: t + "/url",
              schemaPath: "#/properties/url/oneOf",
              keyword: "oneOf",
              params: { passingSchemas: $ },
              message: "must match exactly one schema in oneOf",
            };
            return i === null ? (i = [M]) : i.push(M), o++, (jt.errors = i), !1;
          }
          var y = T === o;
        } else var y = !0;
        if (y) {
          if (e.path !== void 0) {
            let m = e.path,
              T = o,
              N = o,
              w = !1,
              $ = null,
              D = o;
            if (typeof m != "string") {
              let k = typeof m,
                x;
              if (x === void 0)
                if (k == "number" || k == "boolean") x = "" + m;
                else if (m === null) x = "";
                else {
                  let ie = {
                    instancePath: t + "/path",
                    schemaPath: "#/properties/path/oneOf/0/type",
                    keyword: "type",
                    params: { type: "string" },
                    message: "must be string",
                  };
                  i === null ? (i = [ie]) : i.push(ie), o++;
                }
              x !== void 0 && ((m = x), e !== void 0 && (e.path = x));
            }
            var S = D === o;
            S && ((w = !0), ($ = 0));
            let v = o;
            if (o === v)
              if (m && typeof m == "object" && !Array.isArray(m)) {
                let k;
                if (m.pathname === void 0 && (k = "pathname")) {
                  let x = {
                    instancePath: t + "/path",
                    schemaPath: "#/properties/path/oneOf/1/required",
                    keyword: "required",
                    params: { missingProperty: k },
                    message: "must have required property '" + k + "'",
                  };
                  i === null ? (i = [x]) : i.push(x), o++;
                } else {
                  if (m.protocol !== void 0) {
                    let x = m.protocol,
                      ie = o;
                    if (typeof x != "string") {
                      let Z = typeof x,
                        G;
                      if (G === void 0)
                        if (Z == "number" || Z == "boolean") G = "" + x;
                        else if (x === null) G = "";
                        else {
                          let Y = {
                            instancePath: t + "/path/protocol",
                            schemaPath: "#/properties/path/oneOf/1/properties/protocol/type",
                            keyword: "type",
                            params: { type: "string" },
                            message: "must be string",
                          };
                          i === null ? (i = [Y]) : i.push(Y), o++;
                        }
                      G !== void 0 && ((x = G), m !== void 0 && (m.protocol = G));
                    }
                    var _ = ie === o;
                  } else var _ = !0;
                  if (_) {
                    if (m.hostname !== void 0) {
                      let x = m.hostname,
                        ie = o;
                      if (typeof x != "string") {
                        let G = typeof x,
                          Y;
                        if (Y === void 0)
                          if (G == "number" || G == "boolean") Y = "" + x;
                          else if (x === null) Y = "";
                          else {
                            let U = {
                              instancePath: t + "/path/hostname",
                              schemaPath: "#/properties/path/oneOf/1/properties/hostname/type",
                              keyword: "type",
                              params: { type: "string" },
                              message: "must be string",
                            };
                            i === null ? (i = [U]) : i.push(U), o++;
                          }
                        Y !== void 0 && ((x = Y), m !== void 0 && (m.hostname = Y));
                      }
                      var _ = ie === o;
                    } else var _ = !0;
                    if (_)
                      if (m.pathname !== void 0) {
                        let x = m.pathname,
                          ie = o;
                        if (typeof x != "string") {
                          let G = typeof x,
                            Y;
                          if (Y === void 0)
                            if (G == "number" || G == "boolean") Y = "" + x;
                            else if (x === null) Y = "";
                            else {
                              let U = {
                                instancePath: t + "/path/pathname",
                                schemaPath: "#/properties/path/oneOf/1/properties/pathname/type",
                                keyword: "type",
                                params: { type: "string" },
                                message: "must be string",
                              };
                              i === null ? (i = [U]) : i.push(U), o++;
                            }
                          Y !== void 0 && ((x = Y), m !== void 0 && (m.pathname = Y));
                        }
                        var _ = ie === o;
                      } else var _ = !0;
                  }
                }
              } else {
                let k = {
                  instancePath: t + "/path",
                  schemaPath: "#/properties/path/oneOf/1/type",
                  keyword: "type",
                  params: { type: "object" },
                  message: "must be object",
                };
                i === null ? (i = [k]) : i.push(k), o++;
              }
            var S = v === o;
            if ((S && w ? ((w = !1), ($ = [$, 1])) : S && ((w = !0), ($ = 1)), w))
              (o = N), i !== null && (N ? (i.length = N) : (i = null));
            else {
              let k = {
                instancePath: t + "/path",
                schemaPath: "#/properties/path/oneOf",
                keyword: "oneOf",
                params: { passingSchemas: $ },
                message: "must match exactly one schema in oneOf",
              };
              return i === null ? (i = [k]) : i.push(k), o++, (jt.errors = i), !1;
            }
            var y = T === o;
          } else var y = !0;
          if (y) {
            if (e.cookies !== void 0) {
              let m = e.cookies,
                T = o;
              if (o === T && !(m && typeof m == "object" && !Array.isArray(m)))
                return (
                  (jt.errors = [
                    {
                      instancePath: t + "/cookies",
                      schemaPath: "#/properties/cookies/type",
                      keyword: "type",
                      params: { type: "object" },
                      message: "must be object",
                    },
                  ]),
                  !1
                );
              var y = T === o;
            } else var y = !0;
            if (y) {
              if (e.headers !== void 0) {
                let m = e.headers,
                  T = o;
                if (o === T && !(m && typeof m == "object" && !Array.isArray(m)))
                  return (
                    (jt.errors = [
                      {
                        instancePath: t + "/headers",
                        schemaPath: "#/properties/headers/type",
                        keyword: "type",
                        params: { type: "object" },
                        message: "must be object",
                      },
                    ]),
                    !1
                  );
                var y = T === o;
              } else var y = !0;
              if (y) {
                if (e.query !== void 0) {
                  let m = e.query,
                    T = o,
                    N = o,
                    w = !1,
                    $ = o;
                  if (o === $ && !(m && typeof m == "object" && !Array.isArray(m))) {
                    let v = {
                      instancePath: t + "/query",
                      schemaPath: "#/properties/query/anyOf/0/type",
                      keyword: "type",
                      params: { type: "object" },
                      message: "must be object",
                    };
                    i === null ? (i = [v]) : i.push(v), o++;
                  }
                  var E = $ === o;
                  if (((w = w || E), !w)) {
                    let v = o;
                    if (typeof m != "string") {
                      let k = typeof m,
                        x;
                      if (x === void 0)
                        if (k == "number" || k == "boolean") x = "" + m;
                        else if (m === null) x = "";
                        else {
                          let ie = {
                            instancePath: t + "/query",
                            schemaPath: "#/properties/query/anyOf/1/type",
                            keyword: "type",
                            params: { type: "string" },
                            message: "must be string",
                          };
                          i === null ? (i = [ie]) : i.push(ie), o++;
                        }
                      x !== void 0 && ((m = x), e !== void 0 && (e.query = x));
                    }
                    var E = v === o;
                    w = w || E;
                  }
                  if (w) (o = N), i !== null && (N ? (i.length = N) : (i = null));
                  else {
                    let v = {
                      instancePath: t + "/query",
                      schemaPath: "#/properties/query/anyOf",
                      keyword: "anyOf",
                      params: {},
                      message: "must match a schema in anyOf",
                    };
                    return i === null ? (i = [v]) : i.push(v), o++, (jt.errors = i), !1;
                  }
                  var y = T === o;
                } else var y = !0;
                if (y) {
                  if (e.simulate !== void 0) {
                    let m = e.simulate,
                      T = o;
                    if (o === T)
                      if (m && typeof m == "object" && !Array.isArray(m)) {
                        if (m.end !== void 0) {
                          let w = m.end,
                            $ = o;
                          if (typeof w != "boolean") {
                            let D;
                            if (D === void 0)
                              if (w === "false" || w === 0 || w === null) D = !1;
                              else if (w === "true" || w === 1) D = !0;
                              else
                                return (
                                  (jt.errors = [
                                    {
                                      instancePath: t + "/simulate/end",
                                      schemaPath: "#/properties/simulate/properties/end/type",
                                      keyword: "type",
                                      params: { type: "boolean" },
                                      message: "must be boolean",
                                    },
                                  ]),
                                  !1
                                );
                            D !== void 0 && ((w = D), m !== void 0 && (m.end = D));
                          }
                          var g = $ === o;
                        } else var g = !0;
                        if (g) {
                          if (m.split !== void 0) {
                            let w = m.split,
                              $ = o;
                            if (typeof w != "boolean") {
                              let v;
                              if (v === void 0)
                                if (w === "false" || w === 0 || w === null) v = !1;
                                else if (w === "true" || w === 1) v = !0;
                                else
                                  return (
                                    (jt.errors = [
                                      {
                                        instancePath: t + "/simulate/split",
                                        schemaPath: "#/properties/simulate/properties/split/type",
                                        keyword: "type",
                                        params: { type: "boolean" },
                                        message: "must be boolean",
                                      },
                                    ]),
                                    !1
                                  );
                              v !== void 0 && ((w = v), m !== void 0 && (m.split = v));
                            }
                            var g = $ === o;
                          } else var g = !0;
                          if (g) {
                            if (m.error !== void 0) {
                              let w = m.error,
                                $ = o;
                              if (typeof w != "boolean") {
                                let v;
                                if (v === void 0)
                                  if (w === "false" || w === 0 || w === null) v = !1;
                                  else if (w === "true" || w === 1) v = !0;
                                  else
                                    return (
                                      (jt.errors = [
                                        {
                                          instancePath: t + "/simulate/error",
                                          schemaPath: "#/properties/simulate/properties/error/type",
                                          keyword: "type",
                                          params: { type: "boolean" },
                                          message: "must be boolean",
                                        },
                                      ]),
                                      !1
                                    );
                                v !== void 0 && ((w = v), m !== void 0 && (m.error = v));
                              }
                              var g = $ === o;
                            } else var g = !0;
                            if (g)
                              if (m.close !== void 0) {
                                let w = m.close,
                                  $ = o;
                                if (typeof w != "boolean") {
                                  let v;
                                  if (v === void 0)
                                    if (w === "false" || w === 0 || w === null) v = !1;
                                    else if (w === "true" || w === 1) v = !0;
                                    else
                                      return (
                                        (jt.errors = [
                                          {
                                            instancePath: t + "/simulate/close",
                                            schemaPath:
                                              "#/properties/simulate/properties/close/type",
                                            keyword: "type",
                                            params: { type: "boolean" },
                                            message: "must be boolean",
                                          },
                                        ]),
                                        !1
                                      );
                                  v !== void 0 && ((w = v), m !== void 0 && (m.close = v));
                                }
                                var g = $ === o;
                              } else var g = !0;
                          }
                        }
                      } else
                        return (
                          (jt.errors = [
                            {
                              instancePath: t + "/simulate",
                              schemaPath: "#/properties/simulate/type",
                              keyword: "type",
                              params: { type: "object" },
                              message: "must be object",
                            },
                          ]),
                          !1
                        );
                    var y = T === o;
                  } else var y = !0;
                  if (y) {
                    if (e.authority !== void 0) {
                      let m = e.authority,
                        T = o;
                      if (typeof m != "string") {
                        let w = typeof m,
                          $;
                        if ($ === void 0)
                          if (w == "number" || w == "boolean") $ = "" + m;
                          else if (m === null) $ = "";
                          else
                            return (
                              (jt.errors = [
                                {
                                  instancePath: t + "/authority",
                                  schemaPath: "#/properties/authority/type",
                                  keyword: "type",
                                  params: { type: "string" },
                                  message: "must be string",
                                },
                              ]),
                              !1
                            );
                        $ !== void 0 && ((m = $), e !== void 0 && (e.authority = $));
                      }
                      var y = T === o;
                    } else var y = !0;
                    if (y) {
                      if (e.remoteAddress !== void 0) {
                        let m = e.remoteAddress,
                          T = o;
                        if (typeof m != "string") {
                          let w = typeof m,
                            $;
                          if ($ === void 0)
                            if (w == "number" || w == "boolean") $ = "" + m;
                            else if (m === null) $ = "";
                            else
                              return (
                                (jt.errors = [
                                  {
                                    instancePath: t + "/remoteAddress",
                                    schemaPath: "#/properties/remoteAddress/type",
                                    keyword: "type",
                                    params: { type: "string" },
                                    message: "must be string",
                                  },
                                ]),
                                !1
                              );
                          $ !== void 0 && ((m = $), e !== void 0 && (e.remoteAddress = $));
                        }
                        var y = T === o;
                      } else var y = !0;
                      if (y) {
                        if (e.method !== void 0) {
                          let m = e.method,
                            T = o;
                          if (typeof m != "string") {
                            let w = typeof m,
                              $;
                            if ($ === void 0)
                              if (w == "number" || w == "boolean") $ = "" + m;
                              else if (m === null) $ = "";
                              else
                                return (
                                  (jt.errors = [
                                    {
                                      instancePath: t + "/method",
                                      schemaPath: "#/properties/method/type",
                                      keyword: "type",
                                      params: { type: "string" },
                                      message: "must be string",
                                    },
                                  ]),
                                  !1
                                );
                            $ !== void 0 && ((m = $), e !== void 0 && (e.method = $));
                          }
                          if (
                            !(
                              m === "ACL" ||
                              m === "BIND" ||
                              m === "CHECKOUT" ||
                              m === "CONNECT" ||
                              m === "COPY" ||
                              m === "DELETE" ||
                              m === "GET" ||
                              m === "HEAD" ||
                              m === "LINK" ||
                              m === "LOCK" ||
                              m === "M-SEARCH" ||
                              m === "MERGE" ||
                              m === "MKACTIVITY" ||
                              m === "MKCALENDAR" ||
                              m === "MKCOL" ||
                              m === "MOVE" ||
                              m === "NOTIFY" ||
                              m === "OPTIONS" ||
                              m === "PATCH" ||
                              m === "POST" ||
                              m === "PROPFIND" ||
                              m === "PROPPATCH" ||
                              m === "PURGE" ||
                              m === "PUT" ||
                              m === "REBIND" ||
                              m === "REPORT" ||
                              m === "SEARCH" ||
                              m === "SOURCE" ||
                              m === "SUBSCRIBE" ||
                              m === "TRACE" ||
                              m === "UNBIND" ||
                              m === "UNLINK" ||
                              m === "UNLOCK" ||
                              m === "UNSUBSCRIBE" ||
                              m === "acl" ||
                              m === "bind" ||
                              m === "checkout" ||
                              m === "connect" ||
                              m === "copy" ||
                              m === "delete" ||
                              m === "get" ||
                              m === "head" ||
                              m === "link" ||
                              m === "lock" ||
                              m === "m-search" ||
                              m === "merge" ||
                              m === "mkactivity" ||
                              m === "mkcalendar" ||
                              m === "mkcol" ||
                              m === "move" ||
                              m === "notify" ||
                              m === "options" ||
                              m === "patch" ||
                              m === "post" ||
                              m === "propfind" ||
                              m === "proppatch" ||
                              m === "purge" ||
                              m === "put" ||
                              m === "rebind" ||
                              m === "report" ||
                              m === "search" ||
                              m === "source" ||
                              m === "subscribe" ||
                              m === "trace" ||
                              m === "unbind" ||
                              m === "unlink" ||
                              m === "unlock" ||
                              m === "unsubscribe"
                            )
                          )
                            return (
                              (jt.errors = [
                                {
                                  instancePath: t + "/method",
                                  schemaPath: "#/properties/method/enum",
                                  keyword: "enum",
                                  params: { allowedValues: FZ.properties.method.enum },
                                  message: "must be equal to one of the allowed values",
                                },
                              ]),
                              !1
                            );
                          var y = T === o;
                        } else var y = !0;
                        if (y)
                          if (e.validate !== void 0) {
                            let m = e.validate,
                              T = o;
                            if (typeof m != "boolean") {
                              let w;
                              if (w === void 0)
                                if (m === "false" || m === 0 || m === null) w = !1;
                                else if (m === "true" || m === 1) w = !0;
                                else
                                  return (
                                    (jt.errors = [
                                      {
                                        instancePath: t + "/validate",
                                        schemaPath: "#/properties/validate/type",
                                        keyword: "type",
                                        params: { type: "boolean" },
                                        message: "must be boolean",
                                      },
                                    ]),
                                    !1
                                  );
                              w !== void 0 && ((m = w), e !== void 0 && (e.validate = w));
                            }
                            var y = T === o;
                          } else var y = !0;
                      }
                    }
                  }
                }
              }
            }
          }
        }
      } else
        return (
          (jt.errors = [
            {
              instancePath: t,
              schemaPath: "#/type",
              keyword: "type",
              params: { type: "object" },
              message: "must be object",
            },
          ]),
          !1
        );
    return (jt.errors = i), o === 0;
  }
});
var rk = b((pue, ju) => {
  "use strict";
  var MZ = require("node:assert"),
    l_ = GC(),
    pd = XC(),
    yd = "The dispatch function has already been invoked",
    ek = ZC();
  function c_(e, t, r) {
    return r === void 0 ? new qu(e, t) : md(e, t, r);
  }
  function tk(e, t, r, n) {
    return (
      r.once("error", function (s) {
        this.destroyed && n.destroy(s);
      }),
      r.once("close", function () {
        this.destroyed && !this._error && n.destroy();
      }),
      r.prepare(() => e.call(t, r, n))
    );
  }
  function md(e, t, r) {
    if (
      ((t = typeof t == "string" ? { url: t } : t),
      t.validate !== !1 &&
        (MZ(typeof e == "function", "dispatchFunc should be a function"), !ek(t)))
    )
      throw new Error(ek.errors.map((o) => o.message));
    let n = t.server || {},
      s = t.Request ? l_.CustomRequest : l_;
    if (
      (e.request &&
        e.request.app === e &&
        (Object.setPrototypeOf(Object.getPrototypeOf(e.request), s.prototype),
        Object.setPrototypeOf(Object.getPrototypeOf(e.response), pd.prototype)),
      typeof r == "function")
    ) {
      let i = new s(t),
        o = new pd(i, r);
      return tk(e, n, i, o);
    } else
      return new Promise((i, o) => {
        let a = new s(t),
          u = new pd(a, i, o);
        tk(e, n, a, u);
      });
  }
  function qu(e, t) {
    typeof t == "string" ? (this.option = { url: t }) : (this.option = Object.assign({}, t)),
      (this.dispatch = e),
      (this._hasInvoked = !1),
      (this._promise = null),
      this.option.autoStart !== !1 &&
        process.nextTick(() => {
          this._hasInvoked || this.end();
        });
  }
  var zZ = ["delete", "get", "head", "options", "patch", "post", "put", "trace"];
  zZ.forEach((e) => {
    qu.prototype[e] = function (t) {
      if (this._hasInvoked === !0 || this._promise) throw new Error(yd);
      return (this.option.url = t), (this.option.method = e.toUpperCase()), this;
    };
  });
  var VZ = ["body", "cookies", "headers", "payload", "query"];
  VZ.forEach((e) => {
    qu.prototype[e] = function (t) {
      if (this._hasInvoked === !0 || this._promise) throw new Error(yd);
      return (this.option[e] = t), this;
    };
  });
  qu.prototype.end = function (e) {
    if (this._hasInvoked === !0 || this._promise) throw new Error(yd);
    if (((this._hasInvoked = !0), typeof e == "function")) md(this.dispatch, this.option, e);
    else return (this._promise = md(this.dispatch, this.option)), this._promise;
  };
  Object.getOwnPropertyNames(Promise.prototype).forEach((e) => {
    e !== "constructor" &&
      (qu.prototype[e] = function (...t) {
        if (!this._promise) {
          if (this._hasInvoked === !0) throw new Error(yd);
          (this._hasInvoked = !0), (this._promise = md(this.dispatch, this.option));
        }
        return this._promise[e](...t);
      });
  });
  function UZ(e) {
    return (
      e instanceof l_ ||
      e instanceof pd ||
      (e && e.constructor && e.constructor.name === "_CustomLMRRequest")
    );
  }
  ju.exports = c_;
  ju.exports.default = c_;
  ju.exports.inject = c_;
  ju.exports.isInjection = UZ;
});
var gk = b((mue, zu) => {
  "use strict";
  var HZ = "4.28.0",
    BZ = Mv(),
    f_ = require("node:http"),
    Lu,
    {
      kAvvioBoot: xu,
      kChildren: d_,
      kServerBindings: nk,
      kBodyLimit: KZ,
      kRoutePrefix: sk,
      kLogLevel: GZ,
      kLogSerializers: JZ,
      kHooks: h_,
      kSchemaController: Xs,
      kRequestAcceptVersion: QZ,
      kReplySerializerDefault: ik,
      kContentTypeParser: WZ,
      kReply: YZ,
      kRequest: XZ,
      kFourOhFour: ZZ,
      kState: qt,
      kOptions: p_,
      kPluginNameChain: Fu,
      kSchemaErrorFormatter: m_,
      kErrorHandler: gd,
      kKeepAliveConnections: y_,
      kChildLoggerFactory: g_,
      kGenReqId: __,
    } = Vt(),
    { createServer: eee, compileValidateHTTPVersion: tee } = lb(),
    Mu = wc(),
    _d = Lc(),
    ree = xc(),
    { supportedMethods: nee } = pm(),
    Wo = Sm(),
    Di = Om(),
    ok = R0(),
    { Hooks: see, hookRunnerApplication: ak, supportedHooks: S_ } = Os(),
    { createLogger: iee, createChildLogger: uk, defaultChildLoggerFactory: oee } = ba(),
    lk = A0(),
    { getGenReqId: ck, reqIdGenFactory: fk } = Hf(),
    { buildRouting: aee, validateBodyLimitOption: uee } = _C(),
    lee = TC(),
    yk = OC(),
    cee = LC(),
    { FSTDEP009: fee } = ts(),
    dee = FC(),
    { appendStackTrace: hee, AVVIO_ERRORS_MAP: dk, ...qi } = tr(),
    { defaultInitOptions: kr } = yk,
    {
      FST_ERR_ASYNC_CONSTRAINT: pee,
      FST_ERR_BAD_URL: mee,
      FST_ERR_FORCE_CLOSE_CONNECTIONS_IDLE_NOT_AVAILABLE: yee,
      FST_ERR_OPTIONS_NOT_OBJ: gee,
      FST_ERR_QSP_NOT_FN: _ee,
      FST_ERR_SCHEMA_CONTROLLER_BUCKET_OPT_NOT_FN: See,
      FST_ERR_AJV_CUSTOM_OPTIONS_OPT_NOT_OBJ: vee,
      FST_ERR_AJV_CUSTOM_OPTIONS_OPT_NOT_ARR: bee,
      FST_ERR_VERSION_CONSTRAINT_NOT_STR: wee,
      FST_ERR_INSTANCE_ALREADY_LISTENING: Eee,
      FST_ERR_REOPENED_CLOSE_SERVER: Ree,
      FST_ERR_ROUTE_REWRITE_NOT_STR: Tee,
      FST_ERR_SCHEMA_ERROR_FORMATTER_NOT_FN: hk,
      FST_ERR_ERROR_HANDLER_NOT_FN: Pee,
    } = qi,
    { buildErrorHandler: pk } = Ea();
  function $ee(e) {
    let t = {};
    return (
      ["errorHandler", "logLevel", "logSerializers"].concat(S_).forEach((n) => {
        t[n] = e.store[n];
      }),
      Object.assign({}, t)
    );
  }
  function v_(e) {
    if (((e = e || {}), typeof e != "object")) throw new gee();
    if (e.querystringParser && typeof e.querystringParser != "function")
      throw new _ee(typeof e.querystringParser);
    if (
      e.schemaController &&
      e.schemaController.bucket &&
      typeof e.schemaController.bucket != "function"
    )
      throw new See(typeof e.schemaController.bucket);
    uee(e.bodyLimit);
    let t = e.requestIdHeader === !1 ? !1 : (e.requestIdHeader || kr.requestIdHeader).toLowerCase(),
      r = fk(t, e.genReqId),
      n = e.requestIdLogLabel || "reqId",
      s = e.bodyLimit || kr.bodyLimit,
      i = e.disableRequestLogging || !1,
      o = Object.assign({ customOptions: {}, plugins: [] }, e.ajv),
      a = e.frameworkErrors;
    if (!o.customOptions || Object.prototype.toString.call(o.customOptions) !== "[object Object]")
      throw new vee(typeof o.customOptions);
    if (!o.plugins || !Array.isArray(o.plugins)) throw new bee(typeof o.plugins);
    let { logger: u, hasLogger: l } = iee(e);
    (e.connectionTimeout = e.connectionTimeout || kr.connectionTimeout),
      (e.keepAliveTimeout = e.keepAliveTimeout || kr.keepAliveTimeout),
      (e.maxRequestsPerSocket = e.maxRequestsPerSocket || kr.maxRequestsPerSocket),
      (e.requestTimeout = e.requestTimeout || kr.requestTimeout),
      (e.logger = u),
      (e.requestIdHeader = t),
      (e.requestIdLogLabel = n),
      (e.disableRequestLogging = i),
      (e.ajv = o),
      (e.clientErrorHandler = e.clientErrorHandler || Y);
    let c = yk(e);
    e.exposeHeadRoutes = c.exposeHeadRoutes;
    let f = e.constraints;
    e.versioning &&
      (fee(),
      (f = {
        ...f,
        version: {
          name: "version",
          mustMatchWhenDerived: !0,
          storage: e.versioning.storage,
          deriveConstraint: e.versioning.deriveVersion,
          validate(C) {
            if (typeof C != "string") throw new wee();
          },
        },
      }));
    let d = aee({
        config: {
          defaultRoute: U,
          onBadUrl: z,
          constraints: f,
          ignoreTrailingSlash: e.ignoreTrailingSlash || kr.ignoreTrailingSlash,
          ignoreDuplicateSlashes: e.ignoreDuplicateSlashes || kr.ignoreDuplicateSlashes,
          maxParamLength: e.maxParamLength || kr.maxParamLength,
          caseSensitive: e.caseSensitive,
          allowUnsafeRegex: e.allowUnsafeRegex || kr.allowUnsafeRegex,
          buildPrettyMeta: $ee,
          querystringParser: e.querystringParser,
          useSemicolonDelimiter: e.useSemicolonDelimiter ?? kr.useSemicolonDelimiter,
        },
      }),
      h = lee(e),
      p = Oe(d, e);
    e.http2SessionTimeout = c.http2SessionTimeout;
    let { server: y, listen: _ } = eee(e, p),
      S = typeof y.closeAllConnections == "function",
      E = typeof y.closeIdleConnections == "function",
      g = e.forceCloseConnections;
    if (g === "idle" && !E) throw new yee();
    typeof g != "boolean" && (g = E ? "idle" : !1);
    let m = !S && g === !0 ? new Set() : dee(),
      T = Mu.setupResponseListeners,
      N = ok.buildSchemaController(null, e.schemaController),
      w = {
        [qt]: {
          listening: !1,
          closing: !1,
          started: !1,
          ready: !1,
          booting: !1,
          readyPromise: null,
        },
        [y_]: m,
        [p_]: e,
        [d_]: [],
        [nk]: [],
        [KZ]: s,
        [sk]: "",
        [GZ]: "",
        [JZ]: null,
        [h_]: new see(),
        [Xs]: N,
        [m_]: null,
        [gd]: pk(),
        [g_]: oee,
        [ik]: null,
        [WZ]: new Di(
          s,
          e.onProtoPoisoning || kr.onProtoPoisoning,
          e.onConstructorPoisoning || kr.onConstructorPoisoning,
        ),
        [YZ]: Mu.buildReply(Mu),
        [XZ]: _d.buildRequest(_d, e.trustProxy),
        [ZZ]: h,
        [lk.kRegisteredPlugins]: [],
        [Fu]: ["fastify"],
        [xu]: null,
        [__]: r,
        routing: p,
        getDefaultRoute: d.getDefaultRoute.bind(d),
        setDefaultRoute: d.setDefaultRoute.bind(d),
        delete: function (H, K, te) {
          return d.prepareRoute.call(this, { method: "DELETE", url: H, options: K, handler: te });
        },
        get: function (H, K, te) {
          return d.prepareRoute.call(this, { method: "GET", url: H, options: K, handler: te });
        },
        head: function (H, K, te) {
          return d.prepareRoute.call(this, { method: "HEAD", url: H, options: K, handler: te });
        },
        patch: function (H, K, te) {
          return d.prepareRoute.call(this, { method: "PATCH", url: H, options: K, handler: te });
        },
        post: function (H, K, te) {
          return d.prepareRoute.call(this, { method: "POST", url: H, options: K, handler: te });
        },
        put: function (H, K, te) {
          return d.prepareRoute.call(this, { method: "PUT", url: H, options: K, handler: te });
        },
        options: function (H, K, te) {
          return d.prepareRoute.call(this, { method: "OPTIONS", url: H, options: K, handler: te });
        },
        all: function (H, K, te) {
          return d.prepareRoute.call(this, { method: nee, url: H, options: K, handler: te });
        },
        route: function (H) {
          return d.route.call(this, { options: H });
        },
        hasRoute: function (H) {
          return d.hasRoute.call(this, { options: H });
        },
        findRoute: function (H) {
          return d.findRoute(H);
        },
        log: u,
        withTypeProvider: ie,
        addHook: Z,
        addSchema: G,
        getSchema: N.getSchema.bind(N),
        getSchemas: N.getSchemas.bind(N),
        setValidatorCompiler: ce,
        setSerializerCompiler: Ee,
        setSchemaController: ue,
        setReplySerializer: Re,
        setSchemaErrorFormatter: Se,
        setGenReqId: me,
        addContentTypeParser: Di.helpers.addContentTypeParser,
        hasContentTypeParser: Di.helpers.hasContentTypeParser,
        getDefaultJsonParser: Di.defaultParsers.getDefaultJsonParser,
        defaultTextParser: Di.defaultParsers.defaultTextParser,
        removeContentTypeParser: Di.helpers.removeContentTypeParser,
        removeAllContentTypeParsers: Di.helpers.removeAllContentTypeParsers,
        register: null,
        after: null,
        ready: null,
        onClose: null,
        close: null,
        printPlugins: null,
        hasPlugin: function (C) {
          return this[lk.kRegisteredPlugins].includes(C) || this[Fu].includes(C);
        },
        listen: _,
        server: y,
        addresses: function () {
          let C = this[nk].map((H) => H.address());
          return C.push(this.server.address()), C.filter((H) => H);
        },
        decorate: Wo.add,
        hasDecorator: Wo.exist,
        decorateReply: Wo.decorateReply,
        decorateRequest: Wo.decorateRequest,
        hasRequestDecorator: Wo.existRequest,
        hasReplyDecorator: Wo.existReply,
        inject: k,
        printRoutes: Ae,
        setNotFoundHandler: Te,
        setErrorHandler: ee,
        setChildLoggerFactory: ve,
        initialConfig: c,
        addConstraintStrategy: d.addConstraintStrategy.bind(d),
        hasConstraintStrategy: d.hasConstraintStrategy.bind(d),
      };
    Object.defineProperties(w, {
      listeningOrigin: {
        get() {
          let C = this.addresses().slice(-1).pop();
          if (typeof C == "string") return C;
          let H = C.family === "IPv6" ? `[${C.address}]` : C.address;
          return `${this[p_].https ? "https" : "http"}://${H}:${C.port}`;
        },
      },
      pluginName: {
        configurable: !0,
        get() {
          return this[Fu].length > 1 ? this[Fu].join(" -> ") : this[Fu][0];
        },
      },
      prefix: {
        configurable: !0,
        get() {
          return this[sk];
        },
      },
      validatorCompiler: {
        configurable: !0,
        get() {
          return this[Xs].getValidatorCompiler();
        },
      },
      serializerCompiler: {
        configurable: !0,
        get() {
          return this[Xs].getSerializerCompiler();
        },
      },
      childLoggerFactory: {
        configurable: !0,
        get() {
          return this[g_];
        },
      },
      version: {
        configurable: !0,
        get() {
          return HZ;
        },
      },
      errorHandler: {
        configurable: !0,
        get() {
          return this[gd].func;
        },
      },
      genReqId: {
        configurable: !0,
        get() {
          return this[__];
        },
      },
    }),
      e.schemaErrorFormatter &&
        (mk(e.schemaErrorFormatter), (w[m_] = e.schemaErrorFormatter.bind(w)));
    let $ = Number(e.pluginTimeout),
      D = BZ(w, {
        autostart: !1,
        timeout: isNaN($) === !1 ? $ : kr.pluginTimeout,
        expose: { use: "register" },
      });
    (D.override = cee),
      D.on("start", () => (w[qt].started = !0)),
      (w[xu] = w.ready),
      (w.ready = x),
      (w.printPlugins = D.prettyPrint.bind(D)),
      D.once("preReady", () => {
        w.onClose((C, H) => {
          (w[qt].closing = !0),
            d.closeRoutes(),
            ak("preClose", w[xu], w, function () {
              if (w[qt].listening) {
                if (g === "idle") C.server.closeIdleConnections();
                else if (S && g) C.server.closeAllConnections();
                else if (g === !0) for (let K of w[y_]) K.destroy(), w[y_].delete(K);
              }
              !e.serverFactory || w[qt].listening
                ? C.server.close(function (K) {
                    K && K.code !== "ERR_SERVER_NOT_RUNNING" ? H(null) : H();
                  })
                : process.nextTick(H, null);
            });
        });
      });
    let v = new ree({ server: w, config: {} });
    w.setNotFoundHandler(),
      h.arrange404(w),
      d.setup(e, {
        avvio: D,
        fourOhFour: h,
        logger: u,
        hasLogger: l,
        setupResponseListeners: T,
        throwIfAlreadyStarted: M,
        validateHTTPVersion: tee(e),
        keepAliveConnections: m,
      }),
      y.on("clientError", e.clientErrorHandler.bind(w));
    try {
      let H = require("node:diagnostics_channel").channel("fastify.initialization");
      H.hasSubscribers && H.publish({ fastify: w });
    } catch {}
    return (
      "asyncDispose" in Symbol &&
        (w[Symbol.asyncDispose] = function () {
          return w.close();
        }),
      w
    );
    function M(C) {
      if (w[qt].started) throw new Eee(C);
    }
    function k(C, H) {
      if ((Lu === void 0 && (Lu = rk()), w[qt].started)) {
        if (w[qt].closing) {
          let K = new Ree();
          if (H) {
            H(K);
            return;
          } else return Promise.reject(K);
        }
        return Lu(p, C, H);
      }
      if (H)
        this.ready((K) => {
          K ? H(K, null) : Lu(p, C, H);
        });
      else
        return Lu((K, te) => {
          this.ready(function (_e) {
            if (_e) {
              te.emit("error", _e);
              return;
            }
            p(K, te);
          });
        }, C);
    }
    function x(C) {
      if (this[qt].readyPromise !== null) {
        if (C != null) {
          this[qt].readyPromise.then(() => C(null, w), C);
          return;
        }
        return this[qt].readyPromise;
      }
      let H, K;
      if (
        (process.nextTick(te),
        (this[qt].readyPromise = new Promise(function (F, Me) {
          (H = F), (K = Me);
        })),
        C)
      )
        this[qt].readyPromise.then(() => C(null, w), C);
      else return this[qt].readyPromise;
      function te() {
        w[xu]((F, Me) => {
          F || w[qt].started || w[qt].ready || w[qt].booting
            ? _e(F)
            : ((w[qt].booting = !0), ak("onReady", w[xu], w, _e)),
            Me();
        });
      }
      function _e(F) {
        if (((F = F != null && dk[F.code] != null ? hee(F, new dk[F.code](F.message)) : F), F))
          return K(F);
        H(w), (w[qt].booting = !1), (w[qt].ready = !0), (w[qt].promise = null);
      }
    }
    function ie() {
      return this;
    }
    function Z(C, H) {
      if ((M('Cannot call "addHook"!'), H == null)) throw new qi.FST_ERR_HOOK_INVALID_HANDLER(C, H);
      if (C === "onSend" || C === "preSerialization" || C === "onError" || C === "preParsing") {
        if (H.constructor.name === "AsyncFunction" && H.length === 4)
          throw new qi.FST_ERR_HOOK_INVALID_ASYNC_HANDLER();
      } else if (C === "onReady" || C === "onListen") {
        if (H.constructor.name === "AsyncFunction" && H.length !== 0)
          throw new qi.FST_ERR_HOOK_INVALID_ASYNC_HANDLER();
      } else if (C === "onRequestAbort") {
        if (H.constructor.name === "AsyncFunction" && H.length !== 1)
          throw new qi.FST_ERR_HOOK_INVALID_ASYNC_HANDLER();
      } else if (H.constructor.name === "AsyncFunction" && H.length === 3)
        throw new qi.FST_ERR_HOOK_INVALID_ASYNC_HANDLER();
      return (
        C === "onClose"
          ? this.onClose(H)
          : C === "onReady" || C === "onListen" || C === "onRoute"
            ? this[h_].add(C, H)
            : this.after((te, _e) => {
                K.call(this, C, H), _e(te);
              }),
        this
      );
      function K(te, _e) {
        this[h_].add(te, _e), this[d_].forEach((F) => K.call(F, te, _e));
      }
    }
    function G(C) {
      return (
        M('Cannot call "addSchema"!'),
        this[Xs].add(C),
        this[d_].forEach((H) => H.addSchema(C)),
        this
      );
    }
    function Y(C, H) {
      if (C.code === "ECONNRESET" || H.destroyed) return;
      let K, te, _e, F;
      C.code === "ERR_HTTP_REQUEST_TIMEOUT"
        ? ((te = "408"),
          (_e = f_.STATUS_CODES[te]),
          (K = `{"error":"${_e}","message":"Client Timeout","statusCode":408}`),
          (F = "timeout"))
        : C.code === "HPE_HEADER_OVERFLOW"
          ? ((te = "431"),
            (_e = f_.STATUS_CODES[te]),
            (K = `{"error":"${_e}","message":"Exceeded maximum allowed HTTP header size","statusCode":431}`),
            (F = "header_overflow"))
          : ((te = "400"),
            (_e = f_.STATUS_CODES[te]),
            (K = `{"error":"${_e}","message":"Client Error","statusCode":400}`),
            (F = "error")),
        this.log.trace({ err: C }, `client ${F}`),
        H.writable &&
          H.write(`HTTP/1.1 ${te} ${_e}\r
Content-Length: ${K.length}\r
Content-Type: application/json\r
\r
${K}`),
        H.destroy(C);
    }
    function U(C, H) {
      C.headers["accept-version"] !== void 0 &&
        ((C.headers[QZ] = C.headers["accept-version"]), (C.headers["accept-version"] = void 0)),
        h.router.lookup(C, H);
    }
    function z(C, H, K) {
      if (a) {
        let _e = ck(v.server, H),
          F = uk(v, u, H, _e),
          Me = new _d(_e, null, H, null, F, v),
          Xe = new Mu(K, Me, F);
        return i === !1 && F.info({ req: Me }, "incoming request"), a(new mee(C), Me, Xe);
      }
      let te = `{"error":"Bad Request","code":"FST_ERR_BAD_URL","message":"'${C}' is not a valid url component","statusCode":400}`;
      K.writeHead(400, { "Content-Type": "application/json", "Content-Length": te.length }),
        K.end(te);
    }
    function oe(C, H, K) {
      if (C !== !1)
        return function (_e) {
          if (_e) {
            if (a) {
              let Me = ck(v.server, H),
                Xe = uk(v, u, H, Me),
                Je = new _d(Me, null, H, null, Xe, v),
                wt = new Mu(K, Je, Xe);
              return i === !1 && Xe.info({ req: Je }, "incoming request"), a(new pee(), Je, wt);
            }
            let F =
              '{"error":"Internal Server Error","message":"Unexpected error from async constraint","statusCode":500}';
            K.writeHead(500, { "Content-Type": "application/json", "Content-Length": F.length }),
              K.end(F);
          }
        };
    }
    function Te(C, H) {
      return (
        M('Cannot call "setNotFoundHandler"!'),
        h.setNotFoundHandler.call(this, C, H, D, d.routeHandler),
        this
      );
    }
    function ce(C) {
      return M('Cannot call "setValidatorCompiler"!'), this[Xs].setValidatorCompiler(C), this;
    }
    function Se(C) {
      return M('Cannot call "setSchemaErrorFormatter"!'), mk(C), (this[m_] = C.bind(this)), this;
    }
    function Ee(C) {
      return M('Cannot call "setSerializerCompiler"!'), this[Xs].setSerializerCompiler(C), this;
    }
    function ue(C) {
      M('Cannot call "setSchemaController"!');
      let H = this[Xs],
        K = ok.buildSchemaController(H, Object.assign({}, H.opts, C));
      return (
        (this[Xs] = K),
        (this.getSchema = K.getSchema.bind(K)),
        (this.getSchemas = K.getSchemas.bind(K)),
        this
      );
    }
    function Re(C) {
      return M('Cannot call "setReplySerializer"!'), (this[ik] = C), this;
    }
    function ee(C) {
      if ((M('Cannot call "setErrorHandler"!'), typeof C != "function")) throw new Pee();
      return (this[gd] = pk(this[gd], C.bind(this))), this;
    }
    function ve(C) {
      return M('Cannot call "setChildLoggerFactory"!'), (this[g_] = C), this;
    }
    function Ae(C = {}) {
      return (
        (C.includeMeta = C.includeHooks
          ? C.includeMeta
            ? S_.concat(C.includeMeta)
            : S_
          : C.includeMeta),
        d.printRoutes(C)
      );
    }
    function Oe(C, { rewriteUrl: H, logger: K }) {
      let te;
      return function (F, Me) {
        if ((te === void 0 && (te = C.isAsyncConstraint()), H)) {
          F.originalUrl = F.url;
          let Xe = H.call(w, F);
          if (typeof Xe == "string") F.url = Xe;
          else {
            let Je = new Tee(F.url, typeof Xe);
            F.destroy(Je);
          }
        }
        C.routing(F, Me, oe(te, F, Me));
      };
    }
    function me(C) {
      return M('Cannot call "setGenReqId"!'), (this[__] = fk(this[p_].requestIdHeader, C)), this;
    }
  }
  function mk(e) {
    if (typeof e != "function") throw new hk(typeof e);
    if (e.constructor.name === "AsyncFunction") throw new hk("AsyncFunction");
  }
  zu.exports = v_;
  zu.exports.errorCodes = qi;
  zu.exports.fastify = v_;
  zu.exports.default = v_;
});
var pS = b((Xt) => {
  "use strict";
  Object.defineProperty(Xt, "__esModule", { value: !0 });
  Xt.output = Xt.exists = Xt.hash = Xt.bytes = Xt.bool = Xt.number = Xt.isBytes = void 0;
  function Wd(e) {
    if (!Number.isSafeInteger(e) || e < 0) throw new Error(`positive integer expected, not ${e}`);
  }
  Xt.number = Wd;
  function UD(e) {
    if (typeof e != "boolean") throw new Error(`boolean expected, not ${e}`);
  }
  Xt.bool = UD;
  function HD(e) {
    return (
      e instanceof Uint8Array ||
      (e != null && typeof e == "object" && e.constructor.name === "Uint8Array")
    );
  }
  Xt.isBytes = HD;
  function hS(e, ...t) {
    if (!HD(e)) throw new Error("Uint8Array expected");
    if (t.length > 0 && !t.includes(e.length))
      throw new Error(`Uint8Array expected of length ${t}, not of length=${e.length}`);
  }
  Xt.bytes = hS;
  function BD(e) {
    if (typeof e != "function" || typeof e.create != "function")
      throw new Error("Hash should be wrapped by utils.wrapConstructor");
    Wd(e.outputLen), Wd(e.blockLen);
  }
  Xt.hash = BD;
  function KD(e, t = !0) {
    if (e.destroyed) throw new Error("Hash instance has been destroyed");
    if (t && e.finished) throw new Error("Hash#digest() has already been called");
  }
  Xt.exists = KD;
  function GD(e, t) {
    hS(e);
    let r = t.outputLen;
    if (e.length < r) throw new Error(`digestInto() expects output buffer of length at least ${r}`);
  }
  Xt.output = GD;
  var hte = { number: Wd, bool: UD, bytes: hS, hash: BD, exists: KD, output: GD };
  Xt.default = hte;
});
var mq = b((be) => {
  "use strict";
  Object.defineProperty(be, "__esModule", { value: !0 });
  be.add5L =
    be.add5H =
    be.add4H =
    be.add4L =
    be.add3H =
    be.add3L =
    be.add =
    be.rotlBL =
    be.rotlBH =
    be.rotlSL =
    be.rotlSH =
    be.rotr32L =
    be.rotr32H =
    be.rotrBL =
    be.rotrBH =
    be.rotrSL =
    be.rotrSH =
    be.shrSL =
    be.shrSH =
    be.toBig =
    be.split =
    be.fromBig =
      void 0;
  var Yd = BigInt(2 ** 32 - 1),
    mS = BigInt(32);
  function yS(e, t = !1) {
    return t
      ? { h: Number(e & Yd), l: Number((e >> mS) & Yd) }
      : { h: Number((e >> mS) & Yd) | 0, l: Number(e & Yd) | 0 };
  }
  be.fromBig = yS;
  function JD(e, t = !1) {
    let r = new Uint32Array(e.length),
      n = new Uint32Array(e.length);
    for (let s = 0; s < e.length; s++) {
      let { h: i, l: o } = yS(e[s], t);
      [r[s], n[s]] = [i, o];
    }
    return [r, n];
  }
  be.split = JD;
  var QD = (e, t) => (BigInt(e >>> 0) << mS) | BigInt(t >>> 0);
  be.toBig = QD;
  var WD = (e, t, r) => e >>> r;
  be.shrSH = WD;
  var YD = (e, t, r) => (e << (32 - r)) | (t >>> r);
  be.shrSL = YD;
  var XD = (e, t, r) => (e >>> r) | (t << (32 - r));
  be.rotrSH = XD;
  var ZD = (e, t, r) => (e << (32 - r)) | (t >>> r);
  be.rotrSL = ZD;
  var eq = (e, t, r) => (e << (64 - r)) | (t >>> (r - 32));
  be.rotrBH = eq;
  var tq = (e, t, r) => (e >>> (r - 32)) | (t << (64 - r));
  be.rotrBL = tq;
  var rq = (e, t) => t;
  be.rotr32H = rq;
  var nq = (e, t) => e;
  be.rotr32L = nq;
  var sq = (e, t, r) => (e << r) | (t >>> (32 - r));
  be.rotlSH = sq;
  var iq = (e, t, r) => (t << r) | (e >>> (32 - r));
  be.rotlSL = iq;
  var oq = (e, t, r) => (t << (r - 32)) | (e >>> (64 - r));
  be.rotlBH = oq;
  var aq = (e, t, r) => (e << (r - 32)) | (t >>> (64 - r));
  be.rotlBL = aq;
  function uq(e, t, r, n) {
    let s = (t >>> 0) + (n >>> 0);
    return { h: (e + r + ((s / 2 ** 32) | 0)) | 0, l: s | 0 };
  }
  be.add = uq;
  var lq = (e, t, r) => (e >>> 0) + (t >>> 0) + (r >>> 0);
  be.add3L = lq;
  var cq = (e, t, r, n) => (t + r + n + ((e / 2 ** 32) | 0)) | 0;
  be.add3H = cq;
  var fq = (e, t, r, n) => (e >>> 0) + (t >>> 0) + (r >>> 0) + (n >>> 0);
  be.add4L = fq;
  var dq = (e, t, r, n, s) => (t + r + n + s + ((e / 2 ** 32) | 0)) | 0;
  be.add4H = dq;
  var hq = (e, t, r, n, s) => (e >>> 0) + (t >>> 0) + (r >>> 0) + (n >>> 0) + (s >>> 0);
  be.add5L = hq;
  var pq = (e, t, r, n, s, i) => (t + r + n + s + i + ((e / 2 ** 32) | 0)) | 0;
  be.add5H = pq;
  var pte = {
    fromBig: yS,
    split: JD,
    toBig: QD,
    shrSH: WD,
    shrSL: YD,
    rotrSH: XD,
    rotrSL: ZD,
    rotrBH: eq,
    rotrBL: tq,
    rotr32H: rq,
    rotr32L: nq,
    rotlSH: sq,
    rotlSL: iq,
    rotlBH: oq,
    rotlBL: aq,
    add: uq,
    add3L: lq,
    add3H: cq,
    add4L: fq,
    add4H: dq,
    add5H: pq,
    add5L: hq,
  };
  be.default = pte;
});
var yq = b((Zd) => {
  "use strict";
  Object.defineProperty(Zd, "__esModule", { value: !0 });
  Zd.crypto = void 0;
  var Xd = require("node:crypto");
  Zd.crypto = Xd && typeof Xd == "object" && "webcrypto" in Xd ? Xd.webcrypto : void 0;
});
var Sq = b((ye) => {
  "use strict";
  Object.defineProperty(ye, "__esModule", { value: !0 });
  ye.randomBytes =
    ye.wrapXOFConstructorWithOpts =
    ye.wrapConstructorWithOpts =
    ye.wrapConstructor =
    ye.checkOpts =
    ye.Hash =
    ye.concatBytes =
    ye.toBytes =
    ye.utf8ToBytes =
    ye.asyncLoop =
    ye.nextTick =
    ye.hexToBytes =
    ye.bytesToHex =
    ye.byteSwap32 =
    ye.byteSwapIfBE =
    ye.byteSwap =
    ye.isLE =
    ye.rotl =
    ye.rotr =
    ye.createView =
    ye.u32 =
    ye.u8 =
    ye.isBytes =
      void 0;
  var gS = yq(),
    SS = pS();
  function mte(e) {
    return (
      e instanceof Uint8Array ||
      (e != null && typeof e == "object" && e.constructor.name === "Uint8Array")
    );
  }
  ye.isBytes = mte;
  var yte = (e) => new Uint8Array(e.buffer, e.byteOffset, e.byteLength);
  ye.u8 = yte;
  var gte = (e) => new Uint32Array(e.buffer, e.byteOffset, Math.floor(e.byteLength / 4));
  ye.u32 = gte;
  var _te = (e) => new DataView(e.buffer, e.byteOffset, e.byteLength);
  ye.createView = _te;
  var Ste = (e, t) => (e << (32 - t)) | (e >>> t);
  ye.rotr = Ste;
  var vte = (e, t) => (e << t) | ((e >>> (32 - t)) >>> 0);
  ye.rotl = vte;
  ye.isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
  var bte = (e) =>
    ((e << 24) & 4278190080) | ((e << 8) & 16711680) | ((e >>> 8) & 65280) | ((e >>> 24) & 255);
  ye.byteSwap = bte;
  ye.byteSwapIfBE = ye.isLE ? (e) => e : (e) => (0, ye.byteSwap)(e);
  function wte(e) {
    for (let t = 0; t < e.length; t++) e[t] = (0, ye.byteSwap)(e[t]);
  }
  ye.byteSwap32 = wte;
  var Ete = Array.from({ length: 256 }, (e, t) => t.toString(16).padStart(2, "0"));
  function Rte(e) {
    (0, SS.bytes)(e);
    let t = "";
    for (let r = 0; r < e.length; r++) t += Ete[e[r]];
    return t;
  }
  ye.bytesToHex = Rte;
  var Ss = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 };
  function gq(e) {
    if (e >= Ss._0 && e <= Ss._9) return e - Ss._0;
    if (e >= Ss._A && e <= Ss._F) return e - (Ss._A - 10);
    if (e >= Ss._a && e <= Ss._f) return e - (Ss._a - 10);
  }
  function Tte(e) {
    if (typeof e != "string") throw new Error("hex string expected, got " + typeof e);
    let t = e.length,
      r = t / 2;
    if (t % 2) throw new Error("padded hex string expected, got unpadded hex of length " + t);
    let n = new Uint8Array(r);
    for (let s = 0, i = 0; s < r; s++, i += 2) {
      let o = gq(e.charCodeAt(i)),
        a = gq(e.charCodeAt(i + 1));
      if (o === void 0 || a === void 0) {
        let u = e[i] + e[i + 1];
        throw new Error('hex string expected, got non-hex character "' + u + '" at index ' + i);
      }
      n[s] = o * 16 + a;
    }
    return n;
  }
  ye.hexToBytes = Tte;
  var Pte = async () => {};
  ye.nextTick = Pte;
  async function $te(e, t, r) {
    let n = Date.now();
    for (let s = 0; s < e; s++) {
      r(s);
      let i = Date.now() - n;
      (i >= 0 && i < t) || (await (0, ye.nextTick)(), (n += i));
    }
  }
  ye.asyncLoop = $te;
  function _q(e) {
    if (typeof e != "string") throw new Error(`utf8ToBytes expected string, got ${typeof e}`);
    return new Uint8Array(new TextEncoder().encode(e));
  }
  ye.utf8ToBytes = _q;
  function eh(e) {
    return typeof e == "string" && (e = _q(e)), (0, SS.bytes)(e), e;
  }
  ye.toBytes = eh;
  function Ote(...e) {
    let t = 0;
    for (let n = 0; n < e.length; n++) {
      let s = e[n];
      (0, SS.bytes)(s), (t += s.length);
    }
    let r = new Uint8Array(t);
    for (let n = 0, s = 0; n < e.length; n++) {
      let i = e[n];
      r.set(i, s), (s += i.length);
    }
    return r;
  }
  ye.concatBytes = Ote;
  var _S = class {
    clone() {
      return this._cloneInto();
    }
  };
  ye.Hash = _S;
  var Nte = {}.toString;
  function Ate(e, t) {
    if (t !== void 0 && Nte.call(t) !== "[object Object]")
      throw new Error("Options should be object or undefined");
    return Object.assign(e, t);
  }
  ye.checkOpts = Ate;
  function Ite(e) {
    let t = (n) => e().update(eh(n)).digest(),
      r = e();
    return (t.outputLen = r.outputLen), (t.blockLen = r.blockLen), (t.create = () => e()), t;
  }
  ye.wrapConstructor = Ite;
  function Cte(e) {
    let t = (n, s) => e(s).update(eh(n)).digest(),
      r = e({});
    return (t.outputLen = r.outputLen), (t.blockLen = r.blockLen), (t.create = (n) => e(n)), t;
  }
  ye.wrapConstructorWithOpts = Cte;
  function kte(e) {
    let t = (n, s) => e(s).update(eh(n)).digest(),
      r = e({});
    return (t.outputLen = r.outputLen), (t.blockLen = r.blockLen), (t.create = (n) => e(n)), t;
  }
  ye.wrapXOFConstructorWithOpts = kte;
  function Dte(e = 32) {
    if (gS.crypto && typeof gS.crypto.getRandomValues == "function")
      return gS.crypto.getRandomValues(new Uint8Array(e));
    throw new Error("crypto.getRandomValues must be defined");
  }
  ye.randomBytes = Dte;
});
var $q = b((dt) => {
  "use strict";
  Object.defineProperty(dt, "__esModule", { value: !0 });
  dt.shake256 =
    dt.shake128 =
    dt.keccak_512 =
    dt.keccak_384 =
    dt.keccak_256 =
    dt.keccak_224 =
    dt.sha3_512 =
    dt.sha3_384 =
    dt.sha3_256 =
    dt.sha3_224 =
    dt.Keccak =
    dt.keccakP =
      void 0;
  var ua = pS(),
    hl = mq(),
    vs = Sq(),
    wq = [],
    Eq = [],
    Rq = [],
    qte = BigInt(0),
    dl = BigInt(1),
    jte = BigInt(2),
    Lte = BigInt(7),
    xte = BigInt(256),
    Fte = BigInt(113);
  for (let e = 0, t = dl, r = 1, n = 0; e < 24; e++) {
    ([r, n] = [n, (2 * r + 3 * n) % 5]),
      wq.push(2 * (5 * n + r)),
      Eq.push((((e + 1) * (e + 2)) / 2) % 64);
    let s = qte;
    for (let i = 0; i < 7; i++)
      (t = ((t << dl) ^ ((t >> Lte) * Fte)) % xte),
        t & jte && (s ^= dl << ((dl << BigInt(i)) - dl));
    Rq.push(s);
  }
  var [Mte, zte] = (0, hl.split)(Rq, !0),
    vq = (e, t, r) => (r > 32 ? (0, hl.rotlBH)(e, t, r) : (0, hl.rotlSH)(e, t, r)),
    bq = (e, t, r) => (r > 32 ? (0, hl.rotlBL)(e, t, r) : (0, hl.rotlSL)(e, t, r));
  function Tq(e, t = 24) {
    let r = new Uint32Array(10);
    for (let n = 24 - t; n < 24; n++) {
      for (let o = 0; o < 10; o++) r[o] = e[o] ^ e[o + 10] ^ e[o + 20] ^ e[o + 30] ^ e[o + 40];
      for (let o = 0; o < 10; o += 2) {
        let a = (o + 8) % 10,
          u = (o + 2) % 10,
          l = r[u],
          c = r[u + 1],
          f = vq(l, c, 1) ^ r[a],
          d = bq(l, c, 1) ^ r[a + 1];
        for (let h = 0; h < 50; h += 10) (e[o + h] ^= f), (e[o + h + 1] ^= d);
      }
      let s = e[2],
        i = e[3];
      for (let o = 0; o < 24; o++) {
        let a = Eq[o],
          u = vq(s, i, a),
          l = bq(s, i, a),
          c = wq[o];
        (s = e[c]), (i = e[c + 1]), (e[c] = u), (e[c + 1] = l);
      }
      for (let o = 0; o < 50; o += 10) {
        for (let a = 0; a < 10; a++) r[a] = e[o + a];
        for (let a = 0; a < 10; a++) e[o + a] ^= ~r[(a + 2) % 10] & r[(a + 4) % 10];
      }
      (e[0] ^= Mte[n]), (e[1] ^= zte[n]);
    }
    r.fill(0);
  }
  dt.keccakP = Tq;
  var pl = class e extends vs.Hash {
    constructor(t, r, n, s = !1, i = 24) {
      if (
        (super(),
        (this.blockLen = t),
        (this.suffix = r),
        (this.outputLen = n),
        (this.enableXOF = s),
        (this.rounds = i),
        (this.pos = 0),
        (this.posOut = 0),
        (this.finished = !1),
        (this.destroyed = !1),
        (0, ua.number)(n),
        0 >= this.blockLen || this.blockLen >= 200)
      )
        throw new Error("Sha3 supports only keccak-f1600 function");
      (this.state = new Uint8Array(200)), (this.state32 = (0, vs.u32)(this.state));
    }
    keccak() {
      vs.isLE || (0, vs.byteSwap32)(this.state32),
        Tq(this.state32, this.rounds),
        vs.isLE || (0, vs.byteSwap32)(this.state32),
        (this.posOut = 0),
        (this.pos = 0);
    }
    update(t) {
      (0, ua.exists)(this);
      let { blockLen: r, state: n } = this;
      t = (0, vs.toBytes)(t);
      let s = t.length;
      for (let i = 0; i < s; ) {
        let o = Math.min(r - this.pos, s - i);
        for (let a = 0; a < o; a++) n[this.pos++] ^= t[i++];
        this.pos === r && this.keccak();
      }
      return this;
    }
    finish() {
      if (this.finished) return;
      this.finished = !0;
      let { state: t, suffix: r, pos: n, blockLen: s } = this;
      (t[n] ^= r), r & 128 && n === s - 1 && this.keccak(), (t[s - 1] ^= 128), this.keccak();
    }
    writeInto(t) {
      (0, ua.exists)(this, !1), (0, ua.bytes)(t), this.finish();
      let r = this.state,
        { blockLen: n } = this;
      for (let s = 0, i = t.length; s < i; ) {
        this.posOut >= n && this.keccak();
        let o = Math.min(n - this.posOut, i - s);
        t.set(r.subarray(this.posOut, this.posOut + o), s), (this.posOut += o), (s += o);
      }
      return t;
    }
    xofInto(t) {
      if (!this.enableXOF) throw new Error("XOF is not possible for this instance");
      return this.writeInto(t);
    }
    xof(t) {
      return (0, ua.number)(t), this.xofInto(new Uint8Array(t));
    }
    digestInto(t) {
      if (((0, ua.output)(t, this), this.finished)) throw new Error("digest() was already called");
      return this.writeInto(t), this.destroy(), t;
    }
    digest() {
      return this.digestInto(new Uint8Array(this.outputLen));
    }
    destroy() {
      (this.destroyed = !0), this.state.fill(0);
    }
    _cloneInto(t) {
      let { blockLen: r, suffix: n, outputLen: s, rounds: i, enableXOF: o } = this;
      return (
        t || (t = new e(r, n, s, o, i)),
        t.state32.set(this.state32),
        (t.pos = this.pos),
        (t.posOut = this.posOut),
        (t.finished = this.finished),
        (t.rounds = i),
        (t.suffix = n),
        (t.outputLen = s),
        (t.enableXOF = o),
        (t.destroyed = this.destroyed),
        t
      );
    }
  };
  dt.Keccak = pl;
  var ni = (e, t, r) => (0, vs.wrapConstructor)(() => new pl(t, e, r));
  dt.sha3_224 = ni(6, 144, 224 / 8);
  dt.sha3_256 = ni(6, 136, 256 / 8);
  dt.sha3_384 = ni(6, 104, 384 / 8);
  dt.sha3_512 = ni(6, 72, 512 / 8);
  dt.keccak_224 = ni(1, 144, 224 / 8);
  dt.keccak_256 = ni(1, 136, 256 / 8);
  dt.keccak_384 = ni(1, 104, 384 / 8);
  dt.keccak_512 = ni(1, 72, 512 / 8);
  var Pq = (e, t, r) =>
    (0, vs.wrapXOFConstructorWithOpts)(
      (n = {}) => new pl(t, e, n.dkLen === void 0 ? r : n.dkLen, !0),
    );
  dt.shake128 = Pq(31, 168, 128 / 8);
  dt.shake256 = Pq(31, 136, 256 / 8);
});
var qq = b((Bde, si) => {
  var { sha3_512: Vte } = $q(),
    Nq = 24,
    ml = 32,
    vS = (e = 4, t = Math.random) => {
      let r = "";
      for (; r.length < e; ) r = r + Math.floor(t() * 36).toString(36);
      return r;
    };
  function Aq(e) {
    let t = 8n,
      r = 0n;
    for (let n of e.values()) {
      let s = BigInt(n);
      r = (r << t) + s;
    }
    return r;
  }
  var Iq = (e = "") => Aq(Vte(e)).toString(36).slice(1),
    Oq = Array.from({ length: 26 }, (e, t) => String.fromCharCode(t + 97)),
    Ute = (e) => Oq[Math.floor(e() * Oq.length)],
    Cq = ({
      globalObj: e = typeof global < "u" ? global : typeof window < "u" ? window : {},
      random: t = Math.random,
    } = {}) => {
      let r = Object.keys(e).toString(),
        n = r.length ? r + vS(ml, t) : vS(ml, t);
      return Iq(n).substring(0, ml);
    },
    kq = (e) => () => e++,
    Hte = 476782367,
    Dq = ({
      random: e = Math.random,
      counter: t = kq(Math.floor(e() * Hte)),
      length: r = Nq,
      fingerprint: n = Cq({ random: e }),
    } = {}) =>
      function () {
        let i = Ute(e),
          o = Date.now().toString(36),
          a = t().toString(36),
          u = vS(r, e),
          l = `${o + u + a + n}`;
        return `${i + Iq(l).substring(1, r)}`;
      },
    Bte = Dq(),
    Kte = (e, { minLength: t = 2, maxLength: r = ml } = {}) => {
      let n = e.length,
        s = /^[0-9a-z]+$/;
      try {
        if (typeof e == "string" && n >= t && n <= r && s.test(e)) return !0;
      } finally {
      }
      return !1;
    };
  si.exports.getConstants = () => ({ defaultLength: Nq, bigLength: ml });
  si.exports.init = Dq;
  si.exports.createId = Bte;
  si.exports.bufToBigInt = Aq;
  si.exports.createCounter = kq;
  si.exports.createFingerprint = Cq;
  si.exports.isCuid = Kte;
});
var ii = b((Kde, yl) => {
  var { createId: Gte, init: Jte, getConstants: Qte, isCuid: Wte } = qq();
  yl.exports.createId = Gte;
  yl.exports.init = Jte;
  yl.exports.getConstants = Qte;
  yl.exports.isCuid = Wte;
});
var lj = b((ehe, uj) => {
  "use strict";
  var AS = Object.defineProperty,
    Yte = Object.getOwnPropertyDescriptor,
    Xte = Object.getOwnPropertyNames,
    Zte = Object.prototype.hasOwnProperty,
    ere = (e, t) => {
      for (var r in t) AS(e, r, { get: t[r], enumerable: !0 });
    },
    tre = (e, t, r, n) => {
      if ((t && typeof t == "object") || typeof t == "function")
        for (let s of Xte(t))
          !Zte.call(e, s) &&
            s !== r &&
            AS(e, s, { get: () => t[s], enumerable: !(n = Yte(t, s)) || n.enumerable });
      return e;
    },
    rre = (e) => tre(AS({}, "__esModule", { value: !0 }), e),
    zq = {};
  ere(zq, {
    course: () => oi,
    courseHistory: () => sj,
    coursePack: () => la,
    coursePackRelations: () => tj,
    courseRelations: () => nj,
    membership: () => ij,
    schemas: () => Gre,
    statement: () => Sl,
    statementRelations: () => rj,
    userCourseProgress: () => oj,
    userLearnRecord: () => aj,
  });
  uj.exports = rre(zq);
  var nre = ii(),
    ge = Symbol.for("drizzle:entityKind"),
    Gde = Symbol.for("drizzle:hasOwnEntityKind");
  function cn(e, t) {
    if (!e || typeof e != "object") return !1;
    if (e instanceof t) return !0;
    if (!Object.prototype.hasOwnProperty.call(t, ge))
      throw new Error(
        `Class "${t.name ?? "<unknown>"}" doesn't look like a Drizzle entity. If this is incorrect and the class is provided by Drizzle, please report this as a bug.`,
      );
    let r = e.constructor;
    if (r)
      for (; r; ) {
        if (ge in r && r[ge] === t[ge]) return !0;
        r = Object.getPrototypeOf(r);
      }
    return !1;
  }
  var IS = class {
      constructor(e, t) {
        (this.table = e),
          (this.config = t),
          (this.name = t.name),
          (this.notNull = t.notNull),
          (this.default = t.default),
          (this.defaultFn = t.defaultFn),
          (this.onUpdateFn = t.onUpdateFn),
          (this.hasDefault = t.hasDefault),
          (this.primary = t.primaryKey),
          (this.isUnique = t.isUnique),
          (this.uniqueName = t.uniqueName),
          (this.uniqueType = t.uniqueType),
          (this.dataType = t.dataType),
          (this.columnType = t.columnType);
      }
      static [ge] = "Column";
      name;
      primary;
      notNull;
      default;
      defaultFn;
      onUpdateFn;
      hasDefault;
      isUnique;
      uniqueName;
      uniqueType;
      dataType;
      columnType;
      enumValues = void 0;
      config;
      mapFromDriverValue(e) {
        return e;
      }
      mapToDriverValue(e) {
        return e;
      }
    },
    sre = class {
      static [ge] = "ColumnBuilder";
      config;
      constructor(e, t, r) {
        this.config = {
          name: e,
          notNull: !1,
          default: void 0,
          hasDefault: !1,
          primaryKey: !1,
          isUnique: !1,
          uniqueName: void 0,
          uniqueType: void 0,
          dataType: t,
          columnType: r,
        };
      }
      $type() {
        return this;
      }
      notNull() {
        return (this.config.notNull = !0), this;
      }
      default(e) {
        return (this.config.default = e), (this.config.hasDefault = !0), this;
      }
      $defaultFn(e) {
        return (this.config.defaultFn = e), (this.config.hasDefault = !0), this;
      }
      $default = this.$defaultFn;
      $onUpdateFn(e) {
        return (this.config.onUpdateFn = e), (this.config.hasDefault = !0), this;
      }
      $onUpdate = this.$onUpdateFn;
      primaryKey() {
        return (this.config.primaryKey = !0), (this.config.notNull = !0), this;
      }
    },
    bS = Symbol.for("drizzle:Name"),
    wS = Symbol.for("drizzle:Schema"),
    jq = Symbol.for("drizzle:Columns"),
    ES = Symbol.for("drizzle:OriginalName"),
    RS = Symbol.for("drizzle:BaseName"),
    Lq = Symbol.for("drizzle:IsAlias"),
    xq = Symbol.for("drizzle:ExtraConfigBuilder"),
    ire = Symbol.for("drizzle:IsDrizzleTable"),
    Jn = class {
      static [ge] = "Table";
      static Symbol = {
        Name: bS,
        Schema: wS,
        OriginalName: ES,
        Columns: jq,
        BaseName: RS,
        IsAlias: Lq,
        ExtraConfigBuilder: xq,
      };
      [bS];
      [ES];
      [wS];
      [jq];
      [RS];
      [Lq] = !1;
      [xq] = void 0;
      [ire] = !0;
      constructor(e, t, r) {
        (this[bS] = this[ES] = e), (this[wS] = t), (this[RS] = r);
      }
    },
    $S = Symbol.for("drizzle:PgInlineForeignKeys"),
    _l = class extends Jn {
      static [ge] = "PgTable";
      static Symbol = Object.assign({}, Jn.Symbol, { InlineForeignKeys: $S });
      [$S] = [];
      [Jn.Symbol.ExtraConfigBuilder] = void 0;
    };
  function ore(e, t, r, n, s = e) {
    let i = new _l(e, n, s),
      o = Object.fromEntries(
        Object.entries(t).map(([u, l]) => {
          let c = l,
            f = c.build(i);
          return i[$S].push(...c.buildForeignKeys(f, i)), [u, f];
        }),
      ),
      a = Object.assign(i, o);
    return (a[Jn.Symbol.Columns] = o), r && (a[_l.Symbol.ExtraConfigBuilder] = r), a;
  }
  var Vi = (e, t, r) => ore(e, t, r, void 0),
    are = class {
      static [ge] = "PgForeignKeyBuilder";
      reference;
      _onUpdate = "no action";
      _onDelete = "no action";
      constructor(e, t) {
        (this.reference = () => {
          let { name: r, columns: n, foreignColumns: s } = e();
          return { name: r, columns: n, foreignTable: s[0].table, foreignColumns: s };
        }),
          t && ((this._onUpdate = t.onUpdate), (this._onDelete = t.onDelete));
      }
      onUpdate(e) {
        return (this._onUpdate = e === void 0 ? "no action" : e), this;
      }
      onDelete(e) {
        return (this._onDelete = e === void 0 ? "no action" : e), this;
      }
      build(e) {
        return new ure(e, this);
      }
    },
    ure = class {
      constructor(e, t) {
        (this.table = e),
          (this.reference = t.reference),
          (this.onUpdate = t._onUpdate),
          (this.onDelete = t._onDelete);
      }
      static [ge] = "PgForeignKey";
      reference;
      onUpdate;
      onDelete;
      getName() {
        let { name: e, columns: t, foreignColumns: r } = this.reference(),
          n = t.map((o) => o.name),
          s = r.map((o) => o.name),
          i = [this.table[_l.Symbol.Name], ...n, r[0].table[_l.Symbol.Name], ...s];
        return e ?? `${i.join("_")}_fk`;
      }
    };
  function Vq(e, ...t) {
    return e(...t);
  }
  function CS(e) {
    return new cre(e);
  }
  function Uq(e, t) {
    return `${e[_l.Symbol.Name]}_${t.join("_")}_unique`;
  }
  var lre = class {
      constructor(e, t) {
        (this.name = t), (this.columns = e);
      }
      static [ge] = "PgUniqueConstraintBuilder";
      columns;
      nullsNotDistinctConfig = !1;
      nullsNotDistinct() {
        return (this.nullsNotDistinctConfig = !0), this;
      }
      build(e) {
        return new fre(e, this.columns, this.nullsNotDistinctConfig, this.name);
      }
    },
    cre = class {
      static [ge] = "PgUniqueOnConstraintBuilder";
      name;
      constructor(e) {
        this.name = e;
      }
      on(...e) {
        return new lre(e, this.name);
      }
    },
    fre = class {
      constructor(e, t, r, n) {
        (this.table = e),
          (this.columns = t),
          (this.name =
            n ??
            Uq(
              this.table,
              this.columns.map((s) => s.name),
            )),
          (this.nullsNotDistinct = r);
      }
      static [ge] = "PgUniqueConstraint";
      columns;
      name;
      nullsNotDistinct = !1;
      getName() {
        return this.name;
      }
    };
  function Fq(e, t, r) {
    for (let n = t; n < e.length; n++) {
      let s = e[n];
      if (s === "\\") {
        n++;
        continue;
      }
      if (s === '"') return [e.slice(t, n).replace(/\\/g, ""), n + 1];
      if (!r && (s === "," || s === "}")) return [e.slice(t, n).replace(/\\/g, ""), n];
    }
    return [e.slice(t).replace(/\\/g, ""), e.length];
  }
  function Hq(e, t = 0) {
    let r = [],
      n = t,
      s = !1;
    for (; n < e.length; ) {
      let i = e[n];
      if (i === ",") {
        (s || n === t) && r.push(""), (s = !0), n++;
        continue;
      }
      if (((s = !1), i === "\\")) {
        n += 2;
        continue;
      }
      if (i === '"') {
        let [u, l] = Fq(e, n + 1, !0);
        r.push(u), (n = l);
        continue;
      }
      if (i === "}") return [r, n + 1];
      if (i === "{") {
        let [u, l] = Hq(e, n + 1);
        r.push(u), (n = l);
        continue;
      }
      let [o, a] = Fq(e, n, !1);
      r.push(o), (n = a);
    }
    return [r, n];
  }
  function dre(e) {
    let [t] = Hq(e, 1);
    return t;
  }
  function Bq(e) {
    return `{${e.map((t) => (Array.isArray(t) ? Bq(t) : typeof t == "string" ? `"${t.replace(/\\/g, "\\\\").replace(/"/g, '\\"')}"` : `${t}`)).join(",")}}`;
  }
  var Ui = class extends sre {
      foreignKeyConfigs = [];
      static [ge] = "PgColumnBuilder";
      array(e) {
        return new hre(this.config.name, this, e);
      }
      references(e, t = {}) {
        return this.foreignKeyConfigs.push({ ref: e, actions: t }), this;
      }
      unique(e, t) {
        return (
          (this.config.isUnique = !0),
          (this.config.uniqueName = e),
          (this.config.uniqueType = t?.nulls),
          this
        );
      }
      buildForeignKeys(e, t) {
        return this.foreignKeyConfigs.map(({ ref: r, actions: n }) =>
          Vq(
            (s, i) => {
              let o = new are(() => {
                let a = s();
                return { columns: [e], foreignColumns: [a] };
              });
              return (
                i.onUpdate && o.onUpdate(i.onUpdate),
                i.onDelete && o.onDelete(i.onDelete),
                o.build(t)
              );
            },
            r,
            n,
          ),
        );
      }
    },
    Qn = class extends IS {
      constructor(e, t) {
        t.uniqueName || (t.uniqueName = Uq(e, [t.name])), super(e, t), (this.table = e);
      }
      static [ge] = "PgColumn";
    },
    hre = class extends Ui {
      static [ge] = "PgArrayBuilder";
      constructor(e, t, r) {
        super(e, "array", "PgArray"), (this.config.baseBuilder = t), (this.config.size = r);
      }
      build(e) {
        let t = this.config.baseBuilder.build(e);
        return new pre(e, this.config, t);
      }
    },
    pre = class Kq extends Qn {
      constructor(t, r, n, s) {
        super(t, r), (this.baseColumn = n), (this.range = s), (this.size = r.size);
      }
      size;
      static [ge] = "PgArray";
      getSQLType() {
        return `${this.baseColumn.getSQLType()}[${typeof this.size == "number" ? this.size : ""}]`;
      }
      mapFromDriverValue(t) {
        return (
          typeof t == "string" && (t = dre(t)), t.map((r) => this.baseColumn.mapFromDriverValue(r))
        );
      }
      mapToDriverValue(t, r = !1) {
        let n = t.map((s) =>
          s === null
            ? null
            : cn(this.baseColumn, Kq)
              ? this.baseColumn.mapToDriverValue(s, !0)
              : this.baseColumn.mapToDriverValue(s),
        );
        return r ? n : Bq(n);
      }
    },
    Mq = Symbol.for("drizzle:isPgEnum");
  function mre(e) {
    return !!e && typeof e == "function" && Mq in e && e[Mq] === !0;
  }
  var Jde = class extends Ui {
      static [ge] = "PgEnumColumnBuilder";
      constructor(e, t) {
        super(e, "string", "PgEnumColumn"), (this.config.enum = t);
      }
      build(e) {
        return new yre(e, this.config);
      }
    },
    yre = class extends Qn {
      static [ge] = "PgEnumColumn";
      enum = this.config.enum;
      enumValues = this.config.enum.enumValues;
      constructor(e, t) {
        super(e, t), (this.enum = t.enum);
      }
      getSQLType() {
        return this.enum.enumName;
      }
    },
    kS = class {
      static [ge] = "Subquery";
      constructor(e, t, r, n = !1) {
        this._ = { brand: "Subquery", sql: e, selectedFields: t, alias: r, isWith: n };
      }
    },
    Qde = class extends kS {
      static [ge] = "WithSubquery";
    },
    gre = "0.30.10",
    TS,
    PS,
    _re = {
      startActiveSpan(e, t) {
        return TS
          ? (PS || (PS = TS.trace.getTracer("drizzle-orm", gre)),
            Vq(
              (r, n) =>
                n.startActiveSpan(e, (s) => {
                  try {
                    return t(s);
                  } catch (i) {
                    throw (
                      (s.setStatus({
                        code: r.SpanStatusCode.ERROR,
                        message: i instanceof Error ? i.message : "Unknown error",
                      }),
                      i)
                    );
                  } finally {
                    s.end();
                  }
                }),
              TS,
              PS,
            ))
          : t();
      },
    },
    th = Symbol.for("drizzle:ViewBaseConfig"),
    Wde = class {
      static [ge] = "FakePrimitiveParam";
    };
  function Sre(e) {
    return e != null && typeof e.getSQL == "function";
  }
  function vre(e) {
    let t = { sql: "", params: [] };
    for (let r of e)
      (t.sql += r.sql),
        t.params.push(...r.params),
        r.typings?.length && (t.typings || (t.typings = []), t.typings.push(...r.typings));
    return t;
  }
  var Tn = class {
      static [ge] = "StringChunk";
      value;
      constructor(e) {
        this.value = Array.isArray(e) ? e : [e];
      }
      getSQL() {
        return new Er([this]);
      }
    },
    Er = class gl {
      constructor(t) {
        this.queryChunks = t;
      }
      static [ge] = "SQL";
      decoder = Gq;
      shouldInlineParams = !1;
      append(t) {
        return this.queryChunks.push(...t.queryChunks), this;
      }
      toQuery(t) {
        return _re.startActiveSpan("drizzle.buildSQL", (r) => {
          let n = this.buildQueryFromSourceParams(this.queryChunks, t);
          return (
            r?.setAttributes({
              "drizzle.query.text": n.sql,
              "drizzle.query.params": JSON.stringify(n.params),
            }),
            n
          );
        });
      }
      buildQueryFromSourceParams(t, r) {
        let n = Object.assign({}, r, {
            inlineParams: r.inlineParams || this.shouldInlineParams,
            paramStartIndex: r.paramStartIndex || { value: 0 },
          }),
          {
            escapeName: s,
            escapeParam: i,
            prepareTyping: o,
            inlineParams: a,
            paramStartIndex: u,
          } = n;
        return vre(
          t.map((l) => {
            if (cn(l, Tn)) return { sql: l.value.join(""), params: [] };
            if (cn(l, OS)) return { sql: s(l.value), params: [] };
            if (l === void 0) return { sql: "", params: [] };
            if (Array.isArray(l)) {
              let c = [new Tn("(")];
              for (let [f, d] of l.entries()) c.push(d), f < l.length - 1 && c.push(new Tn(", "));
              return c.push(new Tn(")")), this.buildQueryFromSourceParams(c, n);
            }
            if (cn(l, gl))
              return this.buildQueryFromSourceParams(l.queryChunks, {
                ...n,
                inlineParams: a || l.shouldInlineParams,
              });
            if (cn(l, Jn)) {
              let c = l[Jn.Symbol.Schema],
                f = l[Jn.Symbol.Name];
              return { sql: c === void 0 ? s(f) : s(c) + "." + s(f), params: [] };
            }
            if (cn(l, IS)) return { sql: s(l.table[Jn.Symbol.Name]) + "." + s(l.name), params: [] };
            if (cn(l, bre)) {
              let c = l[th].schema,
                f = l[th].name;
              return { sql: c === void 0 ? s(f) : s(c) + "." + s(f), params: [] };
            }
            if (cn(l, Qq)) {
              let c = l.value === null ? null : l.encoder.mapToDriverValue(l.value);
              if (cn(c, gl)) return this.buildQueryFromSourceParams([c], n);
              if (a) return { sql: this.mapInlineParam(c, n), params: [] };
              let f;
              return (
                o !== void 0 && (f = [o(l.encoder)]),
                { sql: i(u.value++, c), params: [c], typings: f }
              );
            }
            return cn(l, Wq)
              ? { sql: i(u.value++, l), params: [l] }
              : cn(l, gl.Aliased) && l.fieldAlias !== void 0
                ? { sql: s(l.fieldAlias), params: [] }
                : cn(l, kS)
                  ? l._.isWith
                    ? { sql: s(l._.alias), params: [] }
                    : this.buildQueryFromSourceParams(
                        [new Tn("("), l._.sql, new Tn(") "), new OS(l._.alias)],
                        n,
                      )
                  : mre(l)
                    ? l.schema
                      ? { sql: s(l.schema) + "." + s(l.enumName), params: [] }
                      : { sql: s(l.enumName), params: [] }
                    : Sre(l)
                      ? this.buildQueryFromSourceParams([new Tn("("), l.getSQL(), new Tn(")")], n)
                      : a
                        ? { sql: this.mapInlineParam(l, n), params: [] }
                        : { sql: i(u.value++, l), params: [l] };
          }),
        );
      }
      mapInlineParam(t, { escapeString: r }) {
        if (t === null) return "null";
        if (typeof t == "number" || typeof t == "boolean") return t.toString();
        if (typeof t == "string") return r(t);
        if (typeof t == "object") {
          let n = t.toString();
          return r(n === "[object Object]" ? JSON.stringify(t) : n);
        }
        throw new Error("Unexpected param value: " + t);
      }
      getSQL() {
        return this;
      }
      as(t) {
        return t === void 0 ? this : new gl.Aliased(this, t);
      }
      mapWith(t) {
        return (this.decoder = typeof t == "function" ? { mapFromDriverValue: t } : t), this;
      }
      inlineParams() {
        return (this.shouldInlineParams = !0), this;
      }
      if(t) {
        return t ? this : void 0;
      }
    },
    OS = class {
      constructor(e) {
        this.value = e;
      }
      static [ge] = "Name";
      brand;
      getSQL() {
        return new Er([this]);
      }
    },
    Gq = { mapFromDriverValue: (e) => e },
    Jq = { mapToDriverValue: (e) => e },
    Yde = { ...Gq, ...Jq },
    Qq = class {
      constructor(e, t = Jq) {
        (this.value = e), (this.encoder = t);
      }
      static [ge] = "Param";
      brand;
      getSQL() {
        return new Er([this]);
      }
    };
  function NS(e, ...t) {
    let r = [];
    (t.length > 0 || (e.length > 0 && e[0] !== "")) && r.push(new Tn(e[0]));
    for (let [n, s] of t.entries()) r.push(s, new Tn(e[n + 1]));
    return new Er(r);
  }
  ((e) => {
    function t() {
      return new Er([]);
    }
    e.empty = t;
    function r(u) {
      return new Er(u);
    }
    e.fromList = r;
    function n(u) {
      return new Er([new Tn(u)]);
    }
    e.raw = n;
    function s(u, l) {
      let c = [];
      for (let [f, d] of u.entries()) f > 0 && l !== void 0 && c.push(l), c.push(d);
      return new Er(c);
    }
    e.join = s;
    function i(u) {
      return new OS(u);
    }
    e.identifier = i;
    function o(u) {
      return new Wq(u);
    }
    e.placeholder = o;
    function a(u, l) {
      return new Qq(u, l);
    }
    e.param = a;
  })(NS || (NS = {}));
  ((e) => {
    class t {
      constructor(n, s) {
        (this.sql = n), (this.fieldAlias = s);
      }
      static [ge] = "SQL.Aliased";
      isSelectionField = !1;
      getSQL() {
        return this.sql;
      }
      clone() {
        return new t(this.sql, this.fieldAlias);
      }
    }
    e.Aliased = t;
  })(Er || (Er = {}));
  var Wq = class {
      constructor(e) {
        this.name = e;
      }
      static [ge] = "Placeholder";
      getSQL() {
        return new Er([this]);
      }
    },
    bre = class {
      static [ge] = "View";
      [th];
      constructor({ name: e, schema: t, selectedFields: r, query: n }) {
        this[th] = {
          name: e,
          originalName: e,
          schema: t,
          selectedFields: r,
          query: n,
          isExisting: !n,
          isAlias: !1,
        };
      }
      getSQL() {
        return new Er([this]);
      }
    };
  IS.prototype.getSQL = function () {
    return new Er([this]);
  };
  Jn.prototype.getSQL = function () {
    return new Er([this]);
  };
  kS.prototype.getSQL = function () {
    return new Er([this]);
  };
  var Yq = class {
      constructor(e, t, r) {
        (this.sourceTable = e),
          (this.referencedTable = t),
          (this.relationName = r),
          (this.referencedTableName = t[Jn.Symbol.Name]);
      }
      static [ge] = "Relation";
      referencedTableName;
      fieldName;
    },
    wre = class {
      constructor(e, t) {
        (this.table = e), (this.config = t);
      }
      static [ge] = "Relations";
    },
    Xde = class Xq extends Yq {
      constructor(t, r, n, s) {
        super(t, r, n?.relationName), (this.config = n), (this.isNullable = s);
      }
      static [ge] = "One";
      withFieldName(t) {
        let r = new Xq(this.sourceTable, this.referencedTable, this.config, this.isNullable);
        return (r.fieldName = t), r;
      }
    },
    Zde = class Zq extends Yq {
      constructor(t, r, n) {
        super(t, r, n?.relationName), (this.config = n);
      }
      static [ge] = "Many";
      withFieldName(t) {
        let r = new Zq(this.sourceTable, this.referencedTable, this.config);
        return (r.fieldName = t), r;
      }
    };
  function DS(e, t) {
    return new wre(e, (r) =>
      Object.fromEntries(Object.entries(t(r)).map(([n, s]) => [n, s.withFieldName(n)])),
    );
  }
  var Ere = class extends Ui {
      static [ge] = "PgBooleanBuilder";
      constructor(e) {
        super(e, "boolean", "PgBoolean");
      }
      build(e) {
        return new Rre(e, this.config);
      }
    },
    Rre = class extends Qn {
      static [ge] = "PgBoolean";
      getSQLType() {
        return "boolean";
      }
    };
  function ej(e) {
    return new Ere(e);
  }
  var rh = class extends Ui {
      static [ge] = "PgDateColumnBaseBuilder";
      defaultNow() {
        return this.default(NS`now()`);
      }
    },
    Tre = class extends rh {
      static [ge] = "PgDateBuilder";
      constructor(e) {
        super(e, "date", "PgDate");
      }
      build(e) {
        return new Pre(e, this.config);
      }
    },
    Pre = class extends Qn {
      static [ge] = "PgDate";
      getSQLType() {
        return "date";
      }
      mapFromDriverValue(e) {
        return new Date(e);
      }
      mapToDriverValue(e) {
        return e.toISOString();
      }
    },
    $re = class extends rh {
      static [ge] = "PgDateStringBuilder";
      constructor(e) {
        super(e, "string", "PgDateString");
      }
      build(e) {
        return new Ore(e, this.config);
      }
    },
    Ore = class extends Qn {
      static [ge] = "PgDateString";
      getSQLType() {
        return "date";
      }
    };
  function Nre(e, t) {
    return t?.mode === "date" ? new Tre(e) : new $re(e);
  }
  var Are = class extends Ui {
      static [ge] = "PgIntegerBuilder";
      constructor(e) {
        super(e, "number", "PgInteger");
      }
      build(e) {
        return new Ire(e, this.config);
      }
    },
    Ire = class extends Qn {
      static [ge] = "PgInteger";
      getSQLType() {
        return "integer";
      }
      mapFromDriverValue(e) {
        return typeof e == "string" ? Number.parseInt(e) : e;
      }
    };
  function ca(e) {
    return new Are(e);
  }
  var Cre = class extends Ui {
      static [ge] = "PgTextBuilder";
      constructor(e, t) {
        super(e, "string", "PgText"), (this.config.enumValues = t.enum);
      }
      build(e) {
        return new kre(e, this.config);
      }
    },
    kre = class extends Qn {
      static [ge] = "PgText";
      enumValues = this.config.enumValues;
      getSQLType() {
        return "text";
      }
    };
  function bt(e, t = {}) {
    return new Cre(e, t);
  }
  var Dre = class extends rh {
      static [ge] = "PgTimestampBuilder";
      constructor(e, t, r) {
        super(e, "date", "PgTimestamp"),
          (this.config.withTimezone = t),
          (this.config.precision = r);
      }
      build(e) {
        return new qre(e, this.config);
      }
    },
    qre = class extends Qn {
      static [ge] = "PgTimestamp";
      withTimezone;
      precision;
      constructor(e, t) {
        super(e, t), (this.withTimezone = t.withTimezone), (this.precision = t.precision);
      }
      getSQLType() {
        return `timestamp${this.precision === void 0 ? "" : ` (${this.precision})`}${this.withTimezone ? " with time zone" : ""}`;
      }
      mapFromDriverValue = (e) => new Date(this.withTimezone ? e : e + "+0000");
      mapToDriverValue = (e) => e.toISOString();
    },
    jre = class extends rh {
      static [ge] = "PgTimestampStringBuilder";
      constructor(e, t, r) {
        super(e, "string", "PgTimestampString"),
          (this.config.withTimezone = t),
          (this.config.precision = r);
      }
      build(e) {
        return new Lre(e, this.config);
      }
    },
    Lre = class extends Qn {
      static [ge] = "PgTimestampString";
      withTimezone;
      precision;
      constructor(e, t) {
        super(e, t), (this.withTimezone = t.withTimezone), (this.precision = t.precision);
      }
      getSQLType() {
        return `timestamp${this.precision === void 0 ? "" : `(${this.precision})`}${this.withTimezone ? " with time zone" : ""}`;
      }
    };
  function dr(e, t = {}) {
    return t.mode === "string"
      ? new jre(e, t.withTimezone ?? !1, t.precision)
      : new Dre(e, t.withTimezone ?? !1, t.precision);
  }
  var xre = class extends Ui {
      static [ge] = "PgVarcharBuilder";
      constructor(e, t) {
        super(e, "string", "PgVarchar"),
          (this.config.length = t.length),
          (this.config.enumValues = t.enum);
      }
      build(e) {
        return new Fre(e, this.config);
      }
    },
    Fre = class extends Qn {
      static [ge] = "PgVarchar";
      length = this.config.length;
      enumValues = this.config.enumValues;
      getSQLType() {
        return this.length === void 0 ? "varchar" : `varchar(${this.length})`;
      }
    };
  function Mre(e, t = {}) {
    return new xre(e, t);
  }
  var zre = ii(),
    la = Vi("course_packs", {
      id: bt("id")
        .primaryKey()
        .$defaultFn(() => (0, zre.createId)()),
      order: ca("order").notNull(),
      title: bt("title").notNull(),
      description: bt("description").default(""),
      isFree: ej("is_free"),
      cover: bt("cover"),
      createdAt: dr("created_at").notNull().defaultNow(),
      updatedAt: dr("updated_at").$onUpdateFn(() => new Date()),
    }),
    tj = DS(la, ({ many: e }) => ({ courses: e(oi) })),
    Vre = ii(),
    Sl = Vi("statements", {
      id: bt("id")
        .primaryKey()
        .$defaultFn(() => (0, Vre.createId)()),
      order: ca("order").notNull(),
      chinese: bt("chinese").notNull(),
      english: bt("english").notNull(),
      soundmark: bt("soundmark").notNull(),
      courseId: bt("course_id")
        .notNull()
        .references(() => oi.id),
      createdAt: dr("created_at").notNull().defaultNow(),
      updatedAt: dr("updated_at").$onUpdateFn(() => new Date()),
    }),
    rj = DS(Sl, ({ one: e }) => ({
      course: e(oi, { fields: [Sl.courseId], references: [oi.id] }),
    })),
    oi = Vi("courses", {
      id: bt("id")
        .primaryKey()
        .$defaultFn(() => (0, nre.createId)()),
      title: Mre("title", { length: 256 }).notNull(),
      description: bt("description").default(""),
      video: bt("video").default(""),
      order: ca("order").notNull(),
      coursePackId: bt("course_pack_id")
        .notNull()
        .references(() => la.id),
      createdAt: dr("created_at").notNull().defaultNow(),
      updatedAt: dr("updated_at").$onUpdateFn(() => new Date()),
    }),
    nj = DS(oi, ({ one: e, many: t }) => ({
      statements: t(Sl),
      coursePack: e(la, { fields: [oi.coursePackId], references: [la.id] }),
    })),
    Ure = ii(),
    sj = Vi(
      "course_history",
      {
        id: bt("id")
          .primaryKey()
          .$defaultFn(() => (0, Ure.createId)()),
        userId: bt("user_id").notNull(),
        courseId: bt("course_id").notNull(),
        coursePackId: bt("course_pack_id").notNull(),
        completionCount: ca("completion_count").notNull(),
        createdAt: dr("created_at").notNull().defaultNow(),
        updatedAt: dr("updated_at").$onUpdateFn(() => new Date()),
      },
      (e) => ({ unq: CS().on(e.userId, e.courseId, e.coursePackId) }),
    ),
    Hre = ii(),
    ij = Vi("memberships", {
      id: bt("id")
        .primaryKey()
        .$defaultFn(() => (0, Hre.createId)()),
      userId: bt("user_id").notNull(),
      start_date: dr("start_date").notNull(),
      end_date: dr("end_date").notNull(),
      isActive: ej("isActive"),
      createdAt: dr("created_at").notNull().defaultNow(),
      updatedAt: dr("updated_at").$onUpdateFn(() => new Date()),
    }),
    Bre = ii(),
    oj = Vi(
      "user_course_progress",
      {
        id: bt("id")
          .primaryKey()
          .$defaultFn(() => (0, Bre.createId)()),
        userId: bt("user_id").notNull(),
        coursePackId: bt("course_pack_id").notNull(),
        courseId: bt("course_id").notNull(),
        statementIndex: ca("statement_index").notNull(),
        createdAt: dr("created_at").notNull().defaultNow(),
        updatedAt: dr("updated_at").$onUpdateFn(() => new Date()),
      },
      (e) => ({ unq: CS().on(e.userId, e.coursePackId) }),
    ),
    Kre = ii(),
    aj = Vi(
      "user_learn_record",
      {
        id: bt("id")
          .primaryKey()
          .$defaultFn(() => (0, Kre.createId)()),
        userId: bt("user_id").notNull(),
        count: ca("count").notNull().default(0),
        day: Nre("day").notNull(),
        createdAt: dr("created_at").notNull().defaultNow(),
        updatedAt: dr("updated_at").$onUpdateFn(() => new Date()),
      },
      (e) => ({ unq: CS().on(e.userId, e.day) }),
    ),
    Gre = {
      course: oi,
      statement: Sl,
      statementRelations: rj,
      membership: ij,
      userCourseProgress: oj,
      courseHistory: sj,
      userLearnRecord: aj,
      coursePack: la,
      courseRelations: nj,
      coursePackRelations: tj,
    };
});
var LS = require("path"),
  pj = Jr(YS()),
  mj = Jr(rv()),
  yj = Jr(gk());
var V = Symbol.for("drizzle:entityKind"),
  yue = Symbol.for("drizzle:hasOwnEntityKind");
function J(e, t) {
  if (!e || typeof e != "object") return !1;
  if (e instanceof t) return !0;
  if (!Object.prototype.hasOwnProperty.call(t, V))
    throw new Error(
      `Class "${t.name ?? "<unknown>"}" doesn't look like a Drizzle entity. If this is incorrect and the class is provided by Drizzle, please report this as a bug.`,
    );
  let r = e.constructor;
  if (r)
    for (; r; ) {
      if (V in r && r[V] === t[V]) return !0;
      r = Object.getPrototypeOf(r);
    }
  return !1;
}
var ot = class {
  constructor(t, r) {
    (this.table = t),
      (this.config = r),
      (this.name = r.name),
      (this.notNull = r.notNull),
      (this.default = r.default),
      (this.defaultFn = r.defaultFn),
      (this.onUpdateFn = r.onUpdateFn),
      (this.hasDefault = r.hasDefault),
      (this.primary = r.primaryKey),
      (this.isUnique = r.isUnique),
      (this.uniqueName = r.uniqueName),
      (this.uniqueType = r.uniqueType),
      (this.dataType = r.dataType),
      (this.columnType = r.columnType);
  }
  static [V] = "Column";
  name;
  primary;
  notNull;
  default;
  defaultFn;
  onUpdateFn;
  hasDefault;
  isUnique;
  uniqueName;
  uniqueType;
  dataType;
  columnType;
  enumValues = void 0;
  config;
  mapFromDriverValue(t) {
    return t;
  }
  mapToDriverValue(t) {
    return t;
  }
};
var Sd = class {
  static [V] = "ColumnBuilder";
  config;
  constructor(t, r, n) {
    this.config = {
      name: t,
      notNull: !1,
      default: void 0,
      hasDefault: !1,
      primaryKey: !1,
      isUnique: !1,
      uniqueName: void 0,
      uniqueType: void 0,
      dataType: r,
      columnType: n,
    };
  }
  $type() {
    return this;
  }
  notNull() {
    return (this.config.notNull = !0), this;
  }
  default(t) {
    return (this.config.default = t), (this.config.hasDefault = !0), this;
  }
  $defaultFn(t) {
    return (this.config.defaultFn = t), (this.config.hasDefault = !0), this;
  }
  $default = this.$defaultFn;
  $onUpdateFn(t) {
    return (this.config.onUpdateFn = t), (this.config.hasDefault = !0), this;
  }
  $onUpdate = this.$onUpdateFn;
  primaryKey() {
    return (this.config.primaryKey = !0), (this.config.notNull = !0), this;
  }
};
var vd = Symbol.for("drizzle:Name"),
  b_ = Symbol.for("drizzle:Schema"),
  _k = Symbol.for("drizzle:Columns"),
  w_ = Symbol.for("drizzle:OriginalName"),
  E_ = Symbol.for("drizzle:BaseName"),
  Sk = Symbol.for("drizzle:IsAlias"),
  vk = Symbol.for("drizzle:ExtraConfigBuilder"),
  bk = Symbol.for("drizzle:IsDrizzleTable"),
  se = class {
    static [V] = "Table";
    static Symbol = {
      Name: vd,
      Schema: b_,
      OriginalName: w_,
      Columns: _k,
      BaseName: E_,
      IsAlias: Sk,
      ExtraConfigBuilder: vk,
    };
    [vd];
    [w_];
    [b_];
    [_k];
    [E_];
    [Sk] = !1;
    [vk] = void 0;
    [bk] = !0;
    constructor(t, r, n) {
      (this[vd] = this[w_] = t), (this[b_] = r), (this[E_] = n);
    }
  };
function wk(e) {
  return typeof e == "object" && e !== null && bk in e;
}
function Zs(e) {
  return e[vd];
}
var Ek = Symbol.for("drizzle:PgInlineForeignKeys"),
  vr = class extends se {
    static [V] = "PgTable";
    static Symbol = Object.assign({}, se.Symbol, { InlineForeignKeys: Ek });
    [Ek] = [];
    [se.Symbol.ExtraConfigBuilder] = void 0;
  };
var bd = class {
    static [V] = "PgForeignKeyBuilder";
    reference;
    _onUpdate = "no action";
    _onDelete = "no action";
    constructor(t, r) {
      (this.reference = () => {
        let { name: n, columns: s, foreignColumns: i } = t();
        return { name: n, columns: s, foreignTable: i[0].table, foreignColumns: i };
      }),
        r && ((this._onUpdate = r.onUpdate), (this._onDelete = r.onDelete));
    }
    onUpdate(t) {
      return (this._onUpdate = t === void 0 ? "no action" : t), this;
    }
    onDelete(t) {
      return (this._onDelete = t === void 0 ? "no action" : t), this;
    }
    build(t) {
      return new R_(t, this);
    }
  },
  R_ = class {
    constructor(t, r) {
      (this.table = t),
        (this.reference = r.reference),
        (this.onUpdate = r._onUpdate),
        (this.onDelete = r._onDelete);
    }
    static [V] = "PgForeignKey";
    reference;
    onUpdate;
    onDelete;
    getName() {
      let { name: t, columns: r, foreignColumns: n } = this.reference(),
        s = r.map((a) => a.name),
        i = n.map((a) => a.name),
        o = [this.table[vr.Symbol.Name], ...s, n[0].table[vr.Symbol.Name], ...i];
      return t ?? `${o.join("_")}_fk`;
    }
  };
function wd(e, ...t) {
  return e(...t);
}
function $_(e, t) {
  return `${e[vr.Symbol.Name]}_${t.join("_")}_unique`;
}
var T_ = class {
    constructor(t, r) {
      (this.name = r), (this.columns = t);
    }
    static [V] = "PgUniqueConstraintBuilder";
    columns;
    nullsNotDistinctConfig = !1;
    nullsNotDistinct() {
      return (this.nullsNotDistinctConfig = !0), this;
    }
    build(t) {
      return new P_(t, this.columns, this.nullsNotDistinctConfig, this.name);
    }
  },
  Rk = class {
    static [V] = "PgUniqueOnConstraintBuilder";
    name;
    constructor(t) {
      this.name = t;
    }
    on(...t) {
      return new T_(t, this.name);
    }
  },
  P_ = class {
    constructor(t, r, n, s) {
      (this.table = t),
        (this.columns = r),
        (this.name =
          s ??
          $_(
            this.table,
            this.columns.map((i) => i.name),
          )),
        (this.nullsNotDistinct = n);
    }
    static [V] = "PgUniqueConstraint";
    columns;
    name;
    nullsNotDistinct = !1;
    getName() {
      return this.name;
    }
  };
function Tk(e, t, r) {
  for (let n = t; n < e.length; n++) {
    let s = e[n];
    if (s === "\\") {
      n++;
      continue;
    }
    if (s === '"') return [e.slice(t, n).replace(/\\/g, ""), n + 1];
    if (!r && (s === "," || s === "}")) return [e.slice(t, n).replace(/\\/g, ""), n];
  }
  return [e.slice(t).replace(/\\/g, ""), e.length];
}
function Pk(e, t = 0) {
  let r = [],
    n = t,
    s = !1;
  for (; n < e.length; ) {
    let i = e[n];
    if (i === ",") {
      (s || n === t) && r.push(""), (s = !0), n++;
      continue;
    }
    if (((s = !1), i === "\\")) {
      n += 2;
      continue;
    }
    if (i === '"') {
      let [u, l] = Tk(e, n + 1, !0);
      r.push(u), (n = l);
      continue;
    }
    if (i === "}") return [r, n + 1];
    if (i === "{") {
      let [u, l] = Pk(e, n + 1);
      r.push(u), (n = l);
      continue;
    }
    let [o, a] = Tk(e, n, !1);
    r.push(o), (n = a);
  }
  return [r, n];
}
function $k(e) {
  let [t] = Pk(e, 1);
  return t;
}
function O_(e) {
  return `{${e.map((t) => (Array.isArray(t) ? O_(t) : typeof t == "string" ? `"${t.replace(/\\/g, "\\\\").replace(/"/g, '\\"')}"` : `${t}`)).join(",")}}`;
}
var br = class extends Sd {
    foreignKeyConfigs = [];
    static [V] = "PgColumnBuilder";
    array(t) {
      return new N_(this.config.name, this, t);
    }
    references(t, r = {}) {
      return this.foreignKeyConfigs.push({ ref: t, actions: r }), this;
    }
    unique(t, r) {
      return (
        (this.config.isUnique = !0),
        (this.config.uniqueName = t),
        (this.config.uniqueType = r?.nulls),
        this
      );
    }
    buildForeignKeys(t, r) {
      return this.foreignKeyConfigs.map(({ ref: n, actions: s }) =>
        wd(
          (i, o) => {
            let a = new bd(() => {
              let u = i();
              return { columns: [t], foreignColumns: [u] };
            });
            return (
              o.onUpdate && a.onUpdate(o.onUpdate), o.onDelete && a.onDelete(o.onDelete), a.build(r)
            );
          },
          n,
          s,
        ),
      );
    }
  },
  vt = class extends ot {
    constructor(t, r) {
      r.uniqueName || (r.uniqueName = $_(t, [r.name])), super(t, r), (this.table = t);
    }
    static [V] = "PgColumn";
  },
  N_ = class extends br {
    static [V] = "PgArrayBuilder";
    constructor(t, r, n) {
      super(t, "array", "PgArray"), (this.config.baseBuilder = r), (this.config.size = n);
    }
    build(t) {
      let r = this.config.baseBuilder.build(t);
      return new A_(t, this.config, r);
    }
  },
  A_ = class e extends vt {
    constructor(t, r, n, s) {
      super(t, r), (this.baseColumn = n), (this.range = s), (this.size = r.size);
    }
    size;
    static [V] = "PgArray";
    getSQLType() {
      return `${this.baseColumn.getSQLType()}[${typeof this.size == "number" ? this.size : ""}]`;
    }
    mapFromDriverValue(t) {
      return (
        typeof t == "string" && (t = $k(t)), t.map((r) => this.baseColumn.mapFromDriverValue(r))
      );
    }
    mapToDriverValue(t, r = !1) {
      let n = t.map((s) =>
        s === null
          ? null
          : J(this.baseColumn, e)
            ? this.baseColumn.mapToDriverValue(s, !0)
            : this.baseColumn.mapToDriverValue(s),
      );
      return r ? n : O_(n);
    }
  };
var Ok = Symbol.for("drizzle:isPgEnum");
function Ak(e) {
  return !!e && typeof e == "function" && Ok in e && e[Ok] === !0;
}
var Nk = class extends br {
    static [V] = "PgEnumColumnBuilder";
    constructor(t, r) {
      super(t, "string", "PgEnumColumn"), (this.config.enum = r);
    }
    build(t) {
      return new I_(t, this.config);
    }
  },
  I_ = class extends vt {
    static [V] = "PgEnumColumn";
    enum = this.config.enum;
    enumValues = this.config.enum.enumValues;
    constructor(t, r) {
      super(t, r), (this.enum = r.enum);
    }
    getSQLType() {
      return this.enum.enumName;
    }
  };
var Ht = class {
    static [V] = "Subquery";
    constructor(t, r, n, s = !1) {
      this._ = { brand: "Subquery", sql: t, selectedFields: r, alias: n, isWith: s };
    }
  },
  Yo = class extends Ht {
    static [V] = "WithSubquery";
  };
var Ik = "0.30.10";
var C_,
  k_,
  at = {
    startActiveSpan(e, t) {
      return C_
        ? (k_ || (k_ = C_.trace.getTracer("drizzle-orm", Ik)),
          wd(
            (r, n) =>
              n.startActiveSpan(e, (s) => {
                try {
                  return t(s);
                } catch (i) {
                  throw (
                    (s.setStatus({
                      code: r.SpanStatusCode.ERROR,
                      message: i instanceof Error ? i.message : "Unknown error",
                    }),
                    i)
                  );
                } finally {
                  s.end();
                }
              }),
            C_,
            k_,
          ))
        : t();
    },
  };
var Tt = Symbol.for("drizzle:ViewBaseConfig");
var Ck = class {
  static [V] = "FakePrimitiveParam";
};
function D_(e) {
  return e != null && typeof e.getSQL == "function";
}
function Oee(e) {
  let t = { sql: "", params: [] };
  for (let r of e)
    (t.sql += r.sql),
      t.params.push(...r.params),
      r.typings?.length && (t.typings || (t.typings = []), t.typings.push(...r.typings));
  return t;
}
var Lt = class {
    static [V] = "StringChunk";
    value;
    constructor(t) {
      this.value = Array.isArray(t) ? t : [t];
    }
    getSQL() {
      return new de([this]);
    }
  },
  de = class e {
    constructor(t) {
      this.queryChunks = t;
    }
    static [V] = "SQL";
    decoder = Dk;
    shouldInlineParams = !1;
    append(t) {
      return this.queryChunks.push(...t.queryChunks), this;
    }
    toQuery(t) {
      return at.startActiveSpan("drizzle.buildSQL", (r) => {
        let n = this.buildQueryFromSourceParams(this.queryChunks, t);
        return (
          r?.setAttributes({
            "drizzle.query.text": n.sql,
            "drizzle.query.params": JSON.stringify(n.params),
          }),
          n
        );
      });
    }
    buildQueryFromSourceParams(t, r) {
      let n = Object.assign({}, r, {
          inlineParams: r.inlineParams || this.shouldInlineParams,
          paramStartIndex: r.paramStartIndex || { value: 0 },
        }),
        {
          escapeName: s,
          escapeParam: i,
          prepareTyping: o,
          inlineParams: a,
          paramStartIndex: u,
        } = n;
      return Oee(
        t.map((l) => {
          if (J(l, Lt)) return { sql: l.value.join(""), params: [] };
          if (J(l, Vu)) return { sql: s(l.value), params: [] };
          if (l === void 0) return { sql: "", params: [] };
          if (Array.isArray(l)) {
            let c = [new Lt("(")];
            for (let [f, d] of l.entries()) c.push(d), f < l.length - 1 && c.push(new Lt(", "));
            return c.push(new Lt(")")), this.buildQueryFromSourceParams(c, n);
          }
          if (J(l, e))
            return this.buildQueryFromSourceParams(l.queryChunks, {
              ...n,
              inlineParams: a || l.shouldInlineParams,
            });
          if (J(l, se)) {
            let c = l[se.Symbol.Schema],
              f = l[se.Symbol.Name];
            return { sql: c === void 0 ? s(f) : s(c) + "." + s(f), params: [] };
          }
          if (J(l, ot)) return { sql: s(l.table[se.Symbol.Name]) + "." + s(l.name), params: [] };
          if (J(l, wr)) {
            let c = l[Tt].schema,
              f = l[Tt].name;
            return { sql: c === void 0 ? s(f) : s(c) + "." + s(f), params: [] };
          }
          if (J(l, zr)) {
            let c = l.value === null ? null : l.encoder.mapToDriverValue(l.value);
            if (J(c, e)) return this.buildQueryFromSourceParams([c], n);
            if (a) return { sql: this.mapInlineParam(c, n), params: [] };
            let f;
            return (
              o !== void 0 && (f = [o(l.encoder)]),
              { sql: i(u.value++, c), params: [c], typings: f }
            );
          }
          return J(l, ji)
            ? { sql: i(u.value++, l), params: [l] }
            : J(l, e.Aliased) && l.fieldAlias !== void 0
              ? { sql: s(l.fieldAlias), params: [] }
              : J(l, Ht)
                ? l._.isWith
                  ? { sql: s(l._.alias), params: [] }
                  : this.buildQueryFromSourceParams(
                      [new Lt("("), l._.sql, new Lt(") "), new Vu(l._.alias)],
                      n,
                    )
                : Ak(l)
                  ? l.schema
                    ? { sql: s(l.schema) + "." + s(l.enumName), params: [] }
                    : { sql: s(l.enumName), params: [] }
                  : D_(l)
                    ? this.buildQueryFromSourceParams([new Lt("("), l.getSQL(), new Lt(")")], n)
                    : a
                      ? { sql: this.mapInlineParam(l, n), params: [] }
                      : { sql: i(u.value++, l), params: [l] };
        }),
      );
    }
    mapInlineParam(t, { escapeString: r }) {
      if (t === null) return "null";
      if (typeof t == "number" || typeof t == "boolean") return t.toString();
      if (typeof t == "string") return r(t);
      if (typeof t == "object") {
        let n = t.toString();
        return r(n === "[object Object]" ? JSON.stringify(t) : n);
      }
      throw new Error("Unexpected param value: " + t);
    }
    getSQL() {
      return this;
    }
    as(t) {
      return t === void 0 ? this : new e.Aliased(this, t);
    }
    mapWith(t) {
      return (this.decoder = typeof t == "function" ? { mapFromDriverValue: t } : t), this;
    }
    inlineParams() {
      return (this.shouldInlineParams = !0), this;
    }
    if(t) {
      return t ? this : void 0;
    }
  },
  Vu = class {
    constructor(t) {
      this.value = t;
    }
    static [V] = "Name";
    brand;
    getSQL() {
      return new de([this]);
    }
  };
function kk(e) {
  return (
    typeof e == "object" &&
    e !== null &&
    "mapToDriverValue" in e &&
    typeof e.mapToDriverValue == "function"
  );
}
var Dk = { mapFromDriverValue: (e) => e },
  qk = { mapToDriverValue: (e) => e },
  ole = { ...Dk, ...qk },
  zr = class {
    constructor(t, r = qk) {
      (this.value = t), (this.encoder = r);
    }
    static [V] = "Param";
    brand;
    getSQL() {
      return new de([this]);
    }
  };
function I(e, ...t) {
  let r = [];
  (t.length > 0 || (e.length > 0 && e[0] !== "")) && r.push(new Lt(e[0]));
  for (let [n, s] of t.entries()) r.push(s, new Lt(e[n + 1]));
  return new de(r);
}
((e) => {
  function t() {
    return new de([]);
  }
  e.empty = t;
  function r(u) {
    return new de(u);
  }
  e.fromList = r;
  function n(u) {
    return new de([new Lt(u)]);
  }
  e.raw = n;
  function s(u, l) {
    let c = [];
    for (let [f, d] of u.entries()) f > 0 && l !== void 0 && c.push(l), c.push(d);
    return new de(c);
  }
  e.join = s;
  function i(u) {
    return new Vu(u);
  }
  e.identifier = i;
  function o(u) {
    return new ji(u);
  }
  e.placeholder = o;
  function a(u, l) {
    return new zr(u, l);
  }
  e.param = a;
})(I || (I = {}));
((e) => {
  class t {
    constructor(n, s) {
      (this.sql = n), (this.fieldAlias = s);
    }
    static [V] = "SQL.Aliased";
    isSelectionField = !1;
    getSQL() {
      return this.sql;
    }
    clone() {
      return new t(this.sql, this.fieldAlias);
    }
  }
  e.Aliased = t;
})(de || (de = {}));
var ji = class {
  constructor(t) {
    this.name = t;
  }
  static [V] = "Placeholder";
  getSQL() {
    return new de([this]);
  }
};
function q_(e, t) {
  return e.map((r) => {
    if (J(r, ji)) {
      if (!(r.name in t)) throw new Error(`No value for placeholder "${r.name}" was provided`);
      return t[r.name];
    }
    return r;
  });
}
var wr = class {
  static [V] = "View";
  [Tt];
  constructor({ name: t, schema: r, selectedFields: n, query: s }) {
    this[Tt] = {
      name: t,
      originalName: t,
      schema: r,
      selectedFields: n,
      query: s,
      isExisting: !s,
      isAlias: !1,
    };
  }
  getSQL() {
    return new de([this]);
  }
};
ot.prototype.getSQL = function () {
  return new de([this]);
};
se.prototype.getSQL = function () {
  return new de([this]);
};
Ht.prototype.getSQL = function () {
  return new de([this]);
};
var Li = class {
    constructor(t) {
      this.table = t;
    }
    static [V] = "ColumnAliasProxyHandler";
    get(t, r) {
      return r === "table" ? this.table : t[r];
    }
  },
  Xo = class {
    constructor(t, r) {
      (this.alias = t), (this.replaceOriginalName = r);
    }
    static [V] = "TableAliasProxyHandler";
    get(t, r) {
      if (r === se.Symbol.IsAlias) return !0;
      if (r === se.Symbol.Name) return this.alias;
      if (this.replaceOriginalName && r === se.Symbol.OriginalName) return this.alias;
      if (r === Tt) return { ...t[Tt], name: this.alias, isAlias: !0 };
      if (r === se.Symbol.Columns) {
        let s = t[se.Symbol.Columns];
        if (!s) return s;
        let i = {};
        return (
          Object.keys(s).map((o) => {
            i[o] = new Proxy(s[o], new Li(new Proxy(t, this)));
          }),
          i
        );
      }
      let n = t[r];
      return J(n, ot) ? new Proxy(n, new Li(new Proxy(t, this))) : n;
    }
  },
  jk = class {
    constructor(t) {
      this.alias = t;
    }
    static [V] = "RelationTableAliasProxyHandler";
    get(t, r) {
      return r === "sourceTable" ? Uu(t.sourceTable, this.alias) : t[r];
    }
  };
function Uu(e, t) {
  return new Proxy(e, new Xo(t, !1));
}
function Kn(e, t) {
  return new Proxy(e, new Li(new Proxy(e.table, new Xo(t, !1))));
}
function j_(e, t) {
  return new de.Aliased(Hu(e.sql, t), e.fieldAlias);
}
function Hu(e, t) {
  return I.join(
    e.queryChunks.map((r) =>
      J(r, ot) ? Kn(r, t) : J(r, de) ? Hu(r, t) : J(r, de.Aliased) ? j_(r, t) : r,
    ),
  );
}
var Bu = class extends Error {
    static [V] = "DrizzleError";
    constructor({ message: t, cause: r }) {
      super(t), (this.name = "DrizzleError"), (this.cause = r);
    }
  },
  Ed = class extends Bu {
    static [V] = "TransactionRollbackError";
    constructor() {
      super({ message: "Rollback" });
    }
  };
function Dr(e, t) {
  return kk(t) && !D_(e) && !J(e, zr) && !J(e, ji) && !J(e, ot) && !J(e, se) && !J(e, wr)
    ? new zr(e, t)
    : e;
}
var Rd = (e, t) => I`${e} = ${Dr(t, e)}`,
  Lk = (e, t) => I`${e} <> ${Dr(t, e)}`;
function Ku(...e) {
  let t = e.filter((r) => r !== void 0);
  if (t.length !== 0)
    return t.length === 1
      ? new de(t)
      : new de([new Lt("("), I.join(t, new Lt(" and ")), new Lt(")")]);
}
function xk(...e) {
  let t = e.filter((r) => r !== void 0);
  if (t.length !== 0)
    return t.length === 1
      ? new de(t)
      : new de([new Lt("("), I.join(t, new Lt(" or ")), new Lt(")")]);
}
function Fk(e) {
  return I`not ${e}`;
}
var Mk = (e, t) => I`${e} > ${Dr(t, e)}`,
  zk = (e, t) => I`${e} >= ${Dr(t, e)}`,
  Vk = (e, t) => I`${e} < ${Dr(t, e)}`,
  Uk = (e, t) => I`${e} <= ${Dr(t, e)}`;
function Hk(e, t) {
  if (Array.isArray(t)) {
    if (t.length === 0) throw new Error("inArray requires at least one value");
    return I`${e} in ${t.map((r) => Dr(r, e))}`;
  }
  return I`${e} in ${Dr(t, e)}`;
}
function Bk(e, t) {
  if (Array.isArray(t)) {
    if (t.length === 0) throw new Error("notInArray requires at least one value");
    return I`${e} not in ${t.map((r) => Dr(r, e))}`;
  }
  return I`${e} not in ${Dr(t, e)}`;
}
function Kk(e) {
  return I`${e} is null`;
}
function Gk(e) {
  return I`${e} is not null`;
}
function Jk(e) {
  return I`exists ${e}`;
}
function Qk(e) {
  return I`not exists ${e}`;
}
function Wk(e, t, r) {
  return I`${e} between ${Dr(t, e)} and ${Dr(r, e)}`;
}
function Yk(e, t, r) {
  return I`${e} not between ${Dr(t, e)} and ${Dr(r, e)}`;
}
function Xk(e, t) {
  return I`${e} like ${t}`;
}
function Zk(e, t) {
  return I`${e} not like ${t}`;
}
function eD(e, t) {
  return I`${e} ilike ${t}`;
}
function tD(e, t) {
  return I`${e} not ilike ${t}`;
}
function rD(e) {
  return I`${e} asc`;
}
function nD(e) {
  return I`${e} desc`;
}
var L_ = class {
    static [V] = "ConsoleLogWriter";
    write(t) {
      console.log(t);
    }
  },
  Zo = class {
    static [V] = "DefaultLogger";
    writer;
    constructor(t) {
      this.writer = t?.writer ?? new L_();
    }
    logQuery(t, r) {
      let n = r.map((i) => {
          try {
            return JSON.stringify(i);
          } catch {
            return String(i);
          }
        }),
        s = n.length ? ` -- params: [${n.join(", ")}]` : "";
      this.writer.write(`Query: ${t}${s}`);
    }
  },
  Td = class {
    static [V] = "NoopLogger";
    logQuery() {}
  };
var lr = class {
  static [V] = "QueryPromise";
  [Symbol.toStringTag] = "QueryPromise";
  catch(t) {
    return this.then(void 0, t);
  }
  finally(t) {
    return this.then(
      (r) => (t?.(), r),
      (r) => {
        throw (t?.(), r);
      },
    );
  }
  then(t, r) {
    return this.execute().then(t, r);
  }
};
var Pd = class {
    static [V] = "PgPrimaryKeyBuilder";
    columns;
    name;
    constructor(t, r) {
      (this.columns = t), (this.name = r);
    }
    build(t) {
      return new x_(t, this.columns, this.name);
    }
  },
  x_ = class {
    constructor(t, r, n) {
      (this.table = t), (this.columns = r), (this.name = n);
    }
    static [V] = "PgPrimaryKey";
    columns;
    name;
    getName() {
      return (
        this.name ?? `${this.table[vr.Symbol.Name]}_${this.columns.map((t) => t.name).join("_")}_pk`
      );
    }
  };
var $d = class {
    constructor(t, r, n) {
      (this.sourceTable = t),
        (this.referencedTable = r),
        (this.relationName = n),
        (this.referencedTableName = r[se.Symbol.Name]);
    }
    static [V] = "Relation";
    referencedTableName;
    fieldName;
  },
  F_ = class {
    constructor(t, r) {
      (this.table = t), (this.config = r);
    }
    static [V] = "Relations";
  },
  ei = class e extends $d {
    constructor(t, r, n, s) {
      super(t, r, n?.relationName), (this.config = n), (this.isNullable = s);
    }
    static [V] = "One";
    withFieldName(t) {
      let r = new e(this.sourceTable, this.referencedTable, this.config, this.isNullable);
      return (r.fieldName = t), r;
    }
  },
  Gu = class e extends $d {
    constructor(t, r, n) {
      super(t, r, n?.relationName), (this.config = n);
    }
    static [V] = "Many";
    withFieldName(t) {
      let r = new e(this.sourceTable, this.referencedTable, this.config);
      return (r.fieldName = t), r;
    }
  };
function sD() {
  return {
    and: Ku,
    between: Wk,
    eq: Rd,
    exists: Jk,
    gt: Mk,
    gte: zk,
    ilike: eD,
    inArray: Hk,
    isNull: Kk,
    isNotNull: Gk,
    like: Xk,
    lt: Vk,
    lte: Uk,
    ne: Lk,
    not: Fk,
    notBetween: Yk,
    notExists: Qk,
    notLike: Zk,
    notIlike: tD,
    notInArray: Bk,
    or: xk,
    sql: I,
  };
}
function iD() {
  return { sql: I, asc: rD, desc: nD };
}
function oD(e, t) {
  Object.keys(e).length === 1 && "default" in e && !J(e.default, se) && (e = e.default);
  let r = {},
    n = {},
    s = {};
  for (let [i, o] of Object.entries(e))
    if (wk(o)) {
      let a = o[se.Symbol.Name],
        u = n[a];
      (r[a] = i),
        (s[i] = {
          tsName: i,
          dbName: o[se.Symbol.Name],
          schema: o[se.Symbol.Schema],
          columns: o[se.Symbol.Columns],
          relations: u?.relations ?? {},
          primaryKey: u?.primaryKey ?? [],
        });
      for (let c of Object.values(o[se.Symbol.Columns])) c.primary && s[i].primaryKey.push(c);
      let l = o[se.Symbol.ExtraConfigBuilder]?.(o);
      if (l) for (let c of Object.values(l)) J(c, Pd) && s[i].primaryKey.push(...c.columns);
    } else if (J(o, F_)) {
      let a = o.table[se.Symbol.Name],
        u = r[a],
        l = o.config(t(o.table)),
        c;
      for (let [f, d] of Object.entries(l))
        if (u) {
          let h = s[u];
          (h.relations[f] = d), c && h.primaryKey.push(...c);
        } else a in n || (n[a] = { relations: {}, primaryKey: c }), (n[a].relations[f] = d);
    }
  return { tables: s, tableNamesMap: r };
}
function Nee(e) {
  return function (r, n) {
    return new ei(e, r, n, n?.fields.reduce((s, i) => s && i.notNull, !0) ?? !1);
  };
}
function Aee(e) {
  return function (r, n) {
    return new Gu(e, r, n);
  };
}
function aD(e, t, r) {
  if (J(r, ei) && r.config) return { fields: r.config.fields, references: r.config.references };
  let n = t[r.referencedTable[se.Symbol.Name]];
  if (!n) throw new Error(`Table "${r.referencedTable[se.Symbol.Name]}" not found in schema`);
  let s = e[n];
  if (!s) throw new Error(`Table "${n}" not found in schema`);
  let i = r.sourceTable,
    o = t[i[se.Symbol.Name]];
  if (!o) throw new Error(`Table "${i[se.Symbol.Name]}" not found in schema`);
  let a = [];
  for (let u of Object.values(s.relations))
    ((r.relationName && r !== u && u.relationName === r.relationName) ||
      (!r.relationName && u.referencedTable === r.sourceTable)) &&
      a.push(u);
  if (a.length > 1)
    throw r.relationName
      ? new Error(`There are multiple relations with name "${r.relationName}" in table "${n}"`)
      : new Error(
          `There are multiple relations between "${n}" and "${r.sourceTable[se.Symbol.Name]}". Please specify relation name`,
        );
  if (a[0] && J(a[0], ei) && a[0].config)
    return { fields: a[0].config.references, references: a[0].config.fields };
  throw new Error(`There is not enough information to infer relation "${o}.${r.fieldName}"`);
}
function uD(e) {
  return { one: Nee(e), many: Aee(e) };
}
function Od(e, t, r, n, s = (i) => i) {
  let i = {};
  for (let [o, a] of n.entries())
    if (a.isJson) {
      let u = t.relations[a.tsKey],
        l = r[o],
        c = typeof l == "string" ? JSON.parse(l) : l;
      i[a.tsKey] = J(u, ei)
        ? c && Od(e, e[a.relationTableTsKey], c, a.selection, s)
        : c.map((f) => Od(e, e[a.relationTableTsKey], f, a.selection, s));
    } else {
      let u = s(r[o]),
        l = a.field,
        c;
      J(l, ot) ? (c = l) : J(l, de) ? (c = l.decoder) : (c = l.sql.decoder),
        (i[a.tsKey] = u === null ? null : c.mapFromDriverValue(u));
    }
  return i;
}
function lD(e, t, r) {
  let n = {},
    s = e.reduce((i, { path: o, field: a }, u) => {
      let l;
      J(a, ot) ? (l = a) : J(a, de) ? (l = a.decoder) : (l = a.sql.decoder);
      let c = i;
      for (let [f, d] of o.entries())
        if (f < o.length - 1) d in c || (c[d] = {}), (c = c[d]);
        else {
          let h = t[u],
            p = (c[d] = h === null ? null : l.mapFromDriverValue(h));
          if (r && J(a, ot) && o.length === 2) {
            let y = o[0];
            y in n
              ? typeof n[y] == "string" && n[y] !== Zs(a.table) && (n[y] = !1)
              : (n[y] = p === null ? Zs(a.table) : !1);
          }
        }
      return i;
    }, {});
  if (r && Object.keys(n).length > 0)
    for (let [i, o] of Object.entries(n)) typeof o == "string" && !r[o] && (s[i] = null);
  return s;
}
function ln(e, t) {
  return Object.entries(e).reduce((r, [n, s]) => {
    if (typeof n != "string") return r;
    let i = t ? [...t, n] : [n];
    return (
      J(s, ot) || J(s, de) || J(s, de.Aliased)
        ? r.push({ path: i, field: s })
        : J(s, se)
          ? r.push(...ln(s[se.Symbol.Columns], i))
          : r.push(...ln(s, i)),
      r
    );
  }, []);
}
function M_(e, t) {
  let r = Object.keys(e),
    n = Object.keys(t);
  if (r.length !== n.length) return !1;
  for (let [s, i] of r.entries()) if (i !== n[s]) return !1;
  return !0;
}
function Nd(e, t) {
  let r = Object.entries(t)
    .filter(([, n]) => n !== void 0)
    .map(([n, s]) => (J(s, de) ? [n, s] : [n, new zr(s, e[se.Symbol.Columns][n])]));
  if (r.length === 0) throw new Error("No values to set");
  return Object.fromEntries(r);
}
function cD(e, t) {
  for (let r of t)
    for (let n of Object.getOwnPropertyNames(r.prototype))
      n !== "constructor" &&
        Object.defineProperty(
          e.prototype,
          n,
          Object.getOwnPropertyDescriptor(r.prototype, n) || Object.create(null),
        );
}
function fD(e) {
  return e[se.Symbol.Columns];
}
function z_(e) {
  return J(e, Ht)
    ? e._.alias
    : J(e, wr)
      ? e[Tt].name
      : J(e, de)
        ? void 0
        : e[se.Symbol.IsAlias]
          ? e[se.Symbol.Name]
          : e[se.Symbol.BaseName];
}
var Ju = class extends lr {
  constructor(t, r, n, s) {
    super(), (this.session = r), (this.dialect = n), (this.config = { table: t, withList: s });
  }
  static [V] = "PgDelete";
  config;
  where(t) {
    return (this.config.where = t), this;
  }
  returning(t = this.config.table[se.Symbol.Columns]) {
    return (this.config.returning = ln(t)), this;
  }
  getSQL() {
    return this.dialect.buildDeleteQuery(this.config);
  }
  toSQL() {
    let { typings: t, ...r } = this.dialect.sqlToQuery(this.getSQL());
    return r;
  }
  _prepare(t) {
    return at.startActiveSpan("drizzle.prepareQuery", () =>
      this.session.prepareQuery(
        this.dialect.sqlToQuery(this.getSQL()),
        this.config.returning,
        t,
        !0,
      ),
    );
  }
  prepare(t) {
    return this._prepare(t);
  }
  execute = (t) => at.startActiveSpan("drizzle.operation", () => this._prepare().execute(t));
  $dynamic() {
    return this;
  }
};
var Qu = class {
    constructor(t, r, n, s) {
      (this.table = t), (this.session = r), (this.dialect = n), (this.withList = s);
    }
    static [V] = "PgInsertBuilder";
    values(t) {
      if (((t = Array.isArray(t) ? t : [t]), t.length === 0))
        throw new Error("values() must be called with at least one value");
      let r = t.map((n) => {
        let s = {},
          i = this.table[se.Symbol.Columns];
        for (let o of Object.keys(n)) {
          let a = n[o];
          s[o] = J(a, de) ? a : new zr(a, i[o]);
        }
        return s;
      });
      return new V_(this.table, r, this.session, this.dialect, this.withList);
    }
  },
  V_ = class extends lr {
    constructor(t, r, n, s, i) {
      super(),
        (this.session = n),
        (this.dialect = s),
        (this.config = { table: t, values: r, withList: i });
    }
    static [V] = "PgInsert";
    config;
    returning(t = this.config.table[se.Symbol.Columns]) {
      return (this.config.returning = ln(t)), this;
    }
    onConflictDoNothing(t = {}) {
      if (t.target === void 0) this.config.onConflict = I`do nothing`;
      else {
        let r = "";
        r = Array.isArray(t.target)
          ? t.target.map((s) => this.dialect.escapeName(s.name)).join(",")
          : this.dialect.escapeName(t.target.name);
        let n = t.where ? I` where ${t.where}` : void 0;
        this.config.onConflict = I`(${I.raw(r)})${n} do nothing`;
      }
      return this;
    }
    onConflictDoUpdate(t) {
      if (t.where && (t.targetWhere || t.setWhere))
        throw new Error(
          'You cannot use both "where" and "targetWhere"/"setWhere" at the same time - "where" is deprecated, use "targetWhere" or "setWhere" instead.',
        );
      let r = t.where ? I` where ${t.where}` : void 0,
        n = t.targetWhere ? I` where ${t.targetWhere}` : void 0,
        s = t.setWhere ? I` where ${t.setWhere}` : void 0,
        i = this.dialect.buildUpdateSet(this.config.table, Nd(this.config.table, t.set)),
        o = "";
      return (
        (o = Array.isArray(t.target)
          ? t.target.map((a) => this.dialect.escapeName(a.name)).join(",")
          : this.dialect.escapeName(t.target.name)),
        (this.config.onConflict = I`(${I.raw(o)})${n} do update set ${i}${r}${s}`),
        this
      );
    }
    getSQL() {
      return this.dialect.buildInsertQuery(this.config);
    }
    toSQL() {
      let { typings: t, ...r } = this.dialect.sqlToQuery(this.getSQL());
      return r;
    }
    _prepare(t) {
      return at.startActiveSpan("drizzle.prepareQuery", () =>
        this.session.prepareQuery(
          this.dialect.sqlToQuery(this.getSQL()),
          this.config.returning,
          t,
          !0,
        ),
      );
    }
    prepare(t) {
      return this._prepare(t);
    }
    execute = (t) => at.startActiveSpan("drizzle.operation", () => this._prepare().execute(t));
    $dynamic() {
      return this;
    }
  };
var Gn = class extends br {
  static [V] = "PgDateColumnBaseBuilder";
  defaultNow() {
    return this.default(I`now()`);
  }
};
var dD = class extends Gn {
    static [V] = "PgDateBuilder";
    constructor(t) {
      super(t, "date", "PgDate");
    }
    build(t) {
      return new Wu(t, this.config);
    }
  },
  Wu = class extends vt {
    static [V] = "PgDate";
    getSQLType() {
      return "date";
    }
    mapFromDriverValue(t) {
      return new Date(t);
    }
    mapToDriverValue(t) {
      return t.toISOString();
    }
  },
  hD = class extends Gn {
    static [V] = "PgDateStringBuilder";
    constructor(t) {
      super(t, "string", "PgDateString");
    }
    build(t) {
      return new Yu(t, this.config);
    }
  },
  Yu = class extends vt {
    static [V] = "PgDateString";
    getSQLType() {
      return "date";
    }
  };
var pD = class extends br {
    static [V] = "PgJsonBuilder";
    constructor(t) {
      super(t, "json", "PgJson");
    }
    build(t) {
      return new Xu(t, this.config);
    }
  },
  Xu = class extends vt {
    static [V] = "PgJson";
    constructor(t, r) {
      super(t, r);
    }
    getSQLType() {
      return "json";
    }
    mapToDriverValue(t) {
      return JSON.stringify(t);
    }
    mapFromDriverValue(t) {
      if (typeof t == "string")
        try {
          return JSON.parse(t);
        } catch {
          return t;
        }
      return t;
    }
  };
var mD = class extends br {
    static [V] = "PgJsonbBuilder";
    constructor(t) {
      super(t, "json", "PgJsonb");
    }
    build(t) {
      return new Zu(t, this.config);
    }
  },
  Zu = class extends vt {
    static [V] = "PgJsonb";
    constructor(t, r) {
      super(t, r);
    }
    getSQLType() {
      return "jsonb";
    }
    mapToDriverValue(t) {
      return JSON.stringify(t);
    }
    mapFromDriverValue(t) {
      if (typeof t == "string")
        try {
          return JSON.parse(t);
        } catch {
          return t;
        }
      return t;
    }
  };
var yD = class extends br {
    static [V] = "PgNumericBuilder";
    constructor(t, r, n) {
      super(t, "string", "PgNumeric"), (this.config.precision = r), (this.config.scale = n);
    }
    build(t) {
      return new el(t, this.config);
    }
  },
  el = class extends vt {
    static [V] = "PgNumeric";
    precision;
    scale;
    constructor(t, r) {
      super(t, r), (this.precision = r.precision), (this.scale = r.scale);
    }
    getSQLType() {
      return this.precision !== void 0 && this.scale !== void 0
        ? `numeric(${this.precision}, ${this.scale})`
        : this.precision === void 0
          ? "numeric"
          : `numeric(${this.precision})`;
    }
  };
var gD = class extends Gn {
    constructor(t, r, n) {
      super(t, "string", "PgTime"),
        (this.withTimezone = r),
        (this.precision = n),
        (this.config.withTimezone = r),
        (this.config.precision = n);
    }
    static [V] = "PgTimeBuilder";
    build(t) {
      return new tl(t, this.config);
    }
  },
  tl = class extends vt {
    static [V] = "PgTime";
    withTimezone;
    precision;
    constructor(t, r) {
      super(t, r), (this.withTimezone = r.withTimezone), (this.precision = r.precision);
    }
    getSQLType() {
      return `time${this.precision === void 0 ? "" : `(${this.precision})`}${this.withTimezone ? " with time zone" : ""}`;
    }
  };
var _D = class extends Gn {
    static [V] = "PgTimestampBuilder";
    constructor(t, r, n) {
      super(t, "date", "PgTimestamp"), (this.config.withTimezone = r), (this.config.precision = n);
    }
    build(t) {
      return new rl(t, this.config);
    }
  },
  rl = class extends vt {
    static [V] = "PgTimestamp";
    withTimezone;
    precision;
    constructor(t, r) {
      super(t, r), (this.withTimezone = r.withTimezone), (this.precision = r.precision);
    }
    getSQLType() {
      return `timestamp${this.precision === void 0 ? "" : ` (${this.precision})`}${this.withTimezone ? " with time zone" : ""}`;
    }
    mapFromDriverValue = (t) => new Date(this.withTimezone ? t : t + "+0000");
    mapToDriverValue = (t) => t.toISOString();
  },
  SD = class extends Gn {
    static [V] = "PgTimestampStringBuilder";
    constructor(t, r, n) {
      super(t, "string", "PgTimestampString"),
        (this.config.withTimezone = r),
        (this.config.precision = n);
    }
    build(t) {
      return new nl(t, this.config);
    }
  },
  nl = class extends vt {
    static [V] = "PgTimestampString";
    withTimezone;
    precision;
    constructor(t, r) {
      super(t, r), (this.withTimezone = r.withTimezone), (this.precision = r.precision);
    }
    getSQLType() {
      return `timestamp${this.precision === void 0 ? "" : `(${this.precision})`}${this.withTimezone ? " with time zone" : ""}`;
    }
  };
var vD = class extends br {
    static [V] = "PgUUIDBuilder";
    constructor(t) {
      super(t, "string", "PgUUID");
    }
    defaultRandom() {
      return this.default(I`gen_random_uuid()`);
    }
    build(t) {
      return new sl(t, this.config);
    }
  },
  sl = class extends vt {
    static [V] = "PgUUID";
    getSQLType() {
      return "uuid";
    }
  };
var ea = class extends wr {
  static [V] = "PgViewBase";
};
var ta = class {
  static [V] = "PgDialect";
  async migrate(t, r, n) {
    let s =
        typeof n == "string" ? "__drizzle_migrations" : n.migrationsTable ?? "__drizzle_migrations",
      i = typeof n == "string" ? "drizzle" : n.migrationsSchema ?? "drizzle",
      o = I`
			CREATE TABLE IF NOT EXISTS ${I.identifier(i)}.${I.identifier(s)} (
				id SERIAL PRIMARY KEY,
				hash text NOT NULL,
				created_at bigint
			)
		`;
    await r.execute(I`CREATE SCHEMA IF NOT EXISTS ${I.identifier(i)}`), await r.execute(o);
    let u = (
      await r.all(
        I`select id, hash, created_at from ${I.identifier(i)}.${I.identifier(s)} order by created_at desc limit 1`,
      )
    )[0];
    await r.transaction(async (l) => {
      for await (let c of t)
        if (!u || Number(u.created_at) < c.folderMillis) {
          for (let f of c.sql) await l.execute(I.raw(f));
          await l.execute(
            I`insert into ${I.identifier(i)}.${I.identifier(s)} ("hash", "created_at") values(${c.hash}, ${c.folderMillis})`,
          );
        }
    });
  }
  escapeName(t) {
    return `"${t}"`;
  }
  escapeParam(t) {
    return `$${t + 1}`;
  }
  escapeString(t) {
    return `'${t.replace(/'/g, "''")}'`;
  }
  buildWithCTE(t) {
    if (!t?.length) return;
    let r = [I`with `];
    for (let [n, s] of t.entries())
      r.push(I`${I.identifier(s._.alias)} as (${s._.sql})`), n < t.length - 1 && r.push(I`, `);
    return r.push(I` `), I.join(r);
  }
  buildDeleteQuery({ table: t, where: r, returning: n, withList: s }) {
    let i = this.buildWithCTE(s),
      o = n ? I` returning ${this.buildSelection(n, { isSingleTable: !0 })}` : void 0,
      a = r ? I` where ${r}` : void 0;
    return I`${i}delete from ${t}${a}${o}`;
  }
  buildUpdateSet(t, r) {
    let n = t[se.Symbol.Columns],
      s = Object.keys(n).filter((o) => r[o] !== void 0 || n[o]?.onUpdateFn !== void 0),
      i = s.length;
    return I.join(
      s.flatMap((o, a) => {
        let u = n[o],
          l = r[o] ?? I.param(u.onUpdateFn(), u),
          c = I`${I.identifier(u.name)} = ${l}`;
        return a < i - 1 ? [c, I.raw(", ")] : [c];
      }),
    );
  }
  buildUpdateQuery({ table: t, set: r, where: n, returning: s, withList: i }) {
    let o = this.buildWithCTE(i),
      a = this.buildUpdateSet(t, r),
      u = s ? I` returning ${this.buildSelection(s, { isSingleTable: !0 })}` : void 0,
      l = n ? I` where ${n}` : void 0;
    return I`${o}update ${t} set ${a}${l}${u}`;
  }
  buildSelection(t, { isSingleTable: r = !1 } = {}) {
    let n = t.length,
      s = t.flatMap(({ field: i }, o) => {
        let a = [];
        if (J(i, de.Aliased) && i.isSelectionField) a.push(I.identifier(i.fieldAlias));
        else if (J(i, de.Aliased) || J(i, de)) {
          let u = J(i, de.Aliased) ? i.sql : i;
          r
            ? a.push(new de(u.queryChunks.map((l) => (J(l, vt) ? I.identifier(l.name) : l))))
            : a.push(u),
            J(i, de.Aliased) && a.push(I` as ${I.identifier(i.fieldAlias)}`);
        } else J(i, ot) && (r ? a.push(I.identifier(i.name)) : a.push(i));
        return o < n - 1 && a.push(I`, `), a;
      });
    return I.join(s);
  }
  buildSelectQuery({
    withList: t,
    fields: r,
    fieldsFlat: n,
    where: s,
    having: i,
    table: o,
    joins: a,
    orderBy: u,
    groupBy: l,
    limit: c,
    offset: f,
    lockingClause: d,
    distinct: h,
    setOperators: p,
  }) {
    let y = n ?? ln(r);
    for (let Z of y)
      if (
        J(Z.field, ot) &&
        Zs(Z.field.table) !==
          (J(o, Ht) ? o._.alias : J(o, ea) ? o[Tt].name : J(o, de) ? void 0 : Zs(o)) &&
        !((G) =>
          a?.some(({ alias: Y }) => Y === (G[se.Symbol.IsAlias] ? Zs(G) : G[se.Symbol.BaseName])))(
          Z.field.table,
        )
      ) {
        let G = Zs(Z.field.table);
        throw new Error(
          `Your "${Z.path.join("->")}" field references a column "${G}"."${Z.field.name}", but the table "${G}" is not part of the query! Did you forget to join it?`,
        );
      }
    let _ = !a || a.length === 0,
      S = this.buildWithCTE(t),
      E;
    h && (E = h === !0 ? I` distinct` : I` distinct on (${I.join(h.on, I`, `)})`);
    let g = this.buildSelection(y, { isSingleTable: _ }),
      m = (() => {
        if (J(o, se) && o[se.Symbol.OriginalName] !== o[se.Symbol.Name]) {
          let Z = I`${I.identifier(o[se.Symbol.OriginalName])}`;
          return (
            o[se.Symbol.Schema] && (Z = I`${I.identifier(o[se.Symbol.Schema])}.${Z}`),
            I`${Z} ${I.identifier(o[se.Symbol.Name])}`
          );
        }
        return o;
      })(),
      T = [];
    if (a)
      for (let [Z, G] of a.entries()) {
        Z === 0 && T.push(I` `);
        let Y = G.table,
          U = G.lateral ? I` lateral` : void 0;
        if (J(Y, vr)) {
          let z = Y[vr.Symbol.Name],
            oe = Y[vr.Symbol.Schema],
            Te = Y[vr.Symbol.OriginalName],
            ce = z === Te ? void 0 : G.alias;
          T.push(
            I`${I.raw(G.joinType)} join${U} ${oe ? I`${I.identifier(oe)}.` : void 0}${I.identifier(Te)}${ce && I` ${I.identifier(ce)}`} on ${G.on}`,
          );
        } else if (J(Y, wr)) {
          let z = Y[Tt].name,
            oe = Y[Tt].schema,
            Te = Y[Tt].originalName,
            ce = z === Te ? void 0 : G.alias;
          T.push(
            I`${I.raw(G.joinType)} join${U} ${oe ? I`${I.identifier(oe)}.` : void 0}${I.identifier(Te)}${ce && I` ${I.identifier(ce)}`} on ${G.on}`,
          );
        } else T.push(I`${I.raw(G.joinType)} join${U} ${Y} on ${G.on}`);
        Z < a.length - 1 && T.push(I` `);
      }
    let N = I.join(T),
      w = s ? I` where ${s}` : void 0,
      $ = i ? I` having ${i}` : void 0,
      D;
    u && u.length > 0 && (D = I` order by ${I.join(u, I`, `)}`);
    let v;
    l && l.length > 0 && (v = I` group by ${I.join(l, I`, `)}`);
    let M = c ? I` limit ${c}` : void 0,
      k = f ? I` offset ${f}` : void 0,
      x = I.empty();
    if (d) {
      let Z = I` for ${I.raw(d.strength)}`;
      d.config.of &&
        Z.append(I` of ${I.join(Array.isArray(d.config.of) ? d.config.of : [d.config.of], I`, `)}`),
        d.config.noWait ? Z.append(I` no wait`) : d.config.skipLocked && Z.append(I` skip locked`),
        x.append(Z);
    }
    let ie = I`${S}select${E} ${g} from ${m}${N}${w}${v}${$}${D}${M}${k}${x}`;
    return p.length > 0 ? this.buildSetOperations(ie, p) : ie;
  }
  buildSetOperations(t, r) {
    let [n, ...s] = r;
    if (!n) throw new Error("Cannot pass undefined values to any set operator");
    return s.length === 0
      ? this.buildSetOperationQuery({ leftSelect: t, setOperator: n })
      : this.buildSetOperations(this.buildSetOperationQuery({ leftSelect: t, setOperator: n }), s);
  }
  buildSetOperationQuery({
    leftSelect: t,
    setOperator: { type: r, isAll: n, rightSelect: s, limit: i, orderBy: o, offset: a },
  }) {
    let u = I`(${t.getSQL()}) `,
      l = I`(${s.getSQL()})`,
      c;
    if (o && o.length > 0) {
      let p = [];
      for (let y of o)
        if (J(y, vt)) p.push(I.identifier(y.name));
        else if (J(y, de)) {
          for (let _ = 0; _ < y.queryChunks.length; _++) {
            let S = y.queryChunks[_];
            J(S, vt) && (y.queryChunks[_] = I.identifier(S.name));
          }
          p.push(I`${y}`);
        } else p.push(I`${y}`);
      c = I` order by ${I.join(p, I`, `)} `;
    }
    let f = i ? I` limit ${i}` : void 0,
      d = I.raw(`${r} ${n ? "all " : ""}`),
      h = a ? I` offset ${a}` : void 0;
    return I`${u}${d}${l}${c}${f}${h}`;
  }
  buildInsertQuery({ table: t, values: r, onConflict: n, returning: s, withList: i }) {
    let o = [],
      a = t[se.Symbol.Columns],
      u = Object.entries(a),
      l = u.map(([, p]) => I.identifier(p.name));
    for (let [p, y] of r.entries()) {
      let _ = [];
      for (let [S, E] of u) {
        let g = y[S];
        if (g === void 0 || (J(g, zr) && g.value === void 0))
          if (E.defaultFn !== void 0) {
            let m = E.defaultFn(),
              T = J(m, de) ? m : I.param(m, E);
            _.push(T);
          } else if (!E.default && E.onUpdateFn !== void 0) {
            let m = E.onUpdateFn(),
              T = J(m, de) ? m : I.param(m, E);
            _.push(T);
          } else _.push(I`default`);
        else _.push(g);
      }
      o.push(_), p < r.length - 1 && o.push(I`, `);
    }
    let c = this.buildWithCTE(i),
      f = I.join(o),
      d = s ? I` returning ${this.buildSelection(s, { isSingleTable: !0 })}` : void 0,
      h = n ? I` on conflict ${n}` : void 0;
    return I`${c}insert into ${t} ${l} values ${f}${h}${d}`;
  }
  buildRefreshMaterializedViewQuery({ view: t, concurrently: r, withNoData: n }) {
    let s = r ? I` concurrently` : void 0,
      i = n ? I` with no data` : void 0;
    return I`refresh materialized view${s} ${t}${i}`;
  }
  prepareTyping(t) {
    return J(t, Zu) || J(t, Xu)
      ? "json"
      : J(t, el)
        ? "decimal"
        : J(t, tl)
          ? "time"
          : J(t, rl) || J(t, nl)
            ? "timestamp"
            : J(t, Wu) || J(t, Yu)
              ? "date"
              : J(t, sl)
                ? "uuid"
                : "none";
  }
  sqlToQuery(t) {
    return t.toQuery({
      escapeName: this.escapeName,
      escapeParam: this.escapeParam,
      escapeString: this.escapeString,
      prepareTyping: this.prepareTyping,
    });
  }
  buildRelationalQueryWithoutPK({
    fullSchema: t,
    schema: r,
    tableNamesMap: n,
    table: s,
    tableConfig: i,
    queryConfig: o,
    tableAlias: a,
    nestedQueryRelation: u,
    joinOn: l,
  }) {
    let c = [],
      f,
      d,
      h = [],
      p,
      y = [];
    if (o === !0)
      c = Object.entries(i.columns).map(([E, g]) => ({
        dbKey: g.name,
        tsKey: E,
        field: Kn(g, a),
        relationTableTsKey: void 0,
        isJson: !1,
        selection: [],
      }));
    else {
      let S = Object.fromEntries(Object.entries(i.columns).map(([w, $]) => [w, Kn($, a)]));
      if (o.where) {
        let w = typeof o.where == "function" ? o.where(S, sD()) : o.where;
        p = w && Hu(w, a);
      }
      let E = [],
        g = [];
      if (o.columns) {
        let w = !1;
        for (let [$, D] of Object.entries(o.columns))
          D !== void 0 && $ in i.columns && (!w && D === !0 && (w = !0), g.push($));
        g.length > 0 &&
          (g = w
            ? g.filter(($) => o.columns?.[$] === !0)
            : Object.keys(i.columns).filter(($) => !g.includes($)));
      } else g = Object.keys(i.columns);
      for (let w of g) {
        let $ = i.columns[w];
        E.push({ tsKey: w, value: $ });
      }
      let m = [];
      o.with &&
        (m = Object.entries(o.with)
          .filter((w) => !!w[1])
          .map(([w, $]) => ({ tsKey: w, queryConfig: $, relation: i.relations[w] })));
      let T;
      if (o.extras) {
        T = typeof o.extras == "function" ? o.extras(S, { sql: I }) : o.extras;
        for (let [w, $] of Object.entries(T)) E.push({ tsKey: w, value: j_($, a) });
      }
      for (let { tsKey: w, value: $ } of E)
        c.push({
          dbKey: J($, de.Aliased) ? $.fieldAlias : i.columns[w].name,
          tsKey: w,
          field: J($, ot) ? Kn($, a) : $,
          relationTableTsKey: void 0,
          isJson: !1,
          selection: [],
        });
      let N = typeof o.orderBy == "function" ? o.orderBy(S, iD()) : o.orderBy ?? [];
      Array.isArray(N) || (N = [N]),
        (h = N.map((w) => (J(w, ot) ? Kn(w, a) : Hu(w, a)))),
        (f = o.limit),
        (d = o.offset);
      for (let { tsKey: w, queryConfig: $, relation: D } of m) {
        let v = aD(r, n, D),
          M = D.referencedTable[se.Symbol.Name],
          k = n[M],
          x = `${a}_${w}`,
          ie = Ku(...v.fields.map((Y, U) => Rd(Kn(v.references[U], x), Kn(Y, a)))),
          Z = this.buildRelationalQueryWithoutPK({
            fullSchema: t,
            schema: r,
            tableNamesMap: n,
            table: t[k],
            tableConfig: r[k],
            queryConfig: J(D, ei) ? ($ === !0 ? { limit: 1 } : { ...$, limit: 1 }) : $,
            tableAlias: x,
            joinOn: ie,
            nestedQueryRelation: D,
          }),
          G = I`${I.identifier(x)}.${I.identifier("data")}`.as(w);
        y.push({
          on: I`true`,
          table: new Ht(Z.sql, {}, x),
          alias: x,
          joinType: "left",
          lateral: !0,
        }),
          c.push({
            dbKey: w,
            tsKey: w,
            field: G,
            relationTableTsKey: k,
            isJson: !0,
            selection: Z.selection,
          });
      }
    }
    if (c.length === 0)
      throw new Bu({ message: `No fields selected for table "${i.tsName}" ("${a}")` });
    let _;
    if (((p = Ku(l, p)), u)) {
      let S = I`json_build_array(${I.join(
        c.map(({ field: m, tsKey: T, isJson: N }) =>
          N
            ? I`${I.identifier(`${a}_${T}`)}.${I.identifier("data")}`
            : J(m, de.Aliased)
              ? m.sql
              : m,
        ),
        I`, `,
      )})`;
      J(u, Gu) &&
        (S = I`coalesce(json_agg(${S}${h.length > 0 ? I` order by ${I.join(h, I`, `)}` : void 0}), '[]'::json)`);
      let E = [
        {
          dbKey: "data",
          tsKey: "data",
          field: S.as("data"),
          isJson: !0,
          relationTableTsKey: i.tsName,
          selection: c,
        },
      ];
      f !== void 0 || d !== void 0 || h.length > 0
        ? ((_ = this.buildSelectQuery({
            table: Uu(s, a),
            fields: {},
            fieldsFlat: [{ path: [], field: I.raw("*") }],
            where: p,
            limit: f,
            offset: d,
            orderBy: h,
            setOperators: [],
          })),
          (p = void 0),
          (f = void 0),
          (d = void 0),
          (h = []))
        : (_ = Uu(s, a)),
        (_ = this.buildSelectQuery({
          table: J(_, vr) ? _ : new Ht(_, {}, a),
          fields: {},
          fieldsFlat: E.map(({ field: m }) => ({ path: [], field: J(m, ot) ? Kn(m, a) : m })),
          joins: y,
          where: p,
          limit: f,
          offset: d,
          orderBy: h,
          setOperators: [],
        }));
    } else
      _ = this.buildSelectQuery({
        table: Uu(s, a),
        fields: {},
        fieldsFlat: c.map(({ field: S }) => ({ path: [], field: J(S, ot) ? Kn(S, a) : S })),
        joins: y,
        where: p,
        limit: f,
        offset: d,
        orderBy: h,
        setOperators: [],
      });
    return { tableTsKey: i.tsName, sql: _, selection: c };
  }
};
var qr = class e {
  static [V] = "SelectionProxyHandler";
  config;
  constructor(t) {
    this.config = { ...t };
  }
  get(t, r) {
    if (r === "_") return { ...t._, selectedFields: new Proxy(t._.selectedFields, this) };
    if (r === Tt) return { ...t[Tt], selectedFields: new Proxy(t[Tt].selectedFields, this) };
    if (typeof r == "symbol") return t[r];
    let s = (J(t, Ht) ? t._.selectedFields : J(t, wr) ? t[Tt].selectedFields : t)[r];
    if (J(s, de.Aliased)) {
      if (this.config.sqlAliasedBehavior === "sql" && !s.isSelectionField) return s.sql;
      let i = s.clone();
      return (i.isSelectionField = !0), i;
    }
    if (J(s, de)) {
      if (this.config.sqlBehavior === "sql") return s;
      throw new Error(
        `You tried to reference "${r}" field from a subquery, which is a raw SQL field, but it doesn't have an alias declared. Please add an alias to the field using ".as('alias')" method.`,
      );
    }
    return J(s, ot)
      ? this.config.alias
        ? new Proxy(
            s,
            new Li(
              new Proxy(s.table, new Xo(this.config.alias, this.config.replaceOriginalName ?? !1)),
            ),
          )
        : s
      : typeof s != "object" || s === null
        ? s
        : new Proxy(s, new e(this.config));
  }
};
var Ad = class {
  static [V] = "TypedQueryBuilder";
  getSelectedFields() {
    return this._.selectedFields;
  }
};
var cr = class {
    static [V] = "PgSelectBuilder";
    fields;
    session;
    dialect;
    withList = [];
    distinct;
    constructor(t) {
      (this.fields = t.fields),
        (this.session = t.session),
        (this.dialect = t.dialect),
        t.withList && (this.withList = t.withList),
        (this.distinct = t.distinct);
    }
    from(t) {
      let r = !!this.fields,
        n;
      return (
        this.fields
          ? (n = this.fields)
          : J(t, Ht)
            ? (n = Object.fromEntries(Object.keys(t._.selectedFields).map((s) => [s, t[s]])))
            : J(t, ea)
              ? (n = t[Tt].selectedFields)
              : J(t, de)
                ? (n = {})
                : (n = fD(t)),
        new Id({
          table: t,
          fields: n,
          isPartialSelect: r,
          session: this.session,
          dialect: this.dialect,
          withList: this.withList,
          distinct: this.distinct,
        })
      );
    }
  },
  U_ = class extends Ad {
    static [V] = "PgSelectQueryBuilder";
    _;
    config;
    joinsNotNullableMap;
    tableName;
    isPartialSelect;
    session;
    dialect;
    constructor({
      table: t,
      fields: r,
      isPartialSelect: n,
      session: s,
      dialect: i,
      withList: o,
      distinct: a,
    }) {
      super(),
        (this.config = { withList: o, table: t, fields: { ...r }, distinct: a, setOperators: [] }),
        (this.isPartialSelect = n),
        (this.session = s),
        (this.dialect = i),
        (this._ = { selectedFields: r }),
        (this.tableName = z_(t)),
        (this.joinsNotNullableMap =
          typeof this.tableName == "string" ? { [this.tableName]: !0 } : {});
    }
    createJoin(t) {
      return (r, n) => {
        let s = this.tableName,
          i = z_(r);
        if (typeof i == "string" && this.config.joins?.some((o) => o.alias === i))
          throw new Error(`Alias "${i}" is already used in this query`);
        if (
          !this.isPartialSelect &&
          (Object.keys(this.joinsNotNullableMap).length === 1 &&
            typeof s == "string" &&
            (this.config.fields = { [s]: this.config.fields }),
          typeof i == "string" && !J(r, de))
        ) {
          let o = J(r, Ht)
            ? r._.selectedFields
            : J(r, wr)
              ? r[Tt].selectedFields
              : r[se.Symbol.Columns];
          this.config.fields[i] = o;
        }
        if (
          (typeof n == "function" &&
            (n = n(
              new Proxy(
                this.config.fields,
                new qr({ sqlAliasedBehavior: "sql", sqlBehavior: "sql" }),
              ),
            )),
          this.config.joins || (this.config.joins = []),
          this.config.joins.push({ on: n, table: r, joinType: t, alias: i }),
          typeof i == "string")
        )
          switch (t) {
            case "left": {
              this.joinsNotNullableMap[i] = !1;
              break;
            }
            case "right": {
              (this.joinsNotNullableMap = Object.fromEntries(
                Object.entries(this.joinsNotNullableMap).map(([o]) => [o, !1]),
              )),
                (this.joinsNotNullableMap[i] = !0);
              break;
            }
            case "inner": {
              this.joinsNotNullableMap[i] = !0;
              break;
            }
            case "full": {
              (this.joinsNotNullableMap = Object.fromEntries(
                Object.entries(this.joinsNotNullableMap).map(([o]) => [o, !1]),
              )),
                (this.joinsNotNullableMap[i] = !1);
              break;
            }
          }
        return this;
      };
    }
    leftJoin = this.createJoin("left");
    rightJoin = this.createJoin("right");
    innerJoin = this.createJoin("inner");
    fullJoin = this.createJoin("full");
    createSetOperator(t, r) {
      return (n) => {
        let s = typeof n == "function" ? n(Iee()) : n;
        if (!M_(this.getSelectedFields(), s.getSelectedFields()))
          throw new Error(
            "Set operator error (union / intersect / except): selected fields are not the same or are in a different order",
          );
        return this.config.setOperators.push({ type: t, isAll: r, rightSelect: s }), this;
      };
    }
    union = this.createSetOperator("union", !1);
    unionAll = this.createSetOperator("union", !0);
    intersect = this.createSetOperator("intersect", !1);
    intersectAll = this.createSetOperator("intersect", !0);
    except = this.createSetOperator("except", !1);
    exceptAll = this.createSetOperator("except", !0);
    addSetOperators(t) {
      return this.config.setOperators.push(...t), this;
    }
    where(t) {
      return (
        typeof t == "function" &&
          (t = t(
            new Proxy(
              this.config.fields,
              new qr({ sqlAliasedBehavior: "sql", sqlBehavior: "sql" }),
            ),
          )),
        (this.config.where = t),
        this
      );
    }
    having(t) {
      return (
        typeof t == "function" &&
          (t = t(
            new Proxy(
              this.config.fields,
              new qr({ sqlAliasedBehavior: "sql", sqlBehavior: "sql" }),
            ),
          )),
        (this.config.having = t),
        this
      );
    }
    groupBy(...t) {
      if (typeof t[0] == "function") {
        let r = t[0](
          new Proxy(
            this.config.fields,
            new qr({ sqlAliasedBehavior: "alias", sqlBehavior: "sql" }),
          ),
        );
        this.config.groupBy = Array.isArray(r) ? r : [r];
      } else this.config.groupBy = t;
      return this;
    }
    orderBy(...t) {
      if (typeof t[0] == "function") {
        let r = t[0](
            new Proxy(
              this.config.fields,
              new qr({ sqlAliasedBehavior: "alias", sqlBehavior: "sql" }),
            ),
          ),
          n = Array.isArray(r) ? r : [r];
        this.config.setOperators.length > 0
          ? (this.config.setOperators.at(-1).orderBy = n)
          : (this.config.orderBy = n);
      } else {
        let r = t;
        this.config.setOperators.length > 0
          ? (this.config.setOperators.at(-1).orderBy = r)
          : (this.config.orderBy = r);
      }
      return this;
    }
    limit(t) {
      return (
        this.config.setOperators.length > 0
          ? (this.config.setOperators.at(-1).limit = t)
          : (this.config.limit = t),
        this
      );
    }
    offset(t) {
      return (
        this.config.setOperators.length > 0
          ? (this.config.setOperators.at(-1).offset = t)
          : (this.config.offset = t),
        this
      );
    }
    for(t, r = {}) {
      return (this.config.lockingClause = { strength: t, config: r }), this;
    }
    getSQL() {
      return this.dialect.buildSelectQuery(this.config);
    }
    toSQL() {
      let { typings: t, ...r } = this.dialect.sqlToQuery(this.getSQL());
      return r;
    }
    as(t) {
      return new Proxy(
        new Ht(this.getSQL(), this.config.fields, t),
        new qr({ alias: t, sqlAliasedBehavior: "alias", sqlBehavior: "error" }),
      );
    }
    getSelectedFields() {
      return new Proxy(
        this.config.fields,
        new qr({ alias: this.tableName, sqlAliasedBehavior: "alias", sqlBehavior: "error" }),
      );
    }
    $dynamic() {
      return this;
    }
  },
  Id = class extends U_ {
    static [V] = "PgSelect";
    _prepare(t) {
      let { session: r, config: n, dialect: s, joinsNotNullableMap: i } = this;
      if (!r)
        throw new Error(
          "Cannot execute a query on a query builder. Please use a database instance instead.",
        );
      return at.startActiveSpan("drizzle.prepareQuery", () => {
        let o = ln(n.fields),
          a = r.prepareQuery(s.sqlToQuery(this.getSQL()), o, t, !0);
        return (a.joinsNotNullableMap = i), a;
      });
    }
    prepare(t) {
      return this._prepare(t);
    }
    execute = (t) => at.startActiveSpan("drizzle.operation", () => this._prepare().execute(t));
  };
cD(Id, [lr]);
function ra(e, t) {
  return (r, n, ...s) => {
    let i = [n, ...s].map((o) => ({ type: e, isAll: t, rightSelect: o }));
    for (let o of i)
      if (!M_(r.getSelectedFields(), o.rightSelect.getSelectedFields()))
        throw new Error(
          "Set operator error (union / intersect / except): selected fields are not the same or are in a different order",
        );
    return r.addSetOperators(i);
  };
}
var Iee = () => ({
    union: Cee,
    unionAll: kee,
    intersect: Dee,
    intersectAll: qee,
    except: jee,
    exceptAll: Lee,
  }),
  Cee = ra("union", !1),
  kee = ra("union", !0),
  Dee = ra("intersect", !1),
  qee = ra("intersect", !0),
  jee = ra("except", !1),
  Lee = ra("except", !0);
var Cd = class {
  static [V] = "PgQueryBuilder";
  dialect;
  $with(t) {
    let r = this;
    return {
      as(n) {
        return (
          typeof n == "function" && (n = n(r)),
          new Proxy(
            new Yo(n.getSQL(), n.getSelectedFields(), t, !0),
            new qr({ alias: t, sqlAliasedBehavior: "alias", sqlBehavior: "error" }),
          )
        );
      },
    };
  }
  with(...t) {
    let r = this;
    function n(o) {
      return new cr({ fields: o ?? void 0, session: void 0, dialect: r.getDialect(), withList: t });
    }
    function s(o) {
      return new cr({
        fields: o ?? void 0,
        session: void 0,
        dialect: r.getDialect(),
        distinct: !0,
      });
    }
    function i(o, a) {
      return new cr({
        fields: a ?? void 0,
        session: void 0,
        dialect: r.getDialect(),
        distinct: { on: o },
      });
    }
    return { select: n, selectDistinct: s, selectDistinctOn: i };
  }
  select(t) {
    return new cr({ fields: t ?? void 0, session: void 0, dialect: this.getDialect() });
  }
  selectDistinct(t) {
    return new cr({
      fields: t ?? void 0,
      session: void 0,
      dialect: this.getDialect(),
      distinct: !0,
    });
  }
  selectDistinctOn(t, r) {
    return new cr({
      fields: r ?? void 0,
      session: void 0,
      dialect: this.getDialect(),
      distinct: { on: t },
    });
  }
  getDialect() {
    return this.dialect || (this.dialect = new ta()), this.dialect;
  }
};
var kd = class extends lr {
  constructor(t, r, n) {
    super(), (this.session = r), (this.dialect = n), (this.config = { view: t });
  }
  static [V] = "PgRefreshMaterializedView";
  config;
  concurrently() {
    if (this.config.withNoData !== void 0)
      throw new Error("Cannot use concurrently and withNoData together");
    return (this.config.concurrently = !0), this;
  }
  withNoData() {
    if (this.config.concurrently !== void 0)
      throw new Error("Cannot use concurrently and withNoData together");
    return (this.config.withNoData = !0), this;
  }
  getSQL() {
    return this.dialect.buildRefreshMaterializedViewQuery(this.config);
  }
  toSQL() {
    let { typings: t, ...r } = this.dialect.sqlToQuery(this.getSQL());
    return r;
  }
  _prepare(t) {
    return at.startActiveSpan("drizzle.prepareQuery", () =>
      this.session.prepareQuery(this.dialect.sqlToQuery(this.getSQL()), void 0, t, !0),
    );
  }
  prepare(t) {
    return this._prepare(t);
  }
  execute = (t) => at.startActiveSpan("drizzle.operation", () => this._prepare().execute(t));
};
var il = class {
    constructor(t, r, n, s) {
      (this.table = t), (this.session = r), (this.dialect = n), (this.withList = s);
    }
    static [V] = "PgUpdateBuilder";
    set(t) {
      return new H_(this.table, Nd(this.table, t), this.session, this.dialect, this.withList);
    }
  },
  H_ = class extends lr {
    constructor(t, r, n, s, i) {
      super(),
        (this.session = n),
        (this.dialect = s),
        (this.config = { set: r, table: t, withList: i });
    }
    static [V] = "PgUpdate";
    config;
    where(t) {
      return (this.config.where = t), this;
    }
    returning(t = this.config.table[se.Symbol.Columns]) {
      return (this.config.returning = ln(t)), this;
    }
    getSQL() {
      return this.dialect.buildUpdateQuery(this.config);
    }
    toSQL() {
      let { typings: t, ...r } = this.dialect.sqlToQuery(this.getSQL());
      return r;
    }
    _prepare(t) {
      return this.session.prepareQuery(
        this.dialect.sqlToQuery(this.getSQL()),
        this.config.returning,
        t,
        !0,
      );
    }
    prepare(t) {
      return this._prepare(t);
    }
    execute = (t) => this._prepare().execute(t);
    $dynamic() {
      return this;
    }
  };
var Dd = class {
    constructor(t, r, n, s, i, o, a) {
      (this.fullSchema = t),
        (this.schema = r),
        (this.tableNamesMap = n),
        (this.table = s),
        (this.tableConfig = i),
        (this.dialect = o),
        (this.session = a);
    }
    static [V] = "PgRelationalQueryBuilder";
    findMany(t) {
      return new qd(
        this.fullSchema,
        this.schema,
        this.tableNamesMap,
        this.table,
        this.tableConfig,
        this.dialect,
        this.session,
        t || {},
        "many",
      );
    }
    findFirst(t) {
      return new qd(
        this.fullSchema,
        this.schema,
        this.tableNamesMap,
        this.table,
        this.tableConfig,
        this.dialect,
        this.session,
        t ? { ...t, limit: 1 } : { limit: 1 },
        "first",
      );
    }
  },
  qd = class extends lr {
    constructor(t, r, n, s, i, o, a, u, l) {
      super(),
        (this.fullSchema = t),
        (this.schema = r),
        (this.tableNamesMap = n),
        (this.table = s),
        (this.tableConfig = i),
        (this.dialect = o),
        (this.session = a),
        (this.config = u),
        (this.mode = l);
    }
    static [V] = "PgRelationalQuery";
    _prepare(t) {
      return at.startActiveSpan("drizzle.prepareQuery", () => {
        let { query: r, builtQuery: n } = this._toSQL();
        return this.session.prepareQuery(n, void 0, t, !0, (s, i) => {
          let o = s.map((a) => Od(this.schema, this.tableConfig, a, r.selection, i));
          return this.mode === "first" ? o[0] : o;
        });
      });
    }
    prepare(t) {
      return this._prepare(t);
    }
    _getQuery() {
      return this.dialect.buildRelationalQueryWithoutPK({
        fullSchema: this.fullSchema,
        schema: this.schema,
        tableNamesMap: this.tableNamesMap,
        table: this.table,
        tableConfig: this.tableConfig,
        queryConfig: this.config,
        tableAlias: this.tableConfig.tsName,
      });
    }
    getSQL() {
      return this._getQuery().sql;
    }
    _toSQL() {
      let t = this._getQuery(),
        r = this.dialect.sqlToQuery(t.sql);
      return { query: t, builtQuery: r };
    }
    toSQL() {
      return this._toSQL().builtQuery;
    }
    execute() {
      return at.startActiveSpan("drizzle.operation", () => this._prepare().execute());
    }
  };
var jd = class extends lr {
  constructor(t, r, n, s) {
    super(), (this.execute = t), (this.sql = r), (this.query = n), (this.mapBatchResult = s);
  }
  static [V] = "PgRaw";
  getSQL() {
    return this.sql;
  }
  getQuery() {
    return this.query;
  }
  mapResult(t, r) {
    return r ? this.mapBatchResult(t) : t;
  }
  _prepare() {
    return this;
  }
  isResponseInArrayMode() {
    return !1;
  }
};
var na = class {
  constructor(t, r, n) {
    if (
      ((this.dialect = t),
      (this.session = r),
      (this._ = n
        ? { schema: n.schema, fullSchema: n.fullSchema, tableNamesMap: n.tableNamesMap, session: r }
        : { schema: void 0, fullSchema: {}, tableNamesMap: {}, session: r }),
      (this.query = {}),
      this._.schema)
    )
      for (let [s, i] of Object.entries(this._.schema))
        this.query[s] = new Dd(
          n.fullSchema,
          this._.schema,
          this._.tableNamesMap,
          n.fullSchema[s],
          i,
          t,
          r,
        );
  }
  static [V] = "PgDatabase";
  query;
  $with(t) {
    return {
      as(r) {
        return (
          typeof r == "function" && (r = r(new Cd())),
          new Proxy(
            new Yo(r.getSQL(), r.getSelectedFields(), t, !0),
            new qr({ alias: t, sqlAliasedBehavior: "alias", sqlBehavior: "error" }),
          )
        );
      },
    };
  }
  with(...t) {
    let r = this;
    function n(l) {
      return new cr({ fields: l ?? void 0, session: r.session, dialect: r.dialect, withList: t });
    }
    function s(l) {
      return new cr({
        fields: l ?? void 0,
        session: r.session,
        dialect: r.dialect,
        withList: t,
        distinct: !0,
      });
    }
    function i(l, c) {
      return new cr({
        fields: c ?? void 0,
        session: r.session,
        dialect: r.dialect,
        withList: t,
        distinct: { on: l },
      });
    }
    function o(l) {
      return new il(l, r.session, r.dialect, t);
    }
    function a(l) {
      return new Qu(l, r.session, r.dialect, t);
    }
    function u(l) {
      return new Ju(l, r.session, r.dialect, t);
    }
    return { select: n, selectDistinct: s, selectDistinctOn: i, update: o, insert: a, delete: u };
  }
  select(t) {
    return new cr({ fields: t ?? void 0, session: this.session, dialect: this.dialect });
  }
  selectDistinct(t) {
    return new cr({
      fields: t ?? void 0,
      session: this.session,
      dialect: this.dialect,
      distinct: !0,
    });
  }
  selectDistinctOn(t, r) {
    return new cr({
      fields: r ?? void 0,
      session: this.session,
      dialect: this.dialect,
      distinct: { on: t },
    });
  }
  update(t) {
    return new il(t, this.session, this.dialect);
  }
  insert(t) {
    return new Qu(t, this.session, this.dialect);
  }
  delete(t) {
    return new Ju(t, this.session, this.dialect);
  }
  refreshMaterializedView(t) {
    return new kd(t, this.session, this.dialect);
  }
  execute(t) {
    let r = t.getSQL(),
      n = this.dialect.sqlToQuery(r),
      s = this.session.prepareQuery(n, void 0, void 0, !1);
    return new jd(
      () => s.execute(),
      r,
      n,
      (i) => s.mapResult(i, !0),
    );
  }
  transaction(t, r) {
    return this.session.transaction(t, r);
  }
};
var Ld = class {
    constructor(t) {
      this.query = t;
    }
    getQuery() {
      return this.query;
    }
    mapResult(t, r) {
      return t;
    }
    static [V] = "PgPreparedQuery";
    joinsNotNullableMap;
  },
  xd = class {
    constructor(t) {
      this.dialect = t;
    }
    static [V] = "PgSession";
    execute(t) {
      return at.startActiveSpan("drizzle.operation", () =>
        at
          .startActiveSpan("drizzle.prepareQuery", () =>
            this.prepareQuery(this.dialect.sqlToQuery(t), void 0, void 0, !1),
          )
          .execute(),
      );
    }
    all(t) {
      return this.prepareQuery(this.dialect.sqlToQuery(t), void 0, void 0, !1).all();
    }
  },
  Fd = class extends na {
    constructor(t, r, n, s = 0) {
      super(t, r, n), (this.schema = n), (this.nestedIndex = s);
    }
    static [V] = "PgTransaction";
    rollback() {
      throw new Ed();
    }
    getTransactionConfigSQL(t) {
      let r = [];
      return (
        t.isolationLevel && r.push(`isolation level ${t.isolationLevel}`),
        t.accessMode && r.push(t.accessMode),
        typeof t.deferrable == "boolean" && r.push(t.deferrable ? "deferrable" : "not deferrable"),
        I.raw(r.join(" "))
      );
    }
    setTransaction(t) {
      return this.session.execute(I`set transaction ${this.getTransactionConfigSQL(t)}`);
    }
  };
var B_ = class extends Ld {
    constructor(t, r, n, s, i, o, a) {
      super({ sql: r, params: n }),
        (this.client = t),
        (this.queryString = r),
        (this.params = n),
        (this.logger = s),
        (this.fields = i),
        (this._isResponseInArrayMode = o),
        (this.customResultMapper = a);
    }
    static [V] = "PostgresJsPreparedQuery";
    async execute(t = {}) {
      return at.startActiveSpan("drizzle.execute", async (r) => {
        let n = q_(this.params, t);
        r?.setAttributes({
          "drizzle.query.text": this.queryString,
          "drizzle.query.params": JSON.stringify(n),
        }),
          this.logger.logQuery(this.queryString, n);
        let {
          fields: s,
          queryString: i,
          client: o,
          joinsNotNullableMap: a,
          customResultMapper: u,
        } = this;
        if (!s && !u) return at.startActiveSpan("drizzle.driver.execute", () => o.unsafe(i, n));
        let l = await at.startActiveSpan(
          "drizzle.driver.execute",
          () => (
            r?.setAttributes({
              "drizzle.query.text": i,
              "drizzle.query.params": JSON.stringify(n),
            }),
            o.unsafe(i, n).values()
          ),
        );
        return at.startActiveSpan("drizzle.mapResponse", () =>
          u ? u(l) : l.map((c) => lD(s, c, a)),
        );
      });
    }
    all(t = {}) {
      return at.startActiveSpan("drizzle.execute", async (r) => {
        let n = q_(this.params, t);
        return (
          r?.setAttributes({
            "drizzle.query.text": this.queryString,
            "drizzle.query.params": JSON.stringify(n),
          }),
          this.logger.logQuery(this.queryString, n),
          at.startActiveSpan(
            "drizzle.driver.execute",
            () => (
              r?.setAttributes({
                "drizzle.query.text": this.queryString,
                "drizzle.query.params": JSON.stringify(n),
              }),
              this.client.unsafe(this.queryString, n)
            ),
          )
        );
      });
    }
    isResponseInArrayMode() {
      return this._isResponseInArrayMode;
    }
  },
  ol = class e extends xd {
    constructor(t, r, n, s = {}) {
      super(r),
        (this.client = t),
        (this.schema = n),
        (this.options = s),
        (this.logger = s.logger ?? new Td());
    }
    static [V] = "PostgresJsSession";
    logger;
    prepareQuery(t, r, n, s, i) {
      return new B_(this.client, t.sql, t.params, this.logger, r, s, i);
    }
    query(t, r) {
      return this.logger.logQuery(t, r), this.client.unsafe(t, r).values();
    }
    queryObjects(t, r) {
      return this.client.unsafe(t, r);
    }
    transaction(t, r) {
      return this.client.begin(async (n) => {
        let s = new e(n, this.dialect, this.schema, this.options),
          i = new K_(this.dialect, s, this.schema);
        return r && (await i.setTransaction(r)), t(i);
      });
    }
  },
  K_ = class e extends Fd {
    constructor(t, r, n, s = 0) {
      super(t, r, n, s), (this.session = r);
    }
    static [V] = "PostgresJsTransaction";
    transaction(t) {
      return this.session.client.savepoint((r) => {
        let n = new ol(r, this.dialect, this.schema, this.session.options),
          s = new e(this.dialect, n, this.schema);
        return t(s);
      });
    }
  };
function bD(e, t = {}) {
  let r = (a) => a;
  for (let a of ["1184", "1082", "1083", "1114"])
    (e.options.parsers[a] = r), (e.options.serializers[a] = r);
  let n = new ta(),
    s;
  t.logger === !0 ? (s = new Zo()) : t.logger !== !1 && (s = t.logger);
  let i;
  if (t.schema) {
    let a = oD(t.schema, uD);
    i = { fullSchema: t.schema, schema: a.tables, tableNamesMap: a.tableNamesMap };
  }
  let o = new ol(e, n, i, { logger: s });
  return new na(n, o, i);
}
var MD = Jr(require("os"), 1),
  zD = Jr(require("fs"), 1);
var Md = new Map(),
  G_ = new Map(),
  J_ = Symbol("OriginError"),
  sa = {},
  Vr = class extends Promise {
    constructor(t, r, n, s, i = {}) {
      let o, a;
      super((u, l) => {
        (o = u), (a = l);
      }),
        (this.tagged = Array.isArray(t.raw)),
        (this.strings = t),
        (this.args = r),
        (this.handler = n),
        (this.canceller = s),
        (this.options = i),
        (this.state = null),
        (this.statement = null),
        (this.resolve = (u) => ((this.active = !1), o(u))),
        (this.reject = (u) => ((this.active = !1), a(u))),
        (this.active = !1),
        (this.cancelled = null),
        (this.executed = !1),
        (this.signature = ""),
        (this[J_] = this.handler.debug ? new Error() : this.tagged && xee(this.strings));
    }
    get origin() {
      return (
        (this.handler.debug
          ? this[J_].stack
          : this.tagged && G_.has(this.strings)
            ? G_.get(this.strings)
            : G_.set(this.strings, this[J_].stack).get(this.strings)) || ""
      );
    }
    static get [Symbol.species]() {
      return Promise;
    }
    cancel() {
      return this.canceller && (this.canceller(this), (this.canceller = null));
    }
    simple() {
      return (this.options.simple = !0), (this.options.prepare = !1), this;
    }
    async readable() {
      return this.simple(), (this.streaming = !0), this;
    }
    async writable() {
      return this.simple(), (this.streaming = !0), this;
    }
    cursor(t = 1, r) {
      if (
        ((this.options.simple = !1),
        typeof t == "function" && ((r = t), (t = 1)),
        (this.cursorRows = t),
        typeof r == "function")
      )
        return (this.cursorFn = r), this;
      let n;
      return {
        [Symbol.asyncIterator]: () => ({
          next: () => {
            if (this.executed && !this.active) return { done: !0 };
            n && n();
            let s = new Promise((i, o) => {
              (this.cursorFn = (a) => (i({ value: a, done: !1 }), new Promise((u) => (n = u)))),
                (this.resolve = () => ((this.active = !1), i({ done: !0 }))),
                (this.reject = (a) => ((this.active = !1), o(a)));
            });
            return this.execute(), s;
          },
          return() {
            return n && n(sa), { done: !0 };
          },
        }),
      };
    }
    describe() {
      return (this.options.simple = !1), (this.onlyDescribe = this.options.prepare = !0), this;
    }
    stream() {
      throw new Error(".stream has been renamed to .forEach");
    }
    forEach(t) {
      return (this.forEachFn = t), this.handle(), this;
    }
    raw() {
      return (this.isRaw = !0), this;
    }
    values() {
      return (this.isRaw = "values"), this;
    }
    async handle() {
      !this.executed && (this.executed = !0) && (await 1) && this.handler(this);
    }
    execute() {
      return this.handle(), this;
    }
    then() {
      return this.handle(), super.then.apply(this, arguments);
    }
    catch() {
      return this.handle(), super.catch.apply(this, arguments);
    }
    finally() {
      return this.handle(), super.finally.apply(this, arguments);
    }
  };
function xee(e) {
  if (Md.has(e)) return Md.get(e);
  let t = Error.stackTraceLimit;
  return (
    (Error.stackTraceLimit = 4), Md.set(e, new Error()), (Error.stackTraceLimit = t), Md.get(e)
  );
}
var xi = class extends Error {
    constructor(t) {
      super(t.message), (this.name = this.constructor.name), Object.assign(this, t);
    }
  },
  xt = { connection: wD, postgres: ED, generic: RD, notSupported: TD };
function wD(e, t, r) {
  let { host: n, port: s } = r || t,
    i = Object.assign(
      new Error("write " + e + " " + (t.path || n + ":" + s)),
      { code: e, errno: e, address: t.path || n },
      t.path ? {} : { port: s },
    );
  return Error.captureStackTrace(i, wD), i;
}
function ED(e) {
  let t = new xi(e);
  return Error.captureStackTrace(t, ED), t;
}
function RD(e, t) {
  let r = Object.assign(new Error(e + ": " + t), { code: e });
  return Error.captureStackTrace(r, RD), r;
}
function TD(e) {
  let t = Object.assign(new Error(e + " (B) is not supported"), {
    code: "MESSAGE_NOT_SUPPORTED",
    name: e,
  });
  return Error.captureStackTrace(t, TD), t;
}
var Fee = {
    string: { to: 25, from: null, serialize: (e) => "" + e },
    number: { to: 0, from: [21, 23, 26, 700, 701], serialize: (e) => "" + e, parse: (e) => +e },
    json: {
      to: 114,
      from: [114, 3802],
      serialize: (e) => JSON.stringify(e),
      parse: (e) => JSON.parse(e),
    },
    boolean: {
      to: 16,
      from: 16,
      serialize: (e) => (e === !0 ? "t" : "f"),
      parse: (e) => e === "t",
    },
    date: {
      to: 1184,
      from: [1082, 1114, 1184],
      serialize: (e) => (e instanceof Date ? e : new Date(e)).toISOString(),
      parse: (e) => new Date(e),
    },
    bytea: {
      to: 17,
      from: 17,
      serialize: (e) => "\\x" + Buffer.from(e).toString("hex"),
      parse: (e) => Buffer.from(e.slice(2), "hex"),
    },
  },
  al = class {
    then() {
      Q_();
    }
    catch() {
      Q_();
    }
    finally() {
      Q_();
    }
  },
  ia = class extends al {
    constructor(t) {
      super(), (this.value = Hd(t));
    }
  },
  Rn = class extends al {
    constructor(t, r, n) {
      super(), (this.value = t), (this.type = r), (this.array = n);
    }
  },
  ul = class extends al {
    constructor(t, r) {
      super(), (this.first = t), (this.rest = r);
    }
    build(t, r, n, s) {
      let i = Mee.map(([o, a]) => ({ fn: a, i: t.search(o) }))
        .sort((o, a) => o.i - a.i)
        .pop();
      return i.i === -1 ? eS(this.first, s) : i.fn(this.first, this.rest, r, n, s);
    }
  };
function Ud(e, t, r, n) {
  let s = e instanceof Rn ? e.value : e;
  if (
    s === void 0 &&
    (e instanceof Rn ? (e.value = n.transform.undefined) : (s = e = n.transform.undefined),
    s === void 0)
  )
    throw xt.generic("UNDEFINED_VALUE", "Undefined values are not allowed");
  return (
    "$" +
    r.push(
      e instanceof Rn
        ? (t.push(e.value),
          e.array ? e.array[e.type || Vd(e.value)] || e.type || ND(e.value) : e.type)
        : (t.push(e), Vd(e)),
    )
  );
}
var $D = ID(Fee);
function X_(e, t, r, n, s, i) {
  for (let o = 1; o < e.strings.length; o++)
    (t += Z_(t, r, n, s, i) + e.strings[o]), (r = e.args[o]);
  return t;
}
function Z_(e, t, r, n, s) {
  return t instanceof ul
    ? t.build(e, r, n, s)
    : t instanceof Vr
      ? Y_(t, r, n, s)
      : t instanceof ia
        ? t.value
        : t && t[0] instanceof Vr
          ? t.reduce((i, o) => i + " " + Y_(o, r, n, s), "")
          : Ud(t, r, n, s);
}
function Y_(e, t, r, n) {
  return (e.fragment = !0), X_(e, e.strings[0], e.args[0], t, r, n);
}
function OD(e, t, r, n, s) {
  return e.map((i) => "(" + n.map((o) => Z_("values", i[o], t, r, s)).join(",") + ")").join(",");
}
function PD(e, t, r, n, s) {
  let i = Array.isArray(e[0]),
    o = t.length ? t.flat() : Object.keys(i ? e[0] : e);
  return OD(i ? e : [e], r, n, o, s);
}
function zd(e, t, r, n, s) {
  if ((typeof e == "string" && (e = [e].concat(t)), Array.isArray(e))) return eS(e, s);
  let i;
  return (t.length ? t.flat() : Object.keys(e))
    .map(
      (a) => (
        (i = e[a]),
        (i instanceof Vr ? Y_(i, r, n, s) : i instanceof ia ? i.value : Ud(i, r, n, s)) +
          " as " +
          Hd(s.transform.column.to ? s.transform.column.to(a) : a)
      ),
    )
    .join(",");
}
var Mee = Object.entries({
  values: PD,
  in: (...e) => {
    let t = PD(...e);
    return t === "()" ? "(null)" : t;
  },
  select: zd,
  as: zd,
  returning: zd,
  "\\(": zd,
  update(e, t, r, n, s) {
    return (t.length ? t.flat() : Object.keys(e)).map(
      (i) =>
        Hd(s.transform.column.to ? s.transform.column.to(i) : i) +
        "=" +
        Z_("values", e[i], r, n, s),
    );
  },
  insert(e, t, r, n, s) {
    let i = t.length ? t.flat() : Object.keys(Array.isArray(e) ? e[0] : e);
    return "(" + eS(i, s) + ")values" + OD(Array.isArray(e) ? e : [e], r, n, i, s);
  },
}).map(([e, t]) => [new RegExp("((?:^|[\\s(])" + e + "(?:$|[\\s(]))(?![\\s\\S]*\\1)", "i"), t]);
function Q_() {
  throw xt.generic("NOT_TAGGED_CALL", "Query not called as a tagged template literal");
}
var zee = $D.serializers,
  Vee = $D.parsers;
function ND(e) {
  return Array.isArray(e) ? ND(e[0]) : typeof e == "string" ? 1009 : 0;
}
var AD = function (e) {
  let t = ID(e || {});
  return {
    serializers: Object.assign({}, zee, t.serializers),
    parsers: Object.assign({}, Vee, t.parsers),
  };
};
function ID(e) {
  return Object.keys(e).reduce(
    (t, r) => (
      e[r].from && [].concat(e[r].from).forEach((n) => (t.parsers[n] = e[r].parse)),
      e[r].serialize &&
        ((t.serializers[e[r].to] = e[r].serialize),
        e[r].from && [].concat(e[r].from).forEach((n) => (t.serializers[n] = e[r].serialize))),
      t
    ),
    { parsers: {}, serializers: {} },
  );
}
function eS(e, { transform: { column: t } }) {
  return e.map((r) => Hd(t.to ? t.to(r) : r)).join(",");
}
var Hd = function (t) {
    return '"' + t.replace(/"/g, '""').replace(/\./g, '"."') + '"';
  },
  Vd = function e(t) {
    return t instanceof Rn
      ? t.type
      : t instanceof Date
        ? 1184
        : t instanceof Uint8Array
          ? 17
          : t === !0 || t === !1
            ? 16
            : typeof t == "bigint"
              ? 20
              : Array.isArray(t)
                ? e(t[0])
                : 0;
  },
  Uee = /\\/g,
  Hee = /"/g;
function Bee(e) {
  return e.replace(Uee, "\\\\").replace(Hee, '\\"');
}
var CD = function e(t, r, n, s) {
    if (Array.isArray(t) === !1) return t;
    if (!t.length) return "{}";
    let i = t[0],
      o = s === 1020 ? ";" : ",";
    return Array.isArray(i) && !i.type
      ? "{" + t.map((a) => e(a, r, n, s)).join(o) + "}"
      : "{" +
          t
            .map((a) => {
              if (a === void 0 && ((a = n.transform.undefined), a === void 0))
                throw xt.generic("UNDEFINED_VALUE", "Undefined values are not allowed");
              return a === null ? "null" : '"' + Bee(r ? r(a.type ? a.value : a) : "" + a) + '"';
            })
            .join(o) +
          "}";
  },
  W_ = { i: 0, char: null, str: "", quoted: !1, last: 0 },
  kD = function (t, r, n) {
    return (W_.i = W_.last = 0), DD(W_, t, r, n);
  };
function DD(e, t, r, n) {
  let s = [],
    i = n === 1020 ? ";" : ",";
  for (; e.i < t.length; e.i++) {
    if (((e.char = t[e.i]), e.quoted))
      e.char === "\\"
        ? (e.str += t[++e.i])
        : e.char === '"'
          ? (s.push(r ? r(e.str) : e.str),
            (e.str = ""),
            (e.quoted = t[e.i + 1] === '"'),
            (e.last = e.i + 2))
          : (e.str += e.char);
    else if (e.char === '"') e.quoted = !0;
    else if (e.char === "{") (e.last = ++e.i), s.push(DD(e, t, r, n));
    else if (e.char === "}") {
      (e.quoted = !1),
        e.last < e.i && s.push(r ? r(t.slice(e.last, e.i)) : t.slice(e.last, e.i)),
        (e.last = e.i + 1);
      break;
    } else
      e.char === i &&
        e.p !== "}" &&
        e.p !== '"' &&
        (s.push(r ? r(t.slice(e.last, e.i)) : t.slice(e.last, e.i)), (e.last = e.i + 1));
    e.p = e.char;
  }
  return e.last < e.i && s.push(r ? r(t.slice(e.last, e.i + 1)) : t.slice(e.last, e.i + 1)), s;
}
var Fi = (e) => {
    let t = e[0];
    for (let r = 1; r < e.length; r++) t += e[r] === "_" ? e[++r].toUpperCase() : e[r];
    return t;
  },
  Mi = (e) => {
    let t = e[0].toUpperCase();
    for (let r = 1; r < e.length; r++) t += e[r] === "_" ? e[++r].toUpperCase() : e[r];
    return t;
  },
  zi = (e) => e.replace(/_/g, "-"),
  ll = (e) => e.replace(/([A-Z])/g, "_$1").toLowerCase(),
  cl = (e) => (e.slice(0, 1) + e.slice(1).replace(/([A-Z])/g, "_$1")).toLowerCase(),
  fl = (e) => e.replace(/-/g, "_");
function tS(e) {
  return function t(r, n) {
    return typeof r == "object" && r !== null && (n.type === 114 || n.type === 3802)
      ? Array.isArray(r)
        ? r.map((s) => t(s, n))
        : Object.entries(r).reduce((s, [i, o]) => Object.assign(s, { [e(i)]: t(o, n) }), {})
      : r;
  };
}
Fi.column = { from: Fi };
Fi.value = { from: tS(Fi) };
ll.column = { to: ll };
var rS = { ...Fi };
rS.column.to = ll;
Mi.column = { from: Mi };
Mi.value = { from: tS(Mi) };
cl.column = { to: cl };
var nS = { ...Mi };
nS.column.to = cl;
zi.column = { from: zi };
zi.value = { from: tS(zi) };
fl.column = { to: fl };
var sS = { ...zi };
sS.column.to = fl;
var aS = Jr(require("net"), 1),
  LD = Jr(require("tls"), 1),
  aa = Jr(require("crypto"), 1),
  Gd = Jr(require("stream"), 1),
  uS = require("perf_hooks");
var ti = class extends Array {
  constructor() {
    super(),
      Object.defineProperties(this, {
        count: { value: null, writable: !0 },
        state: { value: null, writable: !0 },
        command: { value: null, writable: !0 },
        columns: { value: null, writable: !0 },
        statement: { value: null, writable: !0 },
      });
  }
  static get [Symbol.species]() {
    return Array;
  }
};
var Ur = Kee;
function Kee(e = []) {
  let t = e.slice(),
    r = 0;
  return {
    get length() {
      return t.length - r;
    },
    remove: (n) => {
      let s = t.indexOf(n);
      return s === -1 ? null : (t.splice(s, 1), n);
    },
    push: (n) => (t.push(n), n),
    shift: () => {
      let n = t[r++];
      return r === t.length ? ((r = 0), (t = [])) : (t[r - 1] = void 0), n;
    },
  };
}
var fr = Buffer.allocUnsafe(256),
  Gee = "BCcDdEFfHPpQSX".split("").reduce((e, t) => {
    let r = t.charCodeAt(0);
    return (e[t] = () => ((fr[0] = r), (rt.i = 5), rt)), e;
  }, {}),
  rt = Object.assign(Jee, Gee, {
    N: "\0",
    i: 0,
    inc(e) {
      return (rt.i += e), rt;
    },
    str(e) {
      let t = Buffer.byteLength(e);
      return Bd(t), (rt.i += fr.write(e, rt.i, t, "utf8")), rt;
    },
    i16(e) {
      return Bd(2), fr.writeUInt16BE(e, rt.i), (rt.i += 2), rt;
    },
    i32(e, t) {
      return t || t === 0
        ? (fr.writeUInt32BE(e, t), rt)
        : (Bd(4), fr.writeUInt32BE(e, rt.i), (rt.i += 4), rt);
    },
    z(e) {
      return Bd(e), fr.fill(0, rt.i, rt.i + e), (rt.i += e), rt;
    },
    raw(e) {
      return (fr = Buffer.concat([fr.subarray(0, rt.i), e])), (rt.i = fr.length), rt;
    },
    end(e = 1) {
      fr.writeUInt32BE(rt.i - e, e);
      let t = fr.subarray(0, rt.i);
      return (rt.i = 0), (fr = Buffer.allocUnsafe(256)), t;
    },
  }),
  pe = rt;
function Bd(e) {
  if (fr.length - rt.i < e) {
    let t = fr,
      r = t.length;
    (fr = Buffer.allocUnsafe(r + (r >> 1) + e)), t.copy(fr);
  }
}
function Jee() {
  return (rt.i = 0), rt;
}
var lS = xD,
  Qee = 1,
  ri = pe().S().end(),
  qD = pe().H().end(),
  Wee = pe().i32(8).i32(80877103).end(8),
  Yee = Buffer.concat([pe().E().str(pe.N).i32(0).end(), ri]),
  Xee = pe().D().str("S").str(pe.N).end(),
  oa = () => {},
  Zee = new Set(["FetchPreparedStatement", "RevalidateCachedQuery", "transformAssignedExpr"]),
  ete = {
    83: "severity_local",
    86: "severity",
    67: "code",
    77: "message",
    68: "detail",
    72: "hint",
    80: "position",
    112: "internal_position",
    113: "internal_query",
    87: "where",
    115: "schema_name",
    116: "table_name",
    99: "column_name",
    100: "data type_name",
    110: "constraint_name",
    70: "file",
    76: "line",
    82: "routine",
  };
function xD(e, t = {}, { onopen: r = oa, onend: n = oa, onclose: s = oa } = {}) {
  let {
      ssl: i,
      max: o,
      user: a,
      host: u,
      port: l,
      database: c,
      parsers: f,
      transform: d,
      onnotice: h,
      onnotify: p,
      onparameter: y,
      max_pipeline: _,
      keep_alive: S,
      backoff: E,
      target_session_attrs: g,
    } = e,
    m = Ur(),
    T = Qee++,
    N = { pid: null, secret: null },
    w = oS(fa, e.idle_timeout),
    $ = oS(fa, e.max_lifetime),
    D = oS(Hi, e.connect_timeout),
    v = null,
    M,
    k = new ti(),
    x = Buffer.alloc(0),
    ie = e.fetch_types,
    Z = {},
    G = {},
    Y = Math.random().toString(36).slice(2),
    U = 1,
    z = 0,
    oe = 0,
    Te = 0,
    ce = 0,
    Se = 0,
    Ee = 0,
    ue = 0,
    Re = null,
    ee = null,
    ve = !1,
    Ae = null,
    Oe = null,
    me = null,
    C = null,
    H = null,
    K = null,
    te = null,
    _e = null,
    F = null,
    Me = null,
    Xe = {
      queue: t.closed,
      idleTimer: w,
      connect(P) {
        (me = P || !0), Zt();
      },
      terminate: ut,
      execute: bs,
      cancel: wt,
      end: fa,
      count: 0,
      id: T,
    };
  return t.closed && t.closed.push(Xe), Xe;
  async function Je() {
    let P;
    try {
      P = e.socket ? await Promise.resolve(e.socket(e)) : new aS.default.Socket();
    } catch (q) {
      ws(q);
      return;
    }
    return P.on("error", ws), P.on("close", On), P.on("drain", Ze), P;
  }
  async function wt({ pid: P, secret: q }, fe, Ve) {
    try {
      (M = pe().i32(16).i32(80877102).i32(P).i32(q).end(16)),
        await vl(),
        v.once("error", Ve),
        v.once("close", fe);
    } catch (et) {
      Ve(et);
    }
  }
  function bs(P) {
    if (ve) return Es(P, xt.connection("CONNECTION_DESTROYED", e));
    if (!P.cancelled)
      try {
        return (
          (P.state = N),
          F ? m.push(P) : ((F = P), (F.active = !0)),
          Lr(P),
          Et(jr(P)) &&
            !P.describeFirst &&
            !P.cursorFn &&
            m.length < _ &&
            (!P.options.onexecute || P.options.onexecute(Xe))
        );
      } catch (q) {
        return m.length === 0 && Et(ri), nt(q), !0;
      }
  }
  function jr(P) {
    if (P.parameters.length >= 65534)
      throw xt.generic("MAX_PARAMETERS_EXCEEDED", "Max number of parameters (65534) exceeded");
    return P.options.simple
      ? pe()
          .Q()
          .str(P.statement.string + pe.N)
          .end()
      : P.describeFirst
        ? Buffer.concat([Hr(P), qD])
        : P.prepare
          ? P.prepared
            ? Pn(P)
            : Buffer.concat([Hr(P), Pn(P)])
          : $n(P);
  }
  function Hr(P) {
    return Buffer.concat([
      Xn(P.statement.string, P.parameters, P.statement.types, P.statement.name),
      Ts("S", P.statement.name),
    ]);
  }
  function Pn(P) {
    return Buffer.concat([
      Gi(P.parameters, P.statement.types, P.statement.name, P.cursorName),
      P.cursorFn ? Gr("", P.cursorRows) : Yee,
    ]);
  }
  function $n(P) {
    return Buffer.concat([Xn(P.statement.string, P.parameters, P.statement.types), Xee, Pn(P)]);
  }
  function Lr(P) {
    let q = [],
      fe = [],
      Ve = X_(P, P.strings[0], P.args[0], q, fe, e);
    !P.tagged && P.args.forEach((et) => Ud(et, q, fe, e)),
      (P.prepare = e.prepare && ("prepare" in P.options ? P.options.prepare : !0)),
      (P.string = Ve),
      (P.signature = P.prepare && fe + Ve),
      P.onlyDescribe && delete G[P.signature],
      (P.parameters = P.parameters || q),
      (P.prepared = P.prepare && P.signature in G),
      (P.describeFirst = P.onlyDescribe || (q.length && !P.prepared)),
      (P.statement = P.prepared
        ? G[P.signature]
        : { string: Ve, types: fe, name: P.prepare ? Y + U++ : "" }),
      typeof e.debug == "function" && e.debug(T, Ve, q, fe);
  }
  function Et(P, q) {
    return (
      (K = K ? Buffer.concat([K, P]) : Buffer.from(P)),
      q || K.length >= 1024 ? Ft(q) : (ee === null && (ee = setImmediate(Ft)), !0)
    );
  }
  function Ft(P) {
    let q = v.write(K, P);
    return ee !== null && clearImmediate(ee), (K = ee = null), q;
  }
  function Hi() {
    nt(xt.connection("CONNECT_TIMEOUT", e, v)), v.destroy();
  }
  async function fn() {
    if (
      (Et(Wee),
      !(await new Promise((q) => v.once("data", (fe) => q(fe[0] === 83)))) && i === "prefer")
    )
      return ht();
    v.removeAllListeners(),
      (v = LD.default.connect({
        socket: v,
        servername: aS.default.isIP(v.host) ? void 0 : v.host,
        ...(i === "require" || i === "allow" || i === "prefer"
          ? { rejectUnauthorized: !1 }
          : i === "verify-full"
            ? {}
            : typeof i == "object"
              ? i
              : {}),
      })),
      v.on("secureConnect", ht),
      v.on("error", ws),
      v.on("close", On),
      v.on("drain", Ze);
  }
  function Ze() {
    !F && r(Xe);
  }
  function Bt(P) {
    if (!(Ae && (Ae.push(P), (oe -= P.length), oe >= 0)))
      for (
        x = Ae
          ? Buffer.concat(Ae, Se - oe)
          : x.length === 0
            ? P
            : Buffer.concat([x, P], x.length + P.length);
        x.length > 4;

      ) {
        if (((Se = x.readUInt32BE(1)), Se >= x.length)) {
          (oe = Se - x.length), (Ae = [x]);
          break;
        }
        try {
          Rs(x.subarray(0, Se + 1));
        } catch (q) {
          F && (F.cursorFn || F.describeFirst) && Et(ri), nt(q);
        }
        (x = x.subarray(Se + 1)), (oe = 0), (Ae = null);
      }
  }
  async function vl() {
    if (((ve = !1), (Z = {}), v || (v = await Je()), !!v)) {
      if ((D.start(), e.socket)) return i ? fn() : ht();
      if ((v.on("connect", i ? fn : ht), e.path)) return v.connect(e.path);
      (v.ssl = i),
        v.connect(l[Te], u[Te]),
        (v.host = u[Te]),
        (v.port = l[Te]),
        (Te = (Te + 1) % l.length);
    }
  }
  function Zt() {
    setTimeout(vl, z ? z + Ee - uS.performance.now() : 0);
  }
  function ht() {
    try {
      (G = {}),
        (ie = e.fetch_types),
        (Y = Math.random().toString(36).slice(2)),
        (U = 1),
        $.start(),
        v.on("data", Bt),
        S && v.setKeepAlive && v.setKeepAlive(!0, 1e3 * S);
      let P = da();
      Et(P);
    } catch (P) {
      ws(P);
    }
  }
  function ws(P) {
    if (!(Xe.queue === t.connecting && e.host[ce + 1])) for (nt(P); m.length; ) Es(m.shift(), P);
  }
  function nt(P) {
    H && (H.destroy(P), (H = null)), F && Es(F, P), me && (Es(me, P), (me = null));
  }
  function Es(P, q) {
    Object.defineProperties(q, {
      stack: {
        value:
          q.stack +
          P.origin.replace(
            /.*\n/,
            `
`,
          ),
        enumerable: e.debug,
      },
      query: { value: P.string, enumerable: e.debug },
      parameters: { value: P.parameters, enumerable: e.debug },
      args: { value: P.args, enumerable: e.debug },
      types: { value: P.statement && P.statement.types, enumerable: e.debug },
    }),
      P.reject(q);
  }
  function fa() {
    return (
      C ||
      (!Xe.reserved && n(Xe),
      !Xe.reserved && !me && !F && m.length === 0
        ? (ut(), new Promise((P) => (v && v.readyState !== "closed" ? v.once("close", P) : P())))
        : (C = new Promise((P) => (te = P))))
    );
  }
  function ut() {
    (ve = !0),
      (H || F || me || m.length) && ws(xt.connection("CONNECTION_DESTROYED", e)),
      clearImmediate(ee),
      v &&
        (v.removeListener("data", Bt),
        v.removeListener("connect", ht),
        v.readyState === "open" && v.end(pe().X().end())),
      te && (te(), (C = te = null));
  }
  async function On(P) {
    if (
      ((x = Buffer.alloc(0)),
      (oe = 0),
      (Ae = null),
      clearImmediate(ee),
      v.removeListener("data", Bt),
      v.removeListener("connect", ht),
      w.cancel(),
      $.cancel(),
      D.cancel(),
      v.removeAllListeners(),
      (v = null),
      me)
    )
      return Zt();
    !P && (F || m.length) && ws(xt.connection("CONNECTION_CLOSED", e, v)),
      (z = uS.performance.now()),
      P && e.shared.retries++,
      (Ee = (typeof E == "function" ? E(e.shared.retries) : E) * 1e3),
      s(Xe, xt.connection("CONNECTION_CLOSED", e, v));
  }
  function Rs(P, q = P[0]) {
    (q === 68
      ? xr
      : q === 100
        ? Ye
        : q === 65
          ? ze
          : q === 83
            ? er
            : q === 90
              ? Bi
              : q === 67
                ? Br
                : q === 50
                  ? ai
                  : q === 49
                    ? Nn
                    : q === 116
                      ? dn
                      : q === 84
                        ? nh
                        : q === 82
                          ? bl
                          : q === 110
                            ? Pe
                            : q === 75
                              ? xe
                              : q === 69
                                ? $t
                                : q === 115
                                  ? mt
                                  : q === 51
                                    ? Qe
                                    : q === 71
                                      ? Wn
                                      : q === 78
                                        ? Tr
                                        : q === 72
                                          ? hr
                                          : q === 99
                                            ? pr
                                            : q === 73
                                              ? Kr
                                              : q === 86
                                                ? Yn
                                                : q === 118
                                                  ? hn
                                                  : q === 87
                                                    ? Rr
                                                    : ui)(P);
  }
  function xr(P) {
    let q = 7,
      fe,
      Ve,
      et,
      Ot = F.isRaw ? new Array(F.statement.columns.length) : {};
    for (let zt = 0; zt < F.statement.columns.length; zt++)
      (Ve = F.statement.columns[zt]),
        (fe = P.readInt32BE(q)),
        (q += 4),
        (et =
          fe === -1
            ? null
            : F.isRaw === !0
              ? P.subarray(q, (q += fe))
              : Ve.parser === void 0
                ? P.toString("utf8", q, (q += fe))
                : Ve.parser.array === !0
                  ? Ve.parser(P.toString("utf8", q + 1, (q += fe)))
                  : Ve.parser(P.toString("utf8", q, (q += fe)))),
        F.isRaw
          ? (Ot[zt] = F.isRaw === !0 ? et : d.value.from ? d.value.from(et, Ve) : et)
          : (Ot[Ve.name] = d.value.from ? d.value.from(et, Ve) : et);
    F.forEachFn
      ? F.forEachFn(d.row.from ? d.row.from(Ot) : Ot, k)
      : (k[ue++] = d.row.from ? d.row.from(Ot) : Ot);
  }
  function er(P) {
    let [q, fe] = P.toString("utf8", 5, P.length - 1).split(pe.N);
    (Z[q] = fe), e.parameters[q] !== fe && ((e.parameters[q] = fe), y && y(q, fe));
  }
  function Bi(P) {
    if (
      (F && F.options.simple && F.resolve(Oe || k), (F = Oe = null), (k = new ti()), D.cancel(), me)
    ) {
      if (g) {
        if (!Z.in_hot_standby || !Z.default_transaction_read_only) return pt();
        if (je(g, Z)) return ut();
      }
      if (ie) return me === !0 && (me = null), Ke();
      me !== !0 && bs(me), (e.shared.retries = ce = 0), (me = null);
      return;
    }
    for (; m.length && (F = m.shift()) && ((F.active = !0), F.cancelled); )
      xD(e).cancel(F.state, F.cancelled.resolve, F.cancelled.reject);
    F ||
      (Xe.reserved
        ? !Xe.reserved.release && P[5] === 73
          ? C
            ? ut()
            : ((Xe.reserved = null), r(Xe))
          : Xe.reserved()
        : C
          ? ut()
          : r(Xe));
  }
  function Br(P) {
    ue = 0;
    for (let q = P.length - 1; q > 0; q--)
      if (
        (P[q] === 32 &&
          P[q + 1] < 58 &&
          k.count === null &&
          (k.count = +P.toString("utf8", q + 1, P.length - 1)),
        P[q - 1] >= 65)
      ) {
        (k.command = P.toString("utf8", 5, q)), (k.state = N);
        break;
      }
    if ((Me && (Me(), (Me = null)), k.command === "BEGIN" && o !== 1 && !Xe.reserved))
      return nt(xt.generic("UNSAFE_TRANSACTION", "Only use sql.begin, sql.reserved or max: 1"));
    if (F.options.simple) return ai();
    F.cursorFn && (k.count && F.cursorFn(k), Et(ri)), F.resolve(k);
  }
  function Nn() {
    F.parsing = !1;
  }
  function ai() {
    !k.statement && (k.statement = F.statement), (k.columns = F.statement.columns);
  }
  function dn(P) {
    let q = P.readUInt16BE(5);
    for (let fe = 0; fe < q; ++fe)
      !F.statement.types[fe] && (F.statement.types[fe] = P.readUInt32BE(7 + fe * 4));
    F.prepare && (G[F.signature] = F.statement),
      F.describeFirst && !F.onlyDescribe && (Et(Pn(F)), (F.describeFirst = !1));
  }
  function nh(P) {
    k.command &&
      ((Oe = Oe || [k]), Oe.push((k = new ti())), (k.count = null), (F.statement.columns = null));
    let q = P.readUInt16BE(5),
      fe = 7,
      Ve;
    F.statement.columns = Array(q);
    for (let et = 0; et < q; ++et) {
      for (Ve = fe; P[fe++] !== 0; );
      let Ot = P.readUInt32BE(fe),
        zt = P.readUInt16BE(fe + 4),
        Pr = P.readUInt32BE(fe + 6);
      (F.statement.columns[et] = {
        name: d.column.from
          ? d.column.from(P.toString("utf8", Ve, fe - 1))
          : P.toString("utf8", Ve, fe - 1),
        parser: f[Pr],
        table: Ot,
        number: zt,
        type: Pr,
      }),
        (fe += 18);
    }
    if (((k.statement = F.statement), F.onlyDescribe)) return F.resolve(F.statement), Et(ri);
  }
  async function bl(P, q = P.readUInt32BE(5)) {
    (q === 3 ? O : q === 5 ? R : q === 10 ? A : q === 11 ? j : q === 12 ? L : q !== 0 ? Ki : oa)(
      P,
      q,
    );
  }
  async function O() {
    let P = await X();
    Et(pe().p().str(P).z(1).end());
  }
  async function R(P) {
    let q =
      "md5" + (await jD(Buffer.concat([Buffer.from(await jD((await X()) + a)), P.subarray(9)])));
    Et(pe().p().str(q).z(1).end());
  }
  async function A() {
    (_e = (await aa.default.randomBytes(18)).toString("base64")),
      pe()
        .p()
        .str("SCRAM-SHA-256" + pe.N);
    let P = pe.i;
    Et(
      pe
        .inc(4)
        .str("n,,n=*,r=" + _e)
        .i32(pe.i - P - 4, P)
        .end(),
    );
  }
  async function j(P) {
    let q = P.toString("utf8", 9)
        .split(",")
        .reduce((zt, Pr) => ((zt[Pr[0]] = Pr.slice(2)), zt), {}),
      fe = await aa.default.pbkdf2Sync(
        await X(),
        Buffer.from(q.s, "base64"),
        parseInt(q.i),
        32,
        "sha256",
      ),
      Ve = await Kd(fe, "Client Key"),
      et = "n=*,r=" + _e + ",r=" + q.r + ",s=" + q.s + ",i=" + q.i + ",c=biws,r=" + q.r;
    Re = (await Kd(await Kd(fe, "Server Key"), et)).toString("base64");
    let Ot =
      "c=biws,r=" +
      q.r +
      ",p=" +
      rte(Ve, Buffer.from(await Kd(await tte(Ve), et))).toString("base64");
    Et(pe().p().str(Ot).end());
  }
  function L(P) {
    P.toString("utf8", 9).split(pe.N, 1)[0].slice(2) !== Re &&
      (nt(xt.generic("SASL_SIGNATURE_MISMATCH", "The server did not return the correct signature")),
      v.destroy());
  }
  function X() {
    return Promise.resolve(typeof e.pass == "function" ? e.pass() : e.pass);
  }
  function Pe() {
    if (((k.statement = F.statement), (k.statement.columns = []), F.onlyDescribe))
      return F.resolve(F.statement), Et(ri);
  }
  function xe(P) {
    (N.pid = P.readUInt32BE(5)), (N.secret = P.readUInt32BE(9));
  }
  async function Ke() {
    (ie = !1),
      (
        await new Vr(
          [
            `
      select b.oid, b.typarray
      from pg_catalog.pg_type a
      left join pg_catalog.pg_type b on b.oid = a.typelem
      where a.typcategory = 'A'
      group by b.oid, b.typarray
      order by b.oid
    `,
          ],
          [],
          bs,
        )
      ).forEach(({ oid: q, typarray: fe }) => Pt(q, fe));
  }
  function Pt(P, q) {
    if (e.parsers[q] && e.serializers[q]) return;
    let fe = e.parsers[P];
    (e.shared.typeArrayMap[P] = q),
      (e.parsers[q] = (Ve) => kD(Ve, fe, q)),
      (e.parsers[q].array = !0),
      (e.serializers[q] = (Ve) => CD(Ve, e.serializers[P], e, q));
  }
  function je(P, q) {
    return (
      (P === "read-write" && q.default_transaction_read_only === "on") ||
      (P === "read-only" && q.default_transaction_read_only === "off") ||
      (P === "primary" && q.in_hot_standby === "on") ||
      (P === "standby" && q.in_hot_standby === "off") ||
      (P === "prefer-standby" && q.in_hot_standby === "off" && e.host[ce])
    );
  }
  function pt() {
    let P = new Vr(
      [
        `
      show transaction_read_only;
      select pg_catalog.pg_is_in_recovery()
    `,
      ],
      [],
      bs,
      null,
      { simple: !0 },
    );
    (P.resolve = ([[q], [fe]]) => {
      (Z.default_transaction_read_only = q.transaction_read_only),
        (Z.in_hot_standby = fe.pg_is_in_recovery ? "on" : "off");
    }),
      P.execute();
  }
  function $t(P) {
    F && (F.cursorFn || F.describeFirst) && Et(ri);
    let q = xt.postgres(iS(P));
    F && F.retried ? nt(F.retried) : F && F.prepared && Zee.has(q.routine) ? lt(F, q) : nt(q);
  }
  function lt(P, q) {
    delete G[P.signature], (P.retried = q), bs(P);
  }
  function ze(P) {
    if (!p) return;
    let q = 9;
    for (; P[q++] !== 0; );
    p(P.toString("utf8", 9, q - 1), P.toString("utf8", q, P.length - 1));
  }
  async function mt() {
    try {
      let P = await Promise.resolve(F.cursorFn(k));
      (ue = 0), P === sa ? Et(Ps(F.portal)) : ((k = new ti()), Et(Gr("", F.cursorRows)));
    } catch (P) {
      Et(ri), F.reject(P);
    }
  }
  function Qe() {
    k.count && F.cursorFn(k), F.resolve(k);
  }
  function Wn() {
    (H = new Gd.default.Writable({
      autoDestroy: !0,
      write(P, q, fe) {
        v.write(pe().d().raw(P).end(), fe);
      },
      destroy(P, q) {
        q(P),
          v.write(
            pe()
              .f()
              .str(P + pe.N)
              .end(),
          ),
          (H = null);
      },
      final(P) {
        v.write(pe().c().end()), (Me = P);
      },
    })),
      F.resolve(H);
  }
  function hr() {
    (H = new Gd.default.Readable({
      read() {
        v.resume();
      },
    })),
      F.resolve(H);
  }
  function Rr() {
    (H = new Gd.default.Duplex({
      autoDestroy: !0,
      read() {
        v.resume();
      },
      write(P, q, fe) {
        v.write(pe().d().raw(P).end(), fe);
      },
      destroy(P, q) {
        q(P),
          v.write(
            pe()
              .f()
              .str(P + pe.N)
              .end(),
          ),
          (H = null);
      },
      final(P) {
        v.write(pe().c().end()), (Me = P);
      },
    })),
      F.resolve(H);
  }
  function Ye(P) {
    H && (H.push(P.subarray(5)) || v.pause());
  }
  function pr() {
    H && H.push(null), (H = null);
  }
  function Tr(P) {
    h ? h(iS(P)) : console.log(iS(P));
  }
  function Kr() {}
  function Yn() {
    nt(xt.notSupported("FunctionCallResponse"));
  }
  function hn() {
    nt(xt.notSupported("NegotiateProtocolVersion"));
  }
  function ui(P) {
    console.error("Postgres.js : Unknown Message:", P[0]);
  }
  function Ki(P, q) {
    console.error("Postgres.js : Unknown Auth:", q);
  }
  function Gi(P, q, fe = "", Ve = "") {
    let et, Ot;
    return (
      pe()
        .B()
        .str(Ve + pe.N)
        .str(fe + pe.N)
        .i16(0)
        .i16(P.length),
      P.forEach((zt, Pr) => {
        if (zt === null) return pe.i32(4294967295);
        (Ot = q[Pr]),
          (P[Pr] = zt = Ot in e.serializers ? e.serializers[Ot](zt) : "" + zt),
          (et = pe.i),
          pe
            .inc(4)
            .str(zt)
            .i32(pe.i - et - 4, et);
      }),
      pe.i16(0),
      pe.end()
    );
  }
  function Xn(P, q, fe, Ve = "") {
    return (
      pe()
        .P()
        .str(Ve + pe.N)
        .str(P + pe.N)
        .i16(q.length),
      q.forEach((et, Ot) => pe.i32(fe[Ot] || 0)),
      pe.end()
    );
  }
  function Ts(P, q = "") {
    return pe()
      .D()
      .str(P)
      .str(q + pe.N)
      .end();
  }
  function Gr(P = "", q = 0) {
    return Buffer.concat([
      pe()
        .E()
        .str(P + pe.N)
        .i32(q)
        .end(),
      qD,
    ]);
  }
  function Ps(P = "") {
    return Buffer.concat([
      pe()
        .C()
        .str("P")
        .str(P + pe.N)
        .end(),
      pe().S().end(),
    ]);
  }
  function da() {
    return (
      M ||
      pe()
        .inc(4)
        .i16(3)
        .z(2)
        .str(
          Object.entries(
            Object.assign({ user: a, database: c, client_encoding: "UTF8" }, e.connection),
          )
            .filter(([, P]) => P)
            .map(([P, q]) => P + pe.N + q)
            .join(pe.N),
        )
        .z(2)
        .end(0)
    );
  }
}
function iS(e) {
  let t = {},
    r = 5;
  for (let n = 5; n < e.length - 1; n++)
    e[n] === 0 && ((t[ete[e[r]]] = e.toString("utf8", r + 1, n)), (r = n + 1));
  return t;
}
function jD(e) {
  return aa.default.createHash("md5").update(e).digest("hex");
}
function Kd(e, t) {
  return aa.default.createHmac("sha256", e).update(t).digest();
}
function tte(e) {
  return aa.default.createHash("sha256").update(e).digest();
}
function rte(e, t) {
  let r = Math.max(e.length, t.length),
    n = Buffer.allocUnsafe(r);
  for (let s = 0; s < r; s++) n[s] = e[s] ^ t[s];
  return n;
}
function oS(e, t) {
  if (((t = typeof t == "function" ? t() : t), !t)) return { cancel: oa, start: oa };
  let r;
  return {
    cancel() {
      r && (clearTimeout(r), (r = null));
    },
    start() {
      r && clearTimeout(r), (r = setTimeout(n, t * 1e3, arguments));
    },
  };
  function n(s) {
    e.apply(null, s), (r = null);
  }
}
var FD = () => {};
function cS(e, t) {
  let r = new Map(),
    n = "postgresjs_" + Math.random().toString(36).slice(2),
    s = {},
    i,
    o,
    a = !1,
    u = (f.sql = e({
      ...t,
      transform: { column: {}, value: {}, row: {} },
      max: 1,
      fetch_types: !1,
      idle_timeout: null,
      max_lifetime: null,
      connection: { ...t.connection, replication: "database" },
      onclose: async function () {
        a ||
          ((o = null),
          (s.pid = s.secret = void 0),
          d(await h(u, n, t.publications)),
          r.forEach((y) => y.forEach(({ onsubscribe: _ }) => _())));
      },
      no_subscribe: !0,
    })),
    l = u.end,
    c = u.close;
  return (
    (u.end = async () => (
      (a = !0), o && (await new Promise((y) => (o.once("close", y), o.end()))), l()
    )),
    (u.close = async () => (o && (await new Promise((y) => (o.once("close", y), o.end()))), c())),
    f
  );
  async function f(y, _, S = FD, E = FD) {
    (y = ite(y)), i || (i = h(u, n, t.publications));
    let g = { fn: _, onsubscribe: S },
      m = r.has(y) ? r.get(y).add(g) : r.set(y, new Set([g])).get(y),
      T = () => {
        m.delete(g), m.size === 0 && r.delete(y);
      };
    return i.then((N) => (d(N), S(), o && o.on("error", E), { unsubscribe: T, state: s, sql: u }));
  }
  function d(y) {
    (o = y.stream), (s.pid = y.state.pid), (s.secret = y.state.secret);
  }
  async function h(y, _, S) {
    if (!S) throw new Error("Missing publication names");
    let E = await y.unsafe(
        `CREATE_REPLICATION_SLOT ${_} TEMPORARY LOGICAL pgoutput NOEXPORT_SNAPSHOT`,
      ),
      [g] = E,
      m = await y
        .unsafe(
          `START_REPLICATION SLOT ${_} LOGICAL ${g.consistent_point} (proto_version '1', publication_names '${S}')`,
        )
        .writable(),
      T = {
        lsn: Buffer.concat(
          g.consistent_point.split("/").map((v) => Buffer.from(("00000000" + v).slice(-8), "hex")),
        ),
      };
    return m.on("data", w), m.on("error", N), m.on("close", y.close), { stream: m, state: E.state };
    function N(v) {
      console.error("Unexpected error during logical streaming - reconnecting", v);
    }
    function w(v) {
      v[0] === 119
        ? ste(v.subarray(25), T, y.options.parsers, $, t.transform)
        : v[0] === 107 && v[17] && ((T.lsn = v.subarray(1, 9)), D());
    }
    function $(v, M) {
      let k = M.relation.schema + "." + M.relation.table;
      p("*", v, M),
        p("*:" + k, v, M),
        M.relation.keys.length && p("*:" + k + "=" + M.relation.keys.map((x) => v[x.name]), v, M),
        p(M.command, v, M),
        p(M.command + ":" + k, v, M),
        M.relation.keys.length &&
          p(M.command + ":" + k + "=" + M.relation.keys.map((x) => v[x.name]), v, M);
    }
    function D() {
      let v = Buffer.alloc(34);
      (v[0] = 114),
        v.fill(T.lsn, 1),
        v.writeBigInt64BE(BigInt(Date.now() - Date.UTC(2e3, 0, 1)) * BigInt(1e3), 25),
        m.write(v);
    }
  }
  function p(y, _, S) {
    r.has(y) && r.get(y).forEach(({ fn: E }) => E(_, S, y));
  }
}
function nte(e) {
  return new Date(Date.UTC(2e3, 0, 1) + Number(e / BigInt(1e3)));
}
function ste(e, t, r, n, s) {
  let i = (o, [a, u]) => ((o[a.charCodeAt(0)] = u), o);
  Object.entries({
    R: (o) => {
      let a = 1,
        u = (t[o.readUInt32BE(a)] = {
          schema: o.toString("utf8", (a += 4), (a = o.indexOf(0, a))) || "pg_catalog",
          table: o.toString("utf8", a + 1, (a = o.indexOf(0, a + 1))),
          columns: Array(o.readUInt16BE((a += 2))),
          keys: [],
        });
      a += 2;
      let l = 0,
        c;
      for (; a < o.length; )
        (c = u.columns[l++] =
          {
            key: o[a++],
            name: s.column.from
              ? s.column.from(o.toString("utf8", a, (a = o.indexOf(0, a))))
              : o.toString("utf8", a, (a = o.indexOf(0, a))),
            type: o.readUInt32BE((a += 1)),
            parser: r[o.readUInt32BE(a)],
            atttypmod: o.readUInt32BE((a += 4)),
          }),
          c.key && u.keys.push(c),
          (a += 4);
    },
    Y: () => {},
    O: () => {},
    B: (o) => {
      (t.date = nte(o.readBigInt64BE(9))), (t.lsn = o.subarray(1, 9));
    },
    I: (o) => {
      let a = 1,
        u = t[o.readUInt32BE(a)],
        { row: l } = Jd(o, u.columns, (a += 7), s);
      n(l, { command: "insert", relation: u });
    },
    D: (o) => {
      let a = 1,
        u = t[o.readUInt32BE(a)];
      a += 4;
      let l = o[a] === 75;
      n(l || o[a] === 79 ? Jd(o, u.columns, (a += 3), s).row : null, {
        command: "delete",
        relation: u,
        key: l,
      });
    },
    U: (o) => {
      let a = 1,
        u = t[o.readUInt32BE(a)];
      a += 4;
      let l = o[a] === 75,
        c = l || o[a] === 79 ? Jd(o, u.columns, (a += 3), s) : null;
      c && (a = c.i);
      let { row: f } = Jd(o, u.columns, a + 3, s);
      n(f, { command: "update", relation: u, key: l, old: c && c.row });
    },
    T: () => {},
    C: () => {},
  })
    .reduce(i, {})
    [e[0]](e);
}
function Jd(e, t, r, n) {
  let s,
    i,
    o,
    a = n.raw ? new Array(t.length) : {};
  for (let u = 0; u < t.length; u++)
    (s = e[r++]),
      (i = t[u]),
      (o =
        s === 110
          ? null
          : s === 117
            ? void 0
            : i.parser === void 0
              ? e.toString("utf8", r + 4, (r += 4 + e.readUInt32BE(r)))
              : i.parser.array === !0
                ? i.parser(e.toString("utf8", r + 5, (r += 4 + e.readUInt32BE(r))))
                : i.parser(e.toString("utf8", r + 4, (r += 4 + e.readUInt32BE(r))))),
      n.raw
        ? (a[u] = n.raw === !0 ? o : n.value.from ? n.value.from(o, i) : o)
        : (a[i.name] = n.value.from ? n.value.from(o, i) : o);
  return { i: r, row: n.row.from ? n.row.from(a) : a };
}
function ite(e) {
  let t = e.match(/^(\*|insert|update|delete)?:?([^.]+?\.?[^=]+)?=?(.+)?/i) || [];
  if (!t) throw new Error("Malformed subscribe pattern: " + e);
  let [, r, n, s] = t;
  return (
    (r || "*") + (n ? ":" + (n.indexOf(".") === -1 ? "public." + n : n) : "") + (s ? "=" + s : "")
  );
}
var fS = Jr(require("stream"), 1);
function dS(e, t, r = 393216) {
  return new Promise(async (n, s) => {
    await e
      .begin(async (i) => {
        let o;
        !t && ([{ oid: t }] = await i`select lo_creat(-1) as oid`);
        let [{ fd: a }] = await i`select lo_open(${t}, ${r}) as fd`,
          u = {
            writable: c,
            readable: l,
            close: () => i`select lo_close(${a})`.then(o),
            tell: () => i`select lo_tell64(${a})`,
            read: (f) => i`select loread(${a}, ${f}) as data`,
            write: (f) => i`select lowrite(${a}, ${f})`,
            truncate: (f) => i`select lo_truncate64(${a}, ${f})`,
            seek: (f, d = 0) => i`select lo_lseek64(${a}, ${f}, ${d})`,
            size: () => i`
          select
            lo_lseek64(${a}, location, 0) as position,
            seek.size
          from (
            select
              lo_lseek64($1, 0, 2) as size,
              tell.location
            from (select lo_tell64($1) as location) tell
          ) seek
        `,
          };
        return n(u), new Promise(async (f) => (o = f));
        async function l({ highWaterMark: f = 2048 * 8, start: d = 0, end: h = 1 / 0 } = {}) {
          let p = h - d;
          return (
            d && (await u.seek(d)),
            new fS.default.Readable({
              highWaterMark: f,
              async read(y) {
                let _ = y > p ? y - p : y;
                p -= y;
                let [{ data: S }] = await u.read(_);
                this.push(S), S.length < y && this.push(null);
              },
            })
          );
        }
        async function c({ highWaterMark: f = 2048 * 8, start: d = 0 } = {}) {
          return (
            d && (await u.seek(d)),
            new fS.default.Writable({
              highWaterMark: f,
              write(h, p, y) {
                u.write(h).then(() => y(), y);
              },
            })
          );
        }
      })
      .catch(s);
  });
}
Object.assign(Qd, {
  PostgresError: xi,
  toPascal: Mi,
  pascal: nS,
  toCamel: Fi,
  camel: rS,
  toKebab: zi,
  kebab: sS,
  fromPascal: cl,
  fromCamel: ll,
  fromKebab: fl,
  BigInt: { to: 20, from: [20], parse: (e) => BigInt(e), serialize: (e) => e.toString() },
});
var VD = Qd;
function Qd(e, t) {
  let r = ote(e, t),
    n = r.no_subscribe || cS(Qd, { ...r }),
    s = !1,
    i = Ur(),
    o = Ur(),
    a = Ur(),
    u = Ur(),
    l = Ur(),
    c = Ur(),
    f = Ur(),
    d = Ur(),
    h = { connecting: o, reserved: a, closed: u, ended: l, open: c, busy: f, full: d },
    p = [...Array(r.max)].map(() => lS(r, h, { onopen: G, onend: Z, onclose: Y })),
    y = _($);
  return (
    Object.assign(y, {
      get parameters() {
        return r.parameters;
      },
      largeObject: dS.bind(null, y),
      subscribe: n,
      CLOSE: sa,
      END: sa,
      PostgresError: xi,
      options: r,
      reserve: g,
      listen: S,
      begin: m,
      close: k,
      end: M,
    }),
    y
  );
  function _(U) {
    return (
      (U.debug = r.debug),
      Object.entries(r.types).reduce(
        (Se, [Ee, ue]) => ((Se[Ee] = (Re) => new Rn(Re, ue.to)), Se),
        z,
      ),
      Object.assign(oe, { types: z, typed: z, unsafe: Te, notify: E, array: w, json: N, file: ce }),
      oe
    );
    function z(Se, Ee) {
      return new Rn(Se, Ee);
    }
    function oe(Se, ...Ee) {
      return Se && Array.isArray(Se.raw)
        ? new Vr(Se, Ee, U, v)
        : typeof Se == "string" && !Ee.length
          ? new ia(r.transform.column.to ? r.transform.column.to(Se) : Se)
          : new ul(Se, Ee);
    }
    function Te(Se, Ee = [], ue = {}) {
      return (
        arguments.length === 2 && !Array.isArray(Ee) && ((ue = Ee), (Ee = [])),
        new Vr([Se], Ee, U, v, {
          prepare: !1,
          ...ue,
          simple: "simple" in ue ? ue.simple : Ee.length === 0,
        })
      );
    }
    function ce(Se, Ee = [], ue = {}) {
      return (
        arguments.length === 2 && !Array.isArray(Ee) && ((ue = Ee), (Ee = [])),
        new Vr(
          [],
          Ee,
          (ee) => {
            zD.default.readFile(Se, "utf8", (ve, Ae) => {
              if (ve) return ee.reject(ve);
              (ee.strings = [Ae]), U(ee);
            });
          },
          v,
          { ...ue, simple: "simple" in ue ? ue.simple : Ee.length === 0 },
        )
      );
    }
  }
  async function S(U, z, oe) {
    let Te = { fn: z, onlisten: oe },
      ce =
        S.sql ||
        (S.sql = Qd({
          ...r,
          max: 1,
          idle_timeout: null,
          max_lifetime: null,
          fetch_types: !1,
          onclose() {
            Object.entries(S.channels).forEach(([ee, { listeners: ve }]) => {
              delete S.channels[ee],
                Promise.all(ve.map((Ae) => S(ee, Ae.fn, Ae.onlisten).catch(() => {})));
            });
          },
          onnotify(ee, ve) {
            ee in S.channels && S.channels[ee].listeners.forEach((Ae) => Ae.fn(ve));
          },
        })),
      Se = S.channels || (S.channels = {});
    if (U in Se) {
      Se[U].listeners.push(Te);
      let ee = await Se[U].result;
      return Te.onlisten && Te.onlisten(), { state: ee.state, unlisten: Re };
    }
    Se[U] = { result: ce`listen ${ce.unsafe('"' + U.replace(/"/g, '""') + '"')}`, listeners: [Te] };
    let ue = await Se[U].result;
    return Te.onlisten && Te.onlisten(), { state: ue.state, unlisten: Re };
    async function Re() {
      if (
        U in Se &&
        ((Se[U].listeners = Se[U].listeners.filter((ee) => ee !== Te)), !Se[U].listeners.length)
      )
        return delete Se[U], ce`unlisten ${ce.unsafe('"' + U.replace(/"/g, '""') + '"')}`;
    }
  }
  async function E(U, z) {
    return await y`select pg_notify(${U}, ${"" + z})`;
  }
  async function g() {
    let U = Ur(),
      z = c.length
        ? c.shift()
        : await new Promise((ce) => {
            i.push({ reserve: ce }), u.length && ie(u.shift());
          });
    T(z, a),
      (z.reserved = () => (U.length ? z.execute(U.shift()) : T(z, a))),
      (z.reserved.release = !0);
    let oe = _(Te);
    return (
      (oe.release = () => {
        (z.reserved = null), G(z);
      }),
      oe
    );
    function Te(ce) {
      z.queue === d ? U.push(ce) : z.execute(ce) || T(z, d);
    }
  }
  async function m(U, z) {
    !z && ((z = U), (U = ""));
    let oe = Ur(),
      Te = 0,
      ce,
      Se = null;
    try {
      return (
        await y.unsafe("begin " + U.replace(/[^a-z ]/gi, ""), [], { onexecute: ue }).execute(),
        await Promise.race([Ee(ce, z), new Promise((Re, ee) => (ce.onclose = ee))])
      );
    } catch (Re) {
      throw Re;
    }
    async function Ee(Re, ee, ve) {
      let Ae = _(H);
      (Ae.savepoint = C), (Ae.prepare = (K) => (Se = K.replace(/[^a-z0-9$-_. ]/gi)));
      let Oe, me;
      ve && (await Ae`savepoint ${Ae(ve)}`);
      try {
        if (
          ((me = await new Promise((K, te) => {
            let _e = ee(Ae);
            Promise.resolve(Array.isArray(_e) ? Promise.all(_e) : _e).then(K, te);
          })),
          Oe)
        )
          throw Oe;
      } catch (K) {
        throw (
          (await (ve ? Ae`rollback to ${Ae(ve)}` : Ae`rollback`),
          (K instanceof xi && K.code === "25P02" && Oe) || K)
        );
      }
      return ve || (Se ? await Ae`prepare transaction '${Ae.unsafe(Se)}'` : await Ae`commit`), me;
      function C(K, te) {
        return K && Array.isArray(K.raw)
          ? C((_e) => _e.apply(_e, arguments))
          : (arguments.length === 1 && ((te = K), (K = null)),
            Ee(Re, te, "s" + Te++ + (K ? "_" + K : "")));
      }
      function H(K) {
        K.catch((te) => Oe || (Oe = te)), Re.queue === d ? oe.push(K) : Re.execute(K) || T(Re, d);
      }
    }
    function ue(Re) {
      (ce = Re), T(Re, a), (Re.reserved = () => (oe.length ? Re.execute(oe.shift()) : T(Re, a)));
    }
  }
  function T(U, z) {
    return (
      U.queue.remove(U),
      z.push(U),
      (U.queue = z),
      z === c ? U.idleTimer.start() : U.idleTimer.cancel(),
      U
    );
  }
  function N(U) {
    return new Rn(U, 3802);
  }
  function w(U, z) {
    return Array.isArray(U)
      ? new Rn(U, z || (U.length ? Vd(U) || 25 : 0), r.shared.typeArrayMap)
      : w(Array.from(arguments));
  }
  function $(U) {
    if (s) return U.reject(xt.connection("CONNECTION_ENDED", r, r));
    if (c.length) return D(c.shift(), U);
    if (u.length) return ie(u.shift(), U);
    f.length ? D(f.shift(), U) : i.push(U);
  }
  function D(U, z) {
    return U.execute(z) ? T(U, f) : T(U, d);
  }
  function v(U) {
    return new Promise((z, oe) => {
      U.state
        ? U.active
          ? lS(r).cancel(U.state, z, oe)
          : (U.cancelled = { resolve: z, reject: oe })
        : (i.remove(U),
          (U.cancelled = !0),
          U.reject(xt.generic("57014", "canceling statement due to user request")),
          z());
    });
  }
  async function M({ timeout: U = null } = {}) {
    if (s) return s;
    await 1;
    let z;
    return (s = Promise.race([
      new Promise((oe) => U !== null && (z = setTimeout(x, U * 1e3, oe))),
      Promise.all(
        p
          .map((oe) => oe.end())
          .concat(S.sql ? S.sql.end({ timeout: 0 }) : [], n.sql ? n.sql.end({ timeout: 0 }) : []),
      ),
    ]).then(() => clearTimeout(z)));
  }
  async function k() {
    await Promise.all(p.map((U) => U.end()));
  }
  async function x(U) {
    for (await Promise.all(p.map((z) => z.terminate())); i.length; )
      i.shift().reject(xt.connection("CONNECTION_DESTROYED", r));
    U();
  }
  function ie(U, z) {
    return T(U, o), U.connect(z), U;
  }
  function Z(U) {
    T(U, l);
  }
  function G(U) {
    if (i.length === 0) return T(U, c);
    let z = Math.ceil(i.length / (o.length + 1)),
      oe = !0;
    for (; oe && i.length && z-- > 0; ) {
      let Te = i.shift();
      if (Te.reserve) return Te.reserve(U);
      oe = U.execute(Te);
    }
    oe ? T(U, f) : T(U, d);
  }
  function Y(U, z) {
    T(U, u),
      (U.reserved = null),
      U.onclose && (U.onclose(z), (U.onclose = null)),
      r.onclose && r.onclose(U.id),
      i.length && ie(U, i.shift());
  }
}
function ote(e, t) {
  if (e && e.shared) return e;
  let r = process.env,
    n = (!e || typeof e == "string" ? t : e) || {},
    { url: s, multihost: i } = fte(e),
    o = [...s.searchParams].reduce((d, [h, p]) => ((d[h] = p), d), {}),
    a = n.hostname || n.host || i || s.hostname || r.PGHOST || "localhost",
    u = n.port || s.port || r.PGPORT || 5432,
    l = n.user || n.username || s.username || r.PGUSERNAME || r.PGUSER || dte();
  n.no_prepare && (n.prepare = !1),
    o.sslmode && ((o.ssl = o.sslmode), delete o.sslmode),
    "timeout" in n &&
      (console.log("The timeout option is deprecated, use idle_timeout instead"),
      (n.idle_timeout = n.timeout)),
    o.sslrootcert === "system" && (o.ssl = "verify-full");
  let c = [
      "idle_timeout",
      "connect_timeout",
      "max_lifetime",
      "max_pipeline",
      "backoff",
      "keep_alive",
    ],
    f = {
      max: 10,
      ssl: !1,
      idle_timeout: null,
      connect_timeout: 30,
      max_lifetime: lte,
      max_pipeline: 100,
      backoff: ute,
      keep_alive: 60,
      prepare: !0,
      debug: !1,
      fetch_types: !0,
      publications: "alltables",
      target_session_attrs: null,
    };
  return {
    host: Array.isArray(a) ? a : a.split(",").map((d) => d.split(":")[0]),
    port: Array.isArray(u) ? u : a.split(",").map((d) => parseInt(d.split(":")[1] || u)),
    path: n.path || (a.indexOf("/") > -1 && a + "/.s.PGSQL." + u),
    database: n.database || n.db || (s.pathname || "").slice(1) || r.PGDATABASE || l,
    user: l,
    pass: n.pass || n.password || s.password || r.PGPASSWORD || "",
    ...Object.entries(f).reduce((d, [h, p]) => {
      let y =
        h in n
          ? n[h]
          : h in o
            ? o[h] === "disable" || o[h] === "false"
              ? !1
              : o[h]
            : r["PG" + h.toUpperCase()] || p;
      return (d[h] = typeof y == "string" && c.includes(h) ? +y : y), d;
    }, {}),
    connection: {
      application_name: "postgres.js",
      ...n.connection,
      ...Object.entries(o).reduce((d, [h, p]) => (h in f || (d[h] = p), d), {}),
    },
    types: n.types || {},
    target_session_attrs: ate(n, s, r),
    onnotice: n.onnotice,
    onnotify: n.onnotify,
    onclose: n.onclose,
    onparameter: n.onparameter,
    socket: n.socket,
    transform: cte(n.transform || { undefined: void 0 }),
    parameters: {},
    shared: { retries: 0, typeArrayMap: {} },
    ...AD(n.types),
  };
}
function ate(e, t, r) {
  let n =
    e.target_session_attrs || t.searchParams.get("target_session_attrs") || r.PGTARGETSESSIONATTRS;
  if (!n || ["read-write", "read-only", "primary", "standby", "prefer-standby"].includes(n))
    return n;
  throw new Error("target_session_attrs " + n + " is not supported");
}
function ute(e) {
  return (0.5 + Math.random() / 2) * Math.min(3 ** e / 100, 20);
}
function lte() {
  return 60 * (30 + Math.random() * 30);
}
function cte(e) {
  return {
    undefined: e.undefined,
    column: {
      from: typeof e.column == "function" ? e.column : e.column && e.column.from,
      to: e.column && e.column.to,
    },
    value: {
      from: typeof e.value == "function" ? e.value : e.value && e.value.from,
      to: e.value && e.value.to,
    },
    row: { from: typeof e.row == "function" ? e.row : e.row && e.row.from, to: e.row && e.row.to },
  };
}
function fte(e) {
  if (!e || typeof e != "string") return { url: { searchParams: new Map() } };
  let t = e;
  (t = t.slice(t.indexOf("://") + 3).split(/[?/]/)[0]),
    (t = decodeURIComponent(t.slice(t.indexOf("@") + 1)));
  let r = new URL(e.replace(t, t.split(",")[0]));
  return {
    url: {
      username: decodeURIComponent(r.username),
      password: decodeURIComponent(r.password),
      host: r.host,
      hostname: r.hostname,
      port: r.port,
      pathname: r.pathname,
      searchParams: r.searchParams,
    },
    multihost: t.indexOf(",") > -1 && t,
  };
}
function dte() {
  try {
    return MD.default.userInfo().username;
  } catch {
    return process.env.USERNAME || process.env.USER || process.env.LOGNAME;
  }
}
var dj = Jr(lj());
var cj = Jr(Cp()),
  qS = (0, cj.default)({ transport: { target: "pino-pretty" } });
var fj,
  hj = async () => {
    let e = VD(process.env.DATABASE_URL || "");
    qS.info(`DB_URL: ${process.env.DATABASE_URL}`);
    class t {
      write(n) {
        qS.debug(n);
      }
    }
    return (fj = bD(e, { schema: dj.schemas, logger: new Zo({ writer: new t() }) })), fj;
  };
var Jre = process.env.NODE_ENV === "prop" ? ".env.prod" : ".env";
mj.default.config({ path: (0, LS.join)(__dirname, `../../../apps/api/${Jre}`) });
var jS = (0, yj.default)({
  logger: {
    transport: {
      target: "pino-pretty",
      options: {
        destination: 1,
        colorize: !0,
        translateTime: "HH:MM:ss.l",
        ignore: "pid,hostname",
      },
    },
  },
});
jS.register(pj.default, { dir: (0, LS.join)(__dirname, "routes") });
var Qre = async () => {
  try {
    await hj(), await jS.listen({ port: 3008 });
  } catch (e) {
    jS.log.error(e), process.exit(1);
  }
};
Qre();
/*! Bundled license information:

forwarded/index.js:
  (*!
   * forwarded
   * Copyright(c) 2014-2017 Douglas Christopher Wilson
   * MIT Licensed
   *)

proxy-addr/index.js:
  (*!
   * proxy-addr
   * Copyright(c) 2014-2016 Douglas Christopher Wilson
   * MIT Licensed
   *)

toad-cache/dist/toad-cache.cjs:
  (**
   * toad-cache
   *
   * @copyright 2024 Igor Savin <kibertoad@gmail.com>
   * @license MIT
   * @version 3.7.0
   *)

uri-js/dist/es5/uri.all.js:
  (** @license URI.js v4.4.1 (c) 2011 Gary Court. License: http://github.com/garycourt/uri-js *)

cookie/index.js:
  (*!
   * cookie
   * Copyright(c) 2012-2014 Roman Shtylman
   * Copyright(c) 2015 Douglas Christopher Wilson
   * MIT Licensed
   *)

light-my-request/lib/form-data.js:
  (*! formdata-polyfill. MIT License. Jimmy Wärting <https://jimmy.warting.se/opensource> *)

@noble/hashes/utils.js:
  (*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) *)
*/
//# sourceMappingURL=index.js.map
